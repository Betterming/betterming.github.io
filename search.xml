<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BST Summary]]></title>
    <url>%2F%2Fposts%2F</url>
    <content type="text"><![CDATA[Data Structure – BST1. 定义：BST(Binary Search Tree)或者是一棵空树，或者是具有下列性质的二叉树： 若左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若右子树不空，则右子树上所有结点的值均大于它的根结点的值； 左、右子树也分别为二叉排序树； 没有键值相等的节点。 2.基本操作主要包括：查找、插入、建立、删除1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798struct node &#123; int data; node *lchild; node *rchild;&#125;;// 新建节点，返回一个节点指针node* newNode(int v)&#123; node* Node = new node; Node-&gt;data = v; Node-&gt;lchild = Node-&gt;rchild = NULL; return Node;&#125;// search x 只需搜索一边子树即可,O(h) h表示树高void search(node* root, int x)&#123; if(root == NULL) &#123; printf(&quot;search failed!\n&quot;); return; &#125; if(x == root-&gt;data) printf(&quot;%d\n&quot;, root-&gt;data); else if(x &lt; root-&gt;data) search(root-&gt;lchild, int x); else search(root-&gt;rchild, int x);&#125;// insert x 当root==NULL时，即为插入之处 O(h)void insert(node* &amp;root, int x)&#123; if(root == NULL)&#123; root = newNode(x); return; &#125; if(x == root-&gt;data) return; else if(x &lt; root-&gt;data) insert(root-&gt;lchild, x); else insert(root-&gt;rchild, x);&#125;// BST的建立(注意：同一组数据，如果插入的顺序不同最后形成的BST可能也不同)// 复杂度O(h)*n = O(nlog2n)node *Create(int data[], int n)&#123; node* root = NULL; for (int i = 0; i &lt; n; ++i) &#123; insert(root, data[i]); &#125; return root;&#125;//BST的节点删除，删除根节点//删除根节点后，用直接后继或者直接前驱来替换//直接前驱：左子树一直向右直到某一节点的右子树为NULL的节点//直接后继：右子树一直向左直到某一节点的左子树为NULL的节点//FindMin()函数用于寻找树root的最小权值节点node* FindMin(node* root)&#123; while(root-&gt;lchild != NULL) root = root-&gt;lchild; return root;&#125;//FindMax()函数用于寻找树root的最大权值节点node* FindMax(node* root)&#123; while(root-&gt;rchild != NULL) root = root-&gt;rchild; return root;&#125;/*BST删除节点步骤:1. 当前节点root空，直接返回2. 当前节点root的data值等于x，进入删除操作 a)当前节点root为叶子节点，直接删除。 b)当前节点root存在左子树，找到前驱pre，覆盖root，删除pre c)当前节点root存在右子树，找到后继next，覆盖root，删除next3. 若当前节点root权值大于x，则root = root-&gt;lchild 递归删除4. 若当前节点root权值小于x，则root = root-&gt;rchild 递归删除*/void deleteNode(node* &amp;root, int x)&#123; if(root == NULL) return; if(root-&gt;data == x) &#123; if(root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) root = NULL; else if(root-&gt;lchild != NULL) &#123; node *pre = FindMax(root-&gt;lchild); root-&gt;data = pre-&gt;data; deleteNode(root-&gt;lchild, pre-&gt;data); //删除pre节点 &#125; else &#123; node* next = FindMin(root-&gt;rchild); root-&gt;data = next-&gt;data; deleteNode(root-&gt;rchild, next-&gt;data); //删除next 节点 &#125; &#125; else if(root-&gt;data &gt; x) deleteNode(root-&gt;lchild, x); else deleteNode(root-&gt;rchild, x);&#125; 3. 应用利用PAT1043_Is It a Binary Search Tree 来练习一下BST。 1043 Is It a Binary Search Tree （25 分）A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. If we swap the left and right subtrees of every node, then the resulting tree is called the Mirror Image of a BST.Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST. Input Specification: Each input file contains one test case. For each case, the first line contains a positive integer N (≤1000). Then N integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification: For each test case, first print in a line YES if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or NO if not. Then if the answer is YES, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1:1278 6 5 7 10 8 11 Sample Output 1:12YES5 7 6 8 11 10 8 Sample Input 2:1278 10 11 8 6 7 5 Sample Output 2:12YES11 8 10 7 5 6 8 Sample Input 3:1278 6 8 5 10 9 11 Sample Output 3:1NO Code and Analysis:(1) 题意：判断给定序列是不是BST或者BST的镜像的先序遍历序列。是，输出YES和后序遍历序列；否，输出NO结束。(2) 思路步骤： 对给定的序列建立BST 对BST先序遍历，后序遍历，BST镜像先序遍历，BST镜像后序遍历 将给定序列与BST先序遍历，BST镜像先序遍历比较，相等，输出YES和对应后序序列，不相等，输出NO。 (3) 数据结构：用vector存储给定序列origin, BST先序序列pre, BST后序序列post, BST镜像先序序列preM, BST镜像后序序列postM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;struct node&#123; int data; node* lchild; node* rchild;&#125;;void insert(node* &amp;root, int x)&#123; if(root == NULL) &#123; root = new node; root-&gt;data = x; root-&gt;lchild = root-&gt;rchild = NULL; return; &#125; else if(root-&gt;data &gt; x) insert(root-&gt;lchild, x); else insert(root-&gt;rchild, x);&#125;// 先序遍历：中左右 --- 镜像先序遍历：中右左// 后序遍历：左右中 --- 镜像后序遍历：右左中// 中序遍历：左中右 --- 镜像中序遍历：右中左void preOrder(node* root, vector&lt;int&gt;&amp;vi)&#123; if(root == NULL) return; vi.push_back(root-&gt;data); preOrder(root-&gt;lchild, vi); preOrder(root-&gt;rchild, vi);&#125;void preMirror(node* root, vector&lt;int&gt;&amp;vi)&#123; if(root == NULL) return; vi.push_back(root-&gt;data); preMirror(root-&gt;rchild, vi); preMirror(root-&gt;lchild, vi);&#125;void postOrder(node* root, vector&lt;int&gt;&amp;vi)&#123; if(root == NULL) return; postOrder(root-&gt;lchild, vi); postOrder(root-&gt;rchild, vi); vi.push_back(root-&gt;data);&#125;void postMirror(node* root, vector&lt;int&gt;&amp;vi)&#123; if(root == NULL) return; postMirror(root-&gt;rchild, vi); postMirror(root-&gt;lchild, vi); vi.push_back(root-&gt;data);&#125;vector&lt;int&gt; origin, pre, post, preM, postM;int main(int argc, char const *argv[])&#123; int n, data; node* root = new node; root = NULL; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, &amp;data); origin.push_back(data); insert(root, data); &#125; preOrder(root, pre); preMirror(root, preM); postOrder(root, post); postMirror(root, postM); if(origin == pre)&#123; printf(&quot;YES\n&quot;); for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d&quot;,post[i]); if(i &lt; n-1) printf(&quot; &quot;); &#125; &#125; else if(origin == preM)&#123; printf(&quot;YES\n&quot;); for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d&quot;, postM[i]); if(i &lt; n-1) printf(&quot; &quot;); &#125; &#125; else printf(&quot;NO\n&quot;); return 0;&#125;/*78 6 5 7 10 8 11 */]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>PAT</tag>
        <tag>Traversal</tag>
        <tag>Order</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表基本操作二]]></title>
    <url>%2F%2Fposts%2F</url>
    <content type="text"><![CDATA[三、链表实现代码与分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct Node &#123; char *SchoolNumber; char *Name; int Age; struct Node *Next;&#125;;typedef struct Node *Link;// 实现字符串信息转换成相应节点信息struct Node Str_Node(char *buffer) &#123; char *p[3]; char *temp; struct Node n; int i = 0; temp = strdup(strtok(buffer, &quot;,&quot;)); //字符串的分割 while(temp) &#123; p[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; n.SchoolNumber = p[0]; n.Name = p[1]; n.Age = atoi(p[2]); n.Next = NULL; return n;&#125;// 打印单个节点void Print(Link &amp;Head, int op_number)&#123; if(op_number == 0)&#123; printf(&quot;Error!\n&quot;); return ; &#125; Link p; p = Head; for(int i = 0; i &lt; op_number; i++)&#123; p = p-&gt;Next; &#125; printf(&quot;%-10d&quot;, op_number); printf(&quot;%-15x&quot;, p); printf(&quot;%-15s&quot;, p-&gt;SchoolNumber); printf(&quot;%-15s&quot;, p-&gt;Name); printf(&quot;%-15d\n&quot;, p-&gt;Age);&#125;//插入节点void InsertNode(Link &amp;Head, Node n, int &amp;NodeCount, int i)&#123; Link p; p = Head; for(int j = 0; j &lt; i-1; j++)&#123; p = p-&gt;Next; &#125; n.Next = p-&gt;Next; p-&gt;Next = &amp;n; NodeCount++;&#125;//删除节点void DeleteNode(Link &amp;Head, int &amp;NodeCount, int i)&#123; Link p, r; p = Head; for(int j = 0; j &lt; i; j++ ) &#123; r = p; p = p-&gt;Next; &#125; r-&gt;Next = p-&gt;Next; free(p); NodeCount--;&#125;// 主函数int main()&#123; FILE *fp; char buffer[100]; char operate[50]; int op_number; Link Head = (Link)malloc(sizeof(struct Node)); Head-&gt;Next = NULL; int NodeCount = 0; Link p = (Link)malloc(sizeof(struct Node)); p = Head; printf(&quot;Number PhysiAddr SchoolNumber Name Age\n&quot;); if((fp = fopen(&quot;Lab1test.DAT&quot;, &quot;rt&quot;)) != NULL) &#123; while(fgets(buffer, 99, fp) != NULL) &#123; Link temp = (Link)malloc(sizeof(struct Node)); *temp = Str_Node(buffer); p-&gt;Next = temp; p = p-&gt;Next; NodeCount++; &#125; fclose(fp); &#125; for(int i = 0; i &lt; NodeCount; i++) Print(Head, i+1); while(1)&#123; printf(&quot;Please enter Pi, Di or Ii(i&lt;%d):\n&quot;,NodeCount); scanf(&quot;%s&quot;,operate); if(operate[0] == &apos;0&apos;) break; if(operate[0] == &apos;P&apos;) &#123; op_number = atoi(operate + 1); Print(Head, op_number); &#125; else if(operate[0] == &apos;I&apos;)&#123; char *t[4]; char *temp; int i = 0; Node n; temp = strdup(strtok(operate, &quot;,&quot;)); while(temp)&#123; t[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; int number = atoi(operate + 1); n.SchoolNumber = t[1]; n.Name = t[2]; n.Age = atoi(t[3]); InsertNode(Head, n, NodeCount, number); for(int i = 0; i &lt; NodeCount; i++)&#123; Print(Head, i+1); &#125; &#125; else if(operate[0] == &apos;D&apos;) &#123; op_number = atoi(operate + 1); DeleteNode(Head, NodeCount, op_number); for(int i = 0; i &lt; NodeCount; i++)&#123; Print(Head, i+1); &#125; &#125; else printf(&quot;Error!\n&quot;); &#125; return 0;&#125; 四、所遇到的“坑” 在布局输出结果时，使用\t并不能解决，需要使用类似于”%-15x”的格式化输出搞定。 在打印节点时，老是从学号后面开始出现乱码，这种情况，要么是转化时出现问题，要么是创建链表时出问题。在103行，进行节点输出，发现没问题，那么就是转化出问题。将这部分进行单拎出来，用char buffer[] = “SA12345678,小明,22”测试，发现乱码，果然是这部分有问题。与顺序表的转化部分对比，发现一个返回结构体，一个返回结构体指针。以下是出错代码：123456789101112131415161718192021Link Str_Node(char *buffer) &#123; char *p[3]; char *temp; Link NewNode = (Link)malloc(sizeof(struct Node)); int i = 0; temp = strdup(strtok(buffer, &quot;,&quot;)); while(temp) &#123; p[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; NewNode-&gt;SchoolNumber = p[0]; NewNode-&gt;Name = p[1]; NewNode-&gt;Age = atoi(p[2]); NewNode-&gt;Next = NULL; return NewNode;&#125; 将其改为返回结构体得以解决。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表的操作一]]></title>
    <url>%2F%2Fposts%2F</url>
    <content type="text"><![CDATA[Data Structure – Linear_list一、要求：&emsp;&emsp;首先，逐行读取指定文件中的数据，并进行解析后保存在顺序表中。其中，文件中每行数据格式为“学号,姓名,年龄”，比如“SA10225048,张三,24”。（提示：采用顺序表结构时，顺序表中每个表元素包含三类信息：学号，姓名，和年龄；采用单链表结构时，单链表中每个结点的数据域包含三类信息：学号，姓名，和年龄。）再根据键盘输入进行相关操作（查找，删除和插入）。比如，若键盘输入为“P3”，则表示打印出第3项的信息（注意：采用顺序表结构时，第3项数据对应下标为2的表元素；采用单链表结构时，第3项数据对应链表中第3个结点的信息；）；若键盘输入为“D3”，则表示删除第3个表元素；若键盘输入为“I3,SA10225038,张四,24”，则表示在第3项前插入一个学生的信息（SA10225038,张四,24）。 附件可以把以下数据复制到txt文档，然后改名为studentinfo.data。将这个文件和cpp文件放在同一个目录下。 SA10225048,张三,24SG10225132,李四,22连续子向量中的最大和SG10225027,王五,24SA10225213,赵六,25SA10225197,欧阳奋强,23SG10225059,孙八,24SA10225083,余久,23SA10225112,张唯一,24 二、顺序表实现代码与分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define maxn 100struct Node &#123; char *SchoolNumber; char *Name; int Age;&#125;ArrNode[maxn];// 实现字符串信息转换成相应节点信息struct Node Str_Node(char *buffer) &#123; char *p[3]; char *temp; struct Node n; int i = 0; temp = strdup(strtok(buffer, &quot;,&quot;)); while(temp) &#123; p[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; n.SchoolNumber = p[0]; n.Name = p[1]; n.Age = atoi(p[2]); return n;&#125;// 打印所有节点void Print(int NodeCount)&#123; for(int i = 0; i &lt; NodeCount; i++)&#123; printf(&quot;%-10d&quot;, i+1); printf(&quot;%-15x&quot;, ArrNode + i); printf(&quot;%-15s&quot;, ArrNode[i].SchoolNumber); printf(&quot;%-15s&quot;, ArrNode[i].Name); printf(&quot;%-15d\n&quot;, ArrNode[i].Age); &#125;&#125;// 插入节点void InsertNode(struct Node n, int &amp;NodeCount, int i)&#123; for(int j = NodeCount; j &gt;= i; j--)&#123; ArrNode[j].SchoolNumber = ArrNode[j-1].SchoolNumber; ArrNode[j].Name = ArrNode[j-1].Name; ArrNode[j].Age = ArrNode[j-1].Age; &#125; ArrNode[i-1].SchoolNumber = n.SchoolNumber; ArrNode[i-1].Name = n.Name; ArrNode[i-1].Age = n.Age; NodeCount++;&#125;// 删除节点void DeleteNode(int &amp;NodeCount, int i)&#123; for(int j = i; j &lt; NodeCount; j++)&#123; ArrNode[j - 1].SchoolNumber = ArrNode[j].SchoolNumber; ArrNode[j - 1].Name = ArrNode[j].Name; ArrNode[j - 1].Age = ArrNode[j].Age; &#125; NodeCount--;&#125;int main()&#123; FILE *fp; char buffer[100]; int NodeCount = 0; char operate[30]; int op_number; if((fp = fopen(&quot;studentinfo.data&quot;, &quot;rt&quot;)) != NULL) &#123; while(fgets(buffer, 99, fp) != NULL) &#123; ArrNode[NodeCount++] = Str_Node(buffer); &#125; fclose(fp); &#125; printf(&quot;Number PhysiAddr SchoolNumber Name Age\n&quot;); Print(NodeCount); while(1)&#123; printf(&quot;Please enter Pi, Di or Ii(i&lt;%d):\n&quot;,NodeCount); scanf(&quot;%s&quot;,operate); if(operate[0] == &apos;0&apos;) break; if(operate[0] == &apos;P&apos;) &#123; op_number = atoi(operate + 1); printf(&quot;%-10d&quot;, op_number); printf(&quot;%-15x&quot;, ArrNode + op_number - 1); printf(&quot;%-15s&quot;, ArrNode[op_number - 1].SchoolNumber); printf(&quot;%-15s&quot;, ArrNode[op_number - 1].Name); printf(&quot;%-15d\n&quot;, ArrNode[op_number - 1].Age); &#125; else if(operate[0] == &apos;I&apos;)&#123; char *t[4]; char *temp; int i = 0; struct Node n; temp = strdup(strtok(operate, &quot;,&quot;)); while(temp)&#123; t[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; int number = atoi(operate + 1); n.SchoolNumber = t[1]; n.Name = t[2]; n.Age = atoi(t[3]); InsertNode(n, NodeCount, number); Print(NodeCount); &#125; else if(operate[0] == &apos;D&apos;) &#123; op_number = atoi(operate + 1); DeleteNode(NodeCount, op_number); Print(NodeCount); &#125; else printf(&quot;Error!\n&quot;); &#125; return 0;&#125; 使用的是顺序表结构来实现线性表的基本操作，明天采用链表结构来实现。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy学习一]]></title>
    <url>%2F%2Fposts%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本期将会涉及到Python模块中的numpy，这是一个处理数组的强大模块，而该模块也是其他数据分析模块（如pandas和scipy）的核心。 一、数组的创建 np.array(list,tuple,array类型) np.arange,一维数组中的range ones,ones_like,zeros,zeros_like,empty,empty_like eye,identity #单位矩阵 full #全为指定数矩阵 linspace(0,20,10)In:1234567arr1 = np.array(range(10)).reshape(2,5)arr2 = np.arange(10).reshape(2,5)arr3 = np.ones((2,5))arr4 = np.zeros_like(arr1)arr5 = np.eye(5)arr6 = np.full((2, 5), 3)np.linspace(0,20,10) #在0 和 20 包括0,20等长的截取10个点 Out:123456789101112131415161718192021222324252627282930313233343536arr1Out[5]:array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])arr2Out[6]:array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])arr3Out[7]:array([[1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.]])arr4Out[8]:array([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]])arr5Out[9]:array([[1., 0., 0., 0., 0.], [0., 1., 0., 0., 0.], [0., 0., 1., 0., 0.], [0., 0., 0., 1., 0.], [0., 0., 0., 0., 1.]])arr6Out[10]:array([[3, 3, 3, 3, 3], [3, 3, 3, 3, 3]])Out[11]:array([ 0. , 2.22222222, 4.44444444, 6.66666667, 8.88888889, 11.11111111, 13.33333333, 15.55555556, 17.77777778, 20. ]) 二、数组的基本操作123456789101112131415161718192021In[25]:arr1Out[25]:array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])In [26]:arr2Out[26]:array([ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19])In [28]:arr3=arr2.reshape(2,5) #reshape 改变类型In [29]:arr3.shape#不该变arr3自身Out[29]:(2, 5)In [30]:arr3.size #元素个数Out[30]:10In [31]:arr3.ndim #元素维度Out[31]:2 三、矩阵元素访问123456789101112131415161718192021222324252627282930313233343536373839In [32]:arr3[:]Out[32]:array([[ 1, 3, 5, 7, 9], [11, 13, 15, 17, 19]])In [33]:arr3[1,3] #arr3[1,3]和arr3[1][3]一样但是推荐使用前者Out[33]:17In [34]:x = np.array(range(12)).reshape(3, 4) xOut[34]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])In [35]:x[::-1,::-1] #步长为-1表示从后往前数Out[35]:array([[11, 10, 9, 8], [ 7, 6, 5, 4], [ 3, 2, 1, 0]])In [36]:subx=x[:2,:3] #切片访问 subx改变值不会改变arr3值 subxOut[36]:array([[0, 1, 2], [4, 5, 6]])In [37]:subx=x[:2,2:] subxOut[37]:array([[2, 3], [6, 7]])In [38]:subx[0,1]=100In [39]:print(arr3)#改变arr3中子矩阵，arr3也会改变，是引用方式Out[39]:[[ 1 3 5 7 9] [11 13 15 17 19]] 四、合并操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061In [40]:x=np.array([1,2,3]) y=np.array([3,1,2])In [41]:np.concatenate([x,y])Out[41]:array([1, 2, 3, 3, 1, 2])In [42]:np.concatenate([x,y],axis=0)Out[42]:array([1, 2, 3, 3, 1, 2])In [43]:A = np.array([[1,2,3], [4,5,6]])In [44]:np.concatenate([A,A]) #默认垂直合并 concatenate只能处理同类型矩阵Out[44]:array([[1, 2, 3], [4, 5, 6], [1, 2, 3], [4, 5, 6]])In [45]:np.concatenate([A,A],axis = 1)Out[45]:array([[1, 2, 3, 1, 2, 3], [4, 5, 6, 4, 5, 6]])In [46]:z = np.array([666,666,666])In [47]:np.concatenate([A, z.reshape(1,-1)]) #针对concatenate只能同类型矩阵，可以用（1，-1）表示一行，列数随机的方法Out[47]:array([[ 1, 2, 3], [ 4, 5, 6], [666, 666, 666]])In [48]:np.vstack([A,z])#垂直堆叠合并Out[48]:array([[ 1, 2, 3], [ 4, 5, 6], [666, 666, 666]])In [49]:B = np.full((2,2),100) BOut[49]:array([[100, 100], [100, 100]])In [50]:arr4 = np.array(range(12)).reshape(3,4)In [51]:print(arr4)Out[51]:[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]]In [52]:np.hstack([arr4,arr4]) #水平堆叠合并Out[52]:array([[ 0, 1, 2, 3, 0, 1, 2, 3], [ 4, 5, 6, 7, 4, 5, 6, 7], [ 8, 9, 10, 11, 8, 9, 10, 11]])In [53]:np.hstack([arr4,arr4])Out[53]:array([[ 0, 1, 2, 3, 0, 1, 2, 3], [ 4, 5, 6, 7, 4, 5, 6, 7], [ 8, 9, 10, 11, 8, 9, 10, 11]]) 五、分割 split12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485In [54]:arr5=np.array(range(10))In [55]:x1,x2,x3=np.split(arr5,[3,7])#arr5 分割矩阵，【3,7】为分割点列表In [56]:print(x1)Out[56]:[0 1 2]In [57]:x2Out[57]:array([3, 4, 5, 6])In [58]:x3Out[58]:array([7, 8, 9])In [59]:x1,x2 = np.split(arr5,[5]) x1,x2Out[59]:(array([0, 1, 2, 3, 4]), array([5, 6, 7, 8, 9]))In [60]:arr6=np.array(range(16)).reshape(4,4) arr6Out[60]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])In [61]:a1,a2 = np.split(arr6, [2]) #当arr6为二维数组时，【2】表示前两行为分割处 a1Out[61]:array([[0, 1, 2, 3], [4, 5, 6, 7]])In [62]:a2Out[62]:array([[ 8, 9, 10, 11], [12, 13, 14, 15]])In [63]:A1,A2 = np.split(arr6, [2], axis = 1) #axis=1 表示列分割 A1,A2Out[63]:(array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]]), array([[ 2, 3], [ 6, 7], [10, 11], [14, 15]]))In [64]:up,down =np.vsplit(arr6,[-1]) #垂直切割，表示分成上下部分In [65]:up,downOut[65]:(array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]), array([[12, 13, 14, 15]]))In [66]:left,right = np.hsplit(arr6,[2]) #水平切割，表示分成左右部分 left,rightOut[66]:(array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]]), array([[ 2, 3], [ 6, 7], [10, 11], [14, 15]]))In [67]:data = np.arange(16).reshape(4,4) dataOut[67]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])In [82]:x,y = np.hsplit(data,[-1]) # data表示数据集，前三个为特征，后一个为标签，这样切割为x，y x,yOut[82]:(array([[ 0, 1, 2], [ 4, 5, 6], [ 8, 9, 10], [12, 13, 14]]), array([[ 3], [ 7], [11], [15]])) 六、矩阵的标量运算12345678910111213141516171819In [83]:%%timeit #计算单元格内运算时间 n = 10 A = [i for i in range(n)] A858 ns ± 7.77 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)In [84]:%%timeit n = 10 B = [] for i in range(n): B.append(i) B1.51 µs ± 85.2 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)In [85]:%%timeit n = 10 A = np.arange(n) A881 ns ± 93.5 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) 七、Universal Function123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687In [87]:A = [i for i in range(10)] AOut[87]:[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]In [88]:arrA = np.array(A).reshape(2, 5)In [89]:arrA * 2Out[89]:array([[ 0, 2, 4, 6, 8], [10, 12, 14, 16, 18]])In [90]:arrA - 1Out[90]:array([[-1, 0, 1, 2, 3], [ 4, 5, 6, 7, 8]])In [91]:arrA/2Out[91]:array([[0. , 0.5, 1. , 1.5, 2. ], [2.5, 3. , 3.5, 4. , 4.5]])In [92]:arrA **2Out[92]:array([[ 0, 1, 4, 9, 16], [25, 36, 49, 64, 81]], dtype=int32)In [93]:arrA //2 #整除Out[93]:array([[0, 0, 1, 1, 2], [2, 3, 3, 4, 4]], dtype=int32)In [94]:np.abs(arrA-4)Out[94]:array([[4, 3, 2, 1, 0], [1, 2, 3, 4, 5]])In [95]:np.sin(arrA)Out[95]:array([[ 0. , 0.84147098, 0.90929743, 0.14112001, -0.7568025 ], [-0.95892427, -0.2794155 , 0.6569866 , 0.98935825, 0.41211849]])In [96]:np.arcsin(arrA)C:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: invalid value encountered in arcsin &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[96]:array([[0. , 1.57079633, nan, nan, nan], [ nan, nan, nan, nan, nan]])In [97]:np.power(arrA,3)Out[97]:array([[ 0, 1, 8, 27, 64], [125, 216, 343, 512, 729]], dtype=int32)In [98]:1/arrAC:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in true_divide &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[98]:array([[ inf, 1. , 0.5 , 0.33333333, 0.25 ], [0.2 , 0.16666667, 0.14285714, 0.125 , 0.11111111]])In [99]:np.exp(arrA)Out[99]:array([[1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01, 5.45981500e+01], [1.48413159e+02, 4.03428793e+02, 1.09663316e+03, 2.98095799e+03, 8.10308393e+03]])In [100]:np.log2(arrA)C:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in log2 &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[100]:array([[ -inf, 0. , 1. , 1.5849625 , 2. ], [2.32192809, 2.5849625 , 2.80735492, 3. , 3.169925 ]])In [101]:np.log10(arrA)C:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in log10 &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[101]:array([[ -inf, 0. , 0.30103 , 0.47712125, 0.60205999], [0.69897 , 0.77815125, 0.84509804, 0.90308999, 0.95424251]])In [102]:np.log(arrA) #log默认为eC:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in log &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[102]:array([[ -inf, 0. , 0.69314718, 1.09861229, 1.38629436], [1.60943791, 1.79175947, 1.94591015, 2.07944154, 2.19722458]])]]></content>
      <categories>
        <category>Machine Leaning</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令一]]></title>
    <url>%2F%2Fposts%2F</url>
    <content type="text"><![CDATA[Linux命令格式: command [-options] [parameter1] … 说明：command: 命令名,相应功能的英文单词或单词的缩写 [-options]：选项,可用来对命令进行控制，也可以省略，[]代表可选 parameter1 …：传给命令的参数：可以是零个一个或多个 一、基本技能 在linux终端时：Ctrl Shift + 三个键字体扩大，Ctrl - 字体缩小 自动补全：在敲出命令的前几个字母的同时，按下tab键，系统会自动帮我们补全命令 历史命令：当系统执行过一些命令后，可按上下键翻看以前的命令，history将执行过的命令列举出来 多个命令同时使用用 ; ，不建议使用 Ctrl c 终止命令 几个目录符号含义： ~ 用户目录 / 根目录 . 当前路径 .. 上一路径 -回看 清屏：clear 显示当前路径：pwd（不带参数） 二、文件、磁盘管理 查看文件信息：ls 参数 含义 -a 显示指定目录下所有子目录与文件，包括隐藏文件 -l 以列表方式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 输出重定向命令：&gt;Linux允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。如：ls &gt; test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 ) 注意：&gt;输出重定向会覆盖原来的内容，&gt;&gt;输出重定向则会追加到文件的尾部。 分屏显示：more查看内容时，在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用more命令，每次只显示一页，按下空格键可以显示下一页，按下q键退出显示，按下h键可以获取帮助 管道：|管道：一个命令的输出可以通过管道做为另一个命令的输入。管道我们可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里“ | ”的左右分为两端，左端塞东西(写)，右端取东西(读)。 切换工作目录： cd在使用Unix/Linux的时候，经常需要更换工作目录。cd命令可以帮助用户切换工作目录。Linux所有的目录和文件名大小写敏感cd后面可跟绝对路径，也可以跟相对路径。如果省略目录，则默认切换到当前用户的主目录。例如：cd / 到根目录 目录操作： 创建目录：mkdir通过mkdir命令可以创建一个新的目录。参数-p可递归创建目录。需要注意的是新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写权限。 删除目录：rmdir可使用rmdir命令删除一个目录。必须离开目录，并且目录必须为空目录，不然提示删除失败。 删除文件：rm可通过rm删除文件或目录。使用rm命令要小心，因为文件删除后不能恢复。为了防止文件误删，可以在rm后使用-i参数以逐个确认要删除的文件。 参数 含义 -i 以进行交互式方式执行 -f 强制删除，忽略不存在的文件，无需提示 -r 递归地删除目录下的内容，删除文件夹时必须加此参数 建立链接文件：lnLinux链接文件类似于Windows下的快捷方式。链接文件分为软链接和硬链接。软链接：软链接不占用磁盘空间，源文件删除则软链接失效。硬链接：硬链接只能链接普通文件，不能链接目录。使用格式： ln 源文件 链接文件ln -s 源文件 链接文件 如果没有-s选项代表建立一个硬链接文件，两个文件占用相同大小的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s选项是更常见的形式。 注意：如果软链接文件和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径。 查看或者合并文件内容：cat 文本搜索：grepLinux系统中grep命令是一种强大的文本搜索工具，grep允许对文本文件进行模式查找。如果找到匹配模式， grep打印包含模式的所有行。 grep一般格式为： grep [-选项] ‘搜索内容串’文件名 在grep命令中输入字符串参数时，最好引号或双引号括起来。例如：grep‘a ’1.txt。 常用选项说明： 选项 含义 -v 显示不包含匹配文本的所有行（相当于求反） -n 显示匹配行及行号 -i 忽略大小写 grep搜索内容串可以是正则表达式。 &emsp;&emsp;正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 grep常用正则表达式： 参数 含义 ^a 行首,搜寻以 m 开头的行；grep -n ‘^a’ 1.txt ke$ 行尾,搜寻以 ke 结束的行；grep -n ‘ke$’ 1.txt [Ss]igna[Ll] 匹配 [] 里中一系列字符中的一个；搜寻匹配单词signal、signaL、Signal、SignaL的行；grep -n ‘[Ss]igna[Ll]’ 1.txt . (点)匹配一个非换行符的字符；匹配 e 和 e 之间有任意一个字符，可以匹配 eee，eae，eve，但是不匹配 ee，eaae；grep -n ‘e.e’ 1.txt 查找文件：findfind命令功能非常强大，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。 常用用法： 命令 含义 find ./ -name test.sh 查找当前目录下所有名为test.sh的文件 find ./ -name ‘*.sh’ 查找当前目录下所有后缀为.sh的文件 find ./ -name “[A-Z]*” 查找当前目录下所有以大写字母开头的文件 find /tmp -size 2M 查找在/tmp 目录下等于2M的文件 find /tmp -size +2M 查找在/tmp 目录下大于2M的文件 find /tmp -size -2M 查找在/tmp 目录下小于2M的文件 find ./ -size +4k -size -5M 查找当前目录下大于4k，小于5M的文件 find ./ -perm 777 查找当前目录下权限为 777 的文件或目录 拷贝文件：cpcp命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS下的copy命令。 常用选项说明： 选项 含义 -a 该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。 -f 已经存在的目标文件而不提示 -i 交互式复制，在覆盖目标文件之前将给出提示要求用户确认 -r 若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。 -v 显示拷贝进度 移动文件：mv用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名。 常用选项说明： 选项 含义 -f 禁止交互式操作，如有覆盖也不会给出提示 -i 确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问是否重写，要求用户回答以避免误覆盖文件 -v 显示移动进度 归档管理：tar计算机中的数据经常需要备份，tar是Unix/Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。 tar使用格式 tar [参数] 打包文件名 文件 tar命令很特殊，其参数前面可以使用“-”，也可以不使用。 常用参数： 参数 含义 -c 生成档案文件，创建打包文件 -v 列出归档解档的详细过程，显示进度 -f 指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后 -t 列出档案中包含的文件 -x 解开档案文件 注意：除了f需要放在参数的最后，其它参数的顺序任意。 文件压缩解压：gziptar与gzip命令结合使用实现文件打包、压缩。 tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz。 gzip使用格式如下： gzip [选项] 被压缩文件 常用选项： 选项 含义 -d 解压 -r 压缩所有子目录 tar这个命令并没有压缩的功能，它只是一个打包的命令，但是在tar命令中增加一个选项(-z)可以调用gzip实现了一个压缩的功能，实行一个先打包后压缩的过程。 压缩用法：tar cvzf 压缩包包名 文件1 文件2 ... -z ：指定压缩包的格式为：file.tar.gz 解压用法： tar zxvf 压缩包包名 -z:指定压缩包的格式为：file.tar.gz 解压到指定目录：-C （大写字母“C”） 文件压缩解压：bzip2tar与bzip2命令结合使用实现文件打包、压缩(用法和gzip一样)。 tar只负责打包文件，但不压缩，用bzip2压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz2。 在tar命令中增加一个选项(-j)可以调用bzip2实现了一个压缩的功能，实行一个先打包后压缩的过程。 压缩用法：tar -jcvf 压缩包包名 文件...(tar jcvf bk.tar.bz2 *.c) 解压用法：tar -jxvf 压缩包包名 (tar jxvf bk.tar.bz2) 文件压缩解压：zip、unzip通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。 压缩文件：zip [-r] 目标文件(没有扩展名) 源文件 解压文件：unzip -d 解压后目录文件 压缩文件 查看命令位置：which例如：which ls]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise_3_飞机大战]]></title>
    <url>%2F%2Fposts%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一个小练习，飞机大战，主要有四个类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227import pygamefrom pygame.locals import *import randomimport time&apos;&apos;&apos;说明爆炸效果的原理是:换图片&apos;&apos;&apos;class Hero(object): def __init__(self, screen_temp): self.x = 210 self.y = 590 self.image = pygame.image.load(&quot;./feiji/hero1.png&quot;) self.screen = screen_temp self.bullet_list = []#用来存储子弹对象的引用 &quot;&quot;&quot; #爆炸效果用的如下属性 self.hit = False #表示是否要爆炸 self.bomb_list = [] #用来存储爆炸时需要的 图片 self.__crate_images() #调用这个方法向bomb_list中添加图片 self.image_num = 0#用来记录while True的次数,当次数达到一定值时才显示一张爆炸的图,然后清空,,当这个次数再次达到时,再显示下一个爆炸效果的图片 self.image_index = 0#用来记录当前要显示的爆炸效果的图片的序号 def __crate_images(self): self.bomb_list.append(pygame.image.load(&quot;./feiji/hero_blowup_n1.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/hero_blowup_n2.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/hero_blowup_n3.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/hero_blowup_n4.png&quot;)) &quot;&quot;&quot; def display(self, enemy_temp): &quot;&quot;&quot;显示玩家的飞机&quot;&quot;&quot; #如果被击中,就显示爆炸效果,否则显示普通的飞机效果 &quot;&quot;&quot; if self.hit == True: self.screen.blit(self.bomb_list[self.image_index], (self.x, self.y)) self.image_num+=1 if self.image_num == 7: self.image_num=0 self.image_index+=1 if self.image_index&gt;3: time.sleep(1) exit()#调用exit让游戏退出 #self.image_index = 0 &quot;&quot;&quot; #else: self.screen.blit(self.image,(self.x, self.y)) #不管玩家飞机是否被击中,都要显示发射出去的子弹 for bullet in self.bullet_list: bullet.display() bullet.move(enemy_temp) if bullet.judge():#判断子弹是否越界 self.bullet_list.remove(bullet) def move_left(self): self.x -= 8 def move_right(self): self.x += 8 def fire(self): &quot;&quot;&quot;通过创建一个子弹对象,完成发射子弹&quot;&quot;&quot; print(&quot;-----1----&quot;) bullet = Bullet(self.screen, self.x, self.y)#创建一个子弹对象 self.bullet_list.append(bullet) def bomb(self): self.hit = Trueclass Bullet(object): def __init__(self, screen_temp, x_temp, y_temp): self.x = x_temp+40 self.y = y_temp-20 self.image = pygame.image.load(&quot;./feiji/bullet.png&quot;) self.screen = screen_temp def display(self): self.screen.blit(self.image, (self.x, self.y)) def move(self, enemy_temp): if self.x &gt; enemy_temp.x and self.x &lt; enemy_temp.x + 50 and self.y &lt; 40: enemy_temp.bomb() else: self.y -= 20 def judge(self): if self.y&lt;0: return True else: return Falseclass EnemyPlane(object): def __init__(self, screen_temp): self.x = 0 self.y = 0 self.image = pygame.image.load(&quot;./feiji/enemy0.png&quot;) self.screen = screen_temp self.bullet_list = []#用来存储子弹对象的引用 self.direction = &quot;right&quot;#用来设置这个飞机默认的移动方向 #爆炸效果用的如下属性 self.hit = False #表示是否要爆炸 self.bomb_list = [] #用来存储爆炸时需要的 图片 self.__crate_images() #调用这个方法向bomb_list中添加图片 self.image_num = 0#用来记录while True的次数,当次数达到一定值时才显示一张爆炸的图,然后清空,,当这个次数再次达到时,再显示下一个爆炸效果的图片 self.image_index = 0#用来记录当前要显示的爆炸效果的图片的序号 def __crate_images(self): self.bomb_list.append(pygame.image.load(&quot;./feiji/enemy0_down1.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/enemy0_down2.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/enemy0_down3.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/enemy0_down4.png&quot;)) def display(self): &quot;&quot;&quot;显示敌人的飞机&quot;&quot;&quot; if self.hit == True: self.screen.blit(self.bomb_list[self.image_index], (self.x, self.y)) self.image_num+=1 if self.image_num == 7: self.image_num=0 self.image_index+=1 if self.image_index&gt;3: time.sleep(1) exit()#调用exit让游戏退出 #self.image_index = 0 else: self.screen.blit(self.image,(self.x, self.y)) for bullet in self.bullet_list: bullet.display() bullet.move() if bullet.judge():#判断子弹是否越界 self.bullet_list.remove(bullet) def move(self): if self.direction == &quot;right&quot;: self.x+=5 elif self.direction == &quot;left&quot;: self.x-=5 if self.x&gt;480-50: self.direction=&quot;left&quot; elif self.x&lt;0: self.direction=&quot;right&quot; def fire(self): random_num = random.randint(1,100) if random_num == 8 or random_num == 20: self.bullet_list.append(EnemyBullet(self.screen, self.x, self.y)) def bomb(self): self.hit = Trueclass EnemyBullet(object): def __init__(self, screen_temp, x, y): self.x = x+25 self.y = y+40 self.screen = screen_temp self.image = pygame.image.load(&quot;./feiji/bullet1.png&quot;) def display(self): self.screen.blit(self.image, (self.x, self.y)) def move(self): self.y+=5 def judge(self): if self.y&gt;720: return True else: return Falsedef key_control(hero_temp): #获取事件，比如按键等 for event in pygame.event.get(): #判断是否是点击了退出按钮 if event.type == QUIT: print(&quot;exit&quot;) exit() #判断是否是按下了键 elif event.type == KEYDOWN: #检测按键是否是a或者left if event.key == K_a or event.key == K_LEFT: print(&apos;left&apos;) hero_temp.move_left() #检测按键是否是d或者right elif event.key == K_d or event.key == K_RIGHT: print(&apos;right&apos;) hero_temp.move_right() #检测按键是否是空格键 elif event.key == K_SPACE: print(&apos;space&apos;) hero_temp.fire() #elif event.key == K_b: #print(&apos;b&apos;) #hero_temp.bomb()def main(): screen = pygame.display.set_mode((480,720),0,32) background = pygame.image.load(&quot;./feiji/background.png&quot;) #创建玩家飞机 hero = Hero(screen) #创建敌机 enemy = EnemyPlane(screen) while True: screen.blit(background,(0,0)) hero.display(enemy) enemy.display() enemy.move() enemy.fire() pygame.display.update() key_control(hero) time.sleep(0.01)if __name__ == &quot;__main__&quot;: main()]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>pygame</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快排]]></title>
    <url>%2F%2Fposts%2F</url>
    <content type="text"><![CDATA[快排算法： 1、快速排序的基本思想：&emsp;&emsp;快排主要使用分治思想，基于pivot，通过一趟排序将待排序列分割成两部分，左边都不大于pivot，右边都不小于pivot。之后分别对这两部分继续进行排序，以达到整个序列有序的目的。 2、快速排序的三个步骤：(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot） ，这里将第一个元素作为第一个基准。(2)分割操作：以pivot为基准分割该序列为两部分。(3)递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。 3、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;#define n 10//对[left, right]进行划分，使pivot 左边都小于该值，右边都大于该值int Part(int A[], int left, int right)&#123; int pivot = A[left]; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; pivot &lt; A[right]) right--; A[left] = A[right]; while(left &lt; right &amp;&amp; pivot &gt;= A[left]) left++; A[right] = A[left]; &#125; A[left] = pivot; return left;&#125;//利用上面的part函数，且采用递归的方式实现快速排序void Quicksort(int A[], int left, int right)&#123; if(left &lt; right) &#123; int temp = Part(A, left, right); Quicksort(A, left, temp-1); Quicksort(A, temp+1, right); &#125;&#125;//对快排进行测试int main(int argc, char const *argv[])&#123; int array[n]; for (int i = 0; i &lt; n; ++i) cin&gt;&gt;array[i]; Quicksort(array, 0, n-1); cout&lt;&lt;array[0]; for (int i = 0; i &lt; n; ++i) cout&lt;&lt;&quot; &quot;&lt;&lt;array[i]; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>QuickSort</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1090 危险品装箱 （25 分）]]></title>
    <url>%2F%2Fposts%2F</url>
    <content type="text"><![CDATA[1090 危险品装箱 （25 分）集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。 输入格式：输入第一行给出两个正整数：N (≤10$^{4}$) 是成对的不相容物品的对数；M (≤100) 是集装箱货品清单的单数。 随后数据分两大块给出。第一块有 N 行，每行给出一对不相容的物品。第二块有 M 行，每行给出一箱货物的清单，格式如下： K G[1] G[2] … G[K]其中 K (≤1000) 是物品件数，G[i] 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。 输出格式：对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No。 输入样例：123456789106 320001 2000220003 2000420005 2000620003 2000120005 2000420004 200064 00001 20004 00002 200035 98823 20002 20003 20006 100103 12345 67890 23333 输出样例：123NoYesYes 解题思路： map&lt;int, vector &gt; mp字典用来将每个物品与其不相容的物品序列配对 a[10000] = {0}：用来标记物品是否存在 vector g(count): 存放每箱物品清单编号 思路：先配对，然后对每箱物品清单的每个物品判断它的不相容数组中是否有标记，有的话no, 用flag == 1表示。最后为1，即有不相容物品对。若最后还是初始时的0则表示无不相容物品对。12345678910111213141516171819202122232425262728#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main() &#123; int n, m, number1, number2; map&lt;int,vector&lt;int&gt;&gt; mp; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;number1&gt;&gt;number2; mp[number1].push_back(number2); mp[number2].push_back(number1); &#125; while (m--) &#123; int count, flag = 0, a[100000] = &#123;0&#125;; scanf(&quot;%d&quot;, &amp;count); vector&lt;int&gt; g(count); for (int i = 0; i &lt; count; i++) &#123; cin&gt;&gt;g[i]; a[g[i]] = 1; &#125; for (int i = 0; i &lt; g.size(); i++) for (int j = 0; j &lt; mp[g[i]].size(); j++) if (a[mp[g[i]][j]] == 1) flag = 1; printf(&quot;%s\n&quot;,flag ==0 ? &quot;Yes&quot; :&quot;No&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT (Basic Level) Practice</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>STL</tag>
        <tag>map</tag>
        <tag>配对问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1089 狼人杀-简单版 （20 分）]]></title>
    <url>%2F%2Fposts%2F</url>
    <content type="text"><![CDATA[1089 狼人杀-简单版 （20 分）以下文字摘自《灵机一动·好玩的数学》：“狼人杀”游戏分为狼人、好人两大阵营。在一局“狼人杀”游戏中，1 号玩家说：“2 号是狼人”，2 号玩家说：“3 号是好人”，3 号玩家说：“4 号是狼人”，4 号玩家说：“5 号是好人”，5 号玩家说：“4 号是好人”。已知这 5 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。扮演狼人角色的是哪两号玩家？本题是这个问题的升级版：已知 N 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。要求你找出扮演狼人角色的是哪几号玩家？ 输入格式：输入在第一行中给出一个正整数 N（5≤N≤100）。随后 N 行，第 i 行给出第 i 号玩家说的话（1≤i≤N），即一个玩家编号，用正号表示好人，负号表示狼人。 输出格式：如果有解，在一行中按递增顺序输出 2 个狼人的编号，其间以空格分隔，行首尾不得有多余空格。如果解不唯一，则输出最小序列解 —— 即对于两个序列 A=a[1],…,a[M] 和 B=b[1],…,b[M]，若存在 0≤ k&lt; M 使得 a[i]=b[i] （i≤k），且 a[k+1]&lt;b[k+1]，则称序列 A 小于序列 B。若无解则输出 No Solution。输入样例 1：5-2+3-4+5+4输出样例 1：1 4输入样例 2：6+6+3+1-5-2+4输出样例 2（解不唯一）：1 5输入样例 3：5-2-3-4-5-1输出样例 3：No Solution 解题思路： speak[k]数组用来保存k号玩家所说的话 lang_hao[k] 表示k号玩家是狼人还是好人，好人为1，狼人为-1 lie[]存放说谎者的序号 思路：先存speak；然后用两循环令i，j为狼人遍历这n个玩家。当狼人确定后，好人同时确认。接着再用一层循环来判断k号玩家是否说谎，说谎者序号放进lie[]。最后，当lie[]数组大小为2且一个为狼人一个为好人时，输出i，j并结束程序。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; speak(n + 1); for (int i = 1; i &lt;= n; ++i) cin&gt;&gt;speak[i]; for (int i = 1; i &lt;= n; ++i)&#123; for (int j = i + 1; j &lt;= n; ++j) &#123; vector&lt;int&gt; lie, lang_hao(n + 1, 1); lang_hao[i] = lang_hao[j] = -1; for(int k = 1; k&lt;=n; k++)&#123; if(speak[k] * lang_hao[abs(speak[k])] &lt; 0) lie.push_back(k); &#125; if(lie.size() == 2 &amp;&amp; lang_hao[lie[0]] + lang_hao[lie[1]] == 0)&#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j; return 0; &#125; &#125; &#125; cout &lt;&lt; &quot;No Solution&quot;; return 0;&#125;]]></content>
      <categories>
        <category>PAT (Basic Level) Practice</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>STL</tag>
        <tag>狼人杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1088 三人行 （20 分）]]></title>
    <url>%2F%2Fposts%2F</url>
    <content type="text"><![CDATA[1088 三人行 （20 分）子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。” 本题给定甲、乙、丙三个人的能力值关系为：甲的能力值确定是 2 位正整数；把甲的能力值的 2 个数字调换位置就是乙的能力值；甲乙两人能力差是丙的能力值的 X 倍；乙的能力值是丙的 Y 倍。请你指出谁比你强应“从之”，谁比你弱应“改之”。输入格式：输入在一行中给出三个数，依次为：M（你自己的能力值）、X 和 Y。三个数字均为不超过 1000 的正整数。 输出格式：在一行中首先输出甲的能力值，随后依次输出甲、乙、丙三人与你的关系：如果其比你强，输出 Cong；平等则输出 Ping；比你弱则输出 Gai。其间以 1 个空格分隔，行首尾不得有多余空格。 注意：如果解不唯一，则以甲的最大解为准进行判断；如果解不存在，则输出 No Solution。 输入样例 1：48 3 7输出样例 1：48 Ping Cong Gai输入样例 2：48 11 6输出样例 2：No Solution 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int i, j; int m, x, y; double a[3] = &#123;0&#125;;//丙可能是小数，所以用double cin&gt;&gt;m&gt;&gt;x&gt;&gt;y; for(i = 99; i &gt;= 10; --i)&#123;//i表示甲，j为乙 j = i%10*10 + i/10; if(j * x == y * abs(j - i))&#123;1089 狼人杀-简单版 （20 分） printf(&quot;%d&quot;,i); a[0] = i; a[1] = j; a[2] = j * 1.0/y; break; &#125; &#125; for(int i = 0; i &lt; 3; i++)&#123; if(a[i] == 0) &#123; printf(&quot;No Solution&quot;); break; &#125; else if(m &gt; a[i]) printf(&quot; Gai&quot;); else if(m == a[i]) printf(&quot; Ping&quot;); else printf(&quot; Cong&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT (Basic Level) Practice</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>STL</tag>
      </tags>
  </entry>
</search>
