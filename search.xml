<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[经典网络]]></title>
    <url>%2F2018%2F12%2F24%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[转载自深度学习500问 经典网络4.1 LeNet5一种典型的用来识别数字的卷积网络是LeNet-5。 4.1.1 模型结构 4.1.2 模型结构LeNet-5共有7层（不包含输入层），每层都包含可训练参数；每个层有多个Feature Map，每个FeatureMap通过一种卷积滤波器提取输入的一种特征，然后每个FeatureMap有多个神经元。 C1层是一个卷积层输入图片：32 * 32卷积核大小：5 * 5卷积核种类：6输出featuremap大小：28 * 28 （32-5+1）神经元数量：28 * 28 * 6可训练参数：（5 * 5+1） * 6（每个滤波器5 * 5=25个unit参数和一个bias参数，一共6个滤波器）连接数：（5 * 5+1） * 6 * 28 * 28 S2层是一个下采样层输入：28 * 28采样区域：2 * 2采样方式：4个输入相加，乘以一个可训练参数，再加上一个可训练偏置。结果通过sigmoid采样种类：6输出featureMap大小：14 * 14（28/2）神经元数量：14 * 14 * 6可训练参数：2 * 6（和的权+偏置）连接数：（2 * 2+1） * 6 * 14 * 14S2中每个特征图的大小是C1中特征图大小的1/4 C3层也是一个卷积层输入：S2中所有6个或者几个特征map组合卷积核大小：5 * 5卷积核种类：16输出featureMap大小：10 * 10C3中的每个特征map是连接到S2中的所有6个或者几个特征map的，表示本层的特征map是上一层提取到的特征map的不同组合存在的一个方式是：C3的前6个特征图以S2中3个相邻的特征图子集为输入。接下来6个特征图以S2中4个相邻特征图子集为输入。然后的3个以不相邻的4个特征图子集为输入。最后一个将S2中所有特征图为输入。 则：可训练参数：6 * （3 * 25+1）+6 * （4 * 25+1）+3 * （4 * 25+1）+（25 * 6+1）=1516连接数：10 * 10 * 1516=151600 S4层是一个下采样层输入：10 * 10采样区域：2 * 2采样方式：4个输入相加，乘以一个可训练参数，再加上一个可训练偏置。结果通过sigmoid采样种类：16输出featureMap大小：5 * 5（10/2）神经元数量：5 * 5 * 16=400可训练参数：2 * 16=32（和的权+偏置）连接数：16 * （2 * 2+1） * 5 * 5=2000S4中每个特征图的大小是C3中特征图大小的1/4 C5层是一个卷积层输入：S4层的全部16个单元特征map（与s4全相连）卷积核大小：5 * 5卷积核种类：120输出featureMap大小：1 * 1（5-5+1）可训练参数/连接：120 * （16 * 5 * 5+1）=48120 F6层全连接层输入：c5 120维向量计算方式：计算输入向量和权重向量之间的点积，再加上一个偏置，结果通过sigmoid函数可训练参数:84 * (120+1)=10164 4.1.3 模型特性 卷积网络使用一个3层的序列：卷积、池化、非线性——这可能是自这篇论文以来面向图像的深度学习的关键特性！ 使用卷积提取空间特征 使用映射的空间均值进行降采样 tanh或sigmoids非线性 多层神经网络（MLP）作为最终的分类器 层间的稀疏连接矩阵以避免巨大的计算开销 4.2 AlexNet4.2.1 模型介绍​ AlexNet在2012年ILSVRC竞赛中赢得了第一名，其Top5错误率为15.3%。AlexNet模型证明了CNN在复杂模型下的有效性，并且在可接受时间范围内，部署GPU得到了有效结果。 4.2.2 模型结构 4.2.3 模型解读AlexNet共8层，前五层为卷积层，后三层为全连接层。 conv1阶段： &nbsp;&nbsp; 输入图片：227 * 227 * 3 卷积核大小：11 11 3 卷积核数量：96 滤波器stride：4 输出featuremap大小：(227-11)/4+1=55 (227个像素减去11，然后除以4，生成54个像素，再加上被减去的11也对应生成一个像素) 输出featuremap大小：55 * 55 共有96个卷积核，会生成55 * 55 * 96个卷积后的像素层。96个卷积核分成2组，每组48个卷积核。对应生成2组55 * 55 * 48的卷积后的像素层数据。 这些像素层经过relu1单元的处理，生成激活像素层，尺寸仍为2组55 * 55 * 48的像素层数据。 这些像素层经过pool运算的处理，池化运算尺度为3 * 3，运算的步长为2，则池化后图像的尺寸为(55-3)/2+1=27。 即池化后像素的规模为27 * 27 * 96； 然后经过归一化处理，归一化运算的尺度为5 * 5；第一卷积层运算结束后形成的像素层的规模为27 * 27 * 96。分别对应96个卷积核所运算形成。这96层像素层分为2组，每组48个像素层，每组在一个独立的GPU上进行运算。 反向传播时，每个卷积核对应一个偏差值。即第一层的96个卷积核对应上层输入的96个偏差值。 conv2阶段： &nbsp;&nbsp;&nbsp;&nbsp; 输入图片：27 * 27 * 96（第一层输出） 为便于后续处理，每幅像素层的左右两边和上下两边都要填充2个像素 27 * 27 * 96的像素数据分成27 * 27 * 48的两组像素数据，两组数据分别再两个不同的GPU中进行运算。 卷积核大小：5 * 5 * 48 滤波器stride：1 输出featuremap大小：卷积核在移动的过程中会生成(27-5+2 * 2)/1+1=27个像素。(27个像素减去5，正好是22，在加上上下、左右各填充的2个像素，即生成26个像素，再加上被减去的5也对应生成一个像素)，行和列的27 * 27个像素形成对原始图像卷积之后的像素层。共有256个5 * 5 * 48卷积核；这256个卷积核分成两组，每组针对一个GPU中的27 * 27 * 48的像素进行卷积运算。会生成两组27 * 27 * 128个卷积后的像素层。 这些像素层经过relu2单元的处理，生成激活像素层，尺寸仍为两组27 * 27 * 128的像素层。 这些像素层经过pool运算(池化运算)的处理，池化运算的尺度为3 * 3，运算的步长为2，则池化后图像的尺寸为(57-3)/2+1=13。 即池化后像素的规模为2组13 * 13 * 128的像素层； 然后经过归一化处理，归一化运算的尺度为5 * 5； 第二卷积层运算结束后形成的像素层的规模为2组13 * 13 * 128的像素层。分别对应2组128个卷积核所运算形成。每组在一个GPU上进行运算。即共256个卷积核，共2个GPU进行运算。 反向传播时，每个卷积核对应一个偏差值。即第一层的96个卷积核对应上层输入的256个偏差值。 conv3阶段： 第三层输入数据为第二层输出的2组13 * 13 * 128的像素层； 为便于后续处理，每幅像素层的左右两边和上下两边都要填充1个像素； 2组像素层数据都被送至2个不同的GPU中进行运算。每个GPU中都有192个卷积核，每个卷积核的尺寸是3 * 3 * 256。因此，每个GPU中的卷积核都能对2组13 * 13 * 128的像素层的所有数据进行卷积运算。 移动的步长是1个像素。 运算后的卷积核的尺寸为(13-3+1 * 2)/1+1=13（13个像素减去3，正好是10，在加上上下、左右各填充的1个像素，即生成12个像素，再加上被减去的3也对应生成一个像素），每个GPU中共13 * 13 * 192个卷积核。2个GPU中共13 * 13 * 384个卷积后的像素层。这些像素层经过relu3单元的处理，生成激活像素层，尺寸仍为2组13 * 13 * 192像素层，共13 * 13 * 384个像素层。 conv4阶段DFD： &nbsp;&nbsp;&nbsp;&nbsp; 第四层输入数据为第三层输出的2组13 * 13 * 192的像素层； 为便于后续处理，每幅像素层的左右两边和上下两边都要填充1个像素； 2组像素层数据都被送至2个不同的GPU中进行运算。每个GPU中都有192个卷积核，每个卷积核的尺寸是3 * 3 * 192。因此，每个GPU中的卷积核能对1组13 * 13 * 192的像素层的数据进行卷积运算。 移动的步长是1个像素。 运算后的卷积核的尺寸为(13-3+1 * 2)/1+1=13（13个像素减去3，正好是10，在加上上下、左右各填充的1个像素，即生成12个像素，再加上被减去的3也对应生成一个像素），每个GPU中共13 * 13 * 192个卷积核。2个GPU中共13 * 13 * 384个卷积后的像素层。 这些像素层经过relu4单元的处理，生成激活像素层，尺寸仍为2组13 * 13 * 192像素层，共13 * 13 * 384个像素层。 conv5阶段： &nbsp;&nbsp;&nbsp;&nbsp; 第五层输入数据为第四层输出的2组13 * 13 * 192的像素层； 为便于后续处理，每幅像素层的左右两边和上下两边都要填充1个像素； 2组像素层数据都被送至2个不同的GPU中进行运算。每个GPU中都有128个卷积核，每个卷积核的尺寸是3 * 3 * 192。因此，每个GPU中的卷积核能对1组13 * 13 * 192的像素层的数据进行卷积运算。 移动的步长是1个像素。 因此，运算后的卷积核的尺寸为(13-3+1 * 2)/1+1=13（13个像素减去3，正好是10，在加上上下、左右各填充的1个像素，即生成12个像素，再加上被减去的3也对应生成一个像素），每个GPU中共13 * 13 * 128个卷积核。2个GPU中共13 * 13 * 256个卷积后的像素层。 这些像素层经过relu5单元的处理，生成激活像素层，尺寸仍为2组13 * 13 * 128像素层，共13 * 13 * 256个像素层。 2组13 * 13 * 128像素层分别在2个不同GPU中进行池化(pool)运算处理。池化运算的尺度为3 * 3，运算的步长为2，则池化后图像的尺寸为(13-3)/2+1=6。 即池化后像素的规模为两组6 * 6 * 128的像素层数据，共6 * 6 * 256规模的像素层数据。 fc6阶段： &nbsp;&nbsp;&nbsp;&nbsp; 第六层输入数据的尺寸是6 * 6 * 256 采用6 * 6 * 256尺寸的滤波器对第六层的输入数据进行卷积运算 共有4096个6 * 6 * 256尺寸的滤波器对输入数据进行卷积运算，通过4096个神经元输出运算结果； 这4096个运算结果通过relu激活函数生成4096个值； 通过drop运算后输出4096个本层的输出结果值。 由于第六层的运算过程中，采用的滤波器的尺寸(6 * 6 * 256)与待处理的feature map的尺寸(6 * 6 * 256)相同，即滤波器中的每个系数只与feature map中的一个像素值相乘；而其它卷积层中，每个滤波器的系数都会与多个feature map中像素值相乘；因此，将第六层称为全连接层。 第五层输出的6 * 6 * 256规模的像素层数据与第六层的4096个神经元进行全连接，然后经由relu6进行处理后生成4096个数据，再经过dropout6处理后输出4096个数据。 fc7阶段： 第六层输出的4096个数据与第七层的4096个神经元进行全连接 然后经由relu7进行处理后生成4096个数据，再经过dropout7处理后输出4096个数据。 fc8阶段： &nbsp;&nbsp;&nbsp;&nbsp; 第七层输出的4096个数据与第八层的1000个神经元进行全连接，经过训练后输出被训练的数值。 4.2.4 模型特性 使用ReLU作为非线性 使用dropout技术选择性地忽略训练中的单个神经元，避免模型的过拟合 重叠最大池化（overlapping max pooling），避免平均池化（average pooling）的平均效应 使用NVIDIA GTX 580 GPU减少训练时间 当时，GPU比CPU提供了更多的核心，可以将训练速度提升10倍，从而允许使用更大的数据集和更大的图像。 4.3 可视化ZFNet-转置卷积4.3.1 基本的思想及其过程 可视化技术揭露了激发模型中每层单独的特征图。 可视化技术允许观察在训练阶段特征的演变过程且诊断出模型的潜在问题。 可视化技术用到了多层解卷积网络，即由特征激活返回到输入像素空间。 可视化技术进行了分类器输出的敏感性分析，即通过阻止部分输入图像来揭示那部分对于分类是重要的。 可视化技术提供了一个非参数的不变性来展示来自训练集的哪一块激活哪个特征图，不仅需要裁剪输入图片，而且自上而下的投影来揭露来自每块的结构激活一个特征图。 可视化技术依赖于解卷积操作，即卷积操作的逆过程，将特征映射到像素上。 4.3.2 卷积与转置卷积&nbsp;&nbsp;&nbsp;&nbsp;下图为卷积过程 &nbsp;&nbsp;&nbsp;&nbsp;下图为转置卷积过程 &nbsp;&nbsp;&nbsp;&nbsp;下面首先介绍转置卷积中涉及到的几种操作：反池化操作：池化操作是非可逆的，但是我们可以用一组转换变量switch在每个池化区域中通过记录最大值的位置来获得一个近似值。在转置卷积网络中，反池化操作使用这些转换来放置上述最大值的位置，保存激活的位置，其余位置都置0。激活函数：卷积网中使用非线性的ReLU来确保所有输出值总是正值。在反卷积网中也利用了ReLU。转置卷积：为了实现转置卷积，转置卷积网络使用相同卷积核的转置作为新的卷积核进行计算。&nbsp;&nbsp;&nbsp;&nbsp;​ 上图左半部分是一个转置卷积层，右半部分为一个卷积层。反卷积层将会重建一个来自下一层的卷积特征近似版本。图中使用switch来记录在卷积网中进行最大池化操作时每个池化区域的局部最大值的位置，经过非池化操作之后，原来的非最大值的位置都置为0。### 4.3.3 卷积可视化&nbsp;&nbsp;&nbsp;&nbsp;​ 预处理：网络对输入图片进行预处理，裁剪图片中间的256x256区域，并减去整个图像每个像素的均值，然后用10个不同的对256x256图像进行224x224的裁剪（中间区域加上四个角落，以及他们的水平翻转图像），对以128个图片分的块进行随机梯度下降法来更新参数。起始学习率为0.01，动量为0.9，当验证集误差不再变化时时，手动调整学习率。在全连接网络中使用概率为0.5的dropout，并且所有权值都初始化为0.01，偏置设为0。&nbsp;&nbsp;&nbsp;&nbsp;​ 特征可视化：当输入存在一定的变化时，网络的输出结果保持不变。下图即在一个已经训练好的网络中可视化后的图。在可视化结果的右边是对应的输入图片，与重构特征相比，输入图片之间的差异性很大，而重构特征只包含那些具有判别能力的纹理特征。&nbsp;&nbsp;&nbsp;&nbsp;​ 由上图可以看到第二层应对角落和其他边缘或者颜色的结合；第三层有更加复杂的不变性，捕捉到了相似的纹理；第四层显示了特定类间显著的差异性；第五层显示了有显著构成变化的整个物体。&nbsp;&nbsp;&nbsp;&nbsp;​ 训练时的特征演变过程：当输入图片中的最强刺激源发生变化时，对应的输出特征轮廓发生剧烈变化。经过一定次数的迭代以后，底层特征趋于稳定，但更高层的特征则需要更多的迭代次数才能收敛，这表明：只有所有层都收敛时，这个分类模型才是有效的。&nbsp;&nbsp;&nbsp;&nbsp;​ 特征不变性: 一般来说，就深度模型来说，只要深度超过七层，微小的变化对于模型的第一层都有比较大的影响，但对于较深层几乎没有没有影响。对于图像的平移、尺度、旋转的变化来说，网络的输出对于平移和尺度变化都是稳定的，但却不具有旋转不变性，除非目标图像时旋转对称的。下图为分别对平移，尺度，旋转做的分析图。&nbsp;&nbsp;&nbsp;&nbsp;​ 上图按行顺序分别为对5类图像进行不同程度的垂直方向上的平移、尺度变换、旋转对输出结果影响的分析图。按列顺序分别为原始变换图像，第一层中原始图片和变换后的图片的欧氏距离，第7层中原始图片和变换后的图片的欧氏距离，变换后图片被正确分类的概率图。 &nbsp;&nbsp;&nbsp;&nbsp;​ 可视化不仅能够看到一个训练完的模型的内部操作，而且还能帮助选择好的网络结构。 ### 4.3.4 ZFNet和AlexNet比较&nbsp;&nbsp;&nbsp;&nbsp;​ ZFNet的网络结构实际上与AlexNet没有什么很大的变化，差异表现在AlexNet用了两块GPU的稀疏连接结构，而ZFNet只用了一块GPU的稠密连接结构；同时，由于可视化可以用来选择好的网络结构，通过可视化发现AlexNet第一层中有大量的高频和低频信息的混合，却几乎没有覆盖到中间的频率信息；且第二层中由于第一层卷积用的步长为4太大了，导致了有非常多的混叠情况；因此改变了AlexNet的第一层即将滤波器的大小11x11变成7x7，并且将步长4变成了2，下图为AlexNet网络结构与ZFNet的比较。## 4.4 VGGNet### 4.4.1 模型结构### 4.4.2 模型特点1. 整个网络都使用了同样大小的卷积核尺寸（3 * 3）和最大池化尺寸（2 * 2）2. 1 * 1卷积的意义主要在于线性变换，而输入通道数和输出通道数不变，没有发生降维。3. 两个3 * 3的卷积层串联相当于1个5 * 5的卷积层，即一个像素会跟周围5 * 5的像素产生关联，可以说感受野大小为5 * 5。而3个3 * 3的卷积层串联的效果则相当于1个7 * 7的卷积层。除此之外，3个串联的3 * 3的卷积层，拥有比1个7 * 7的卷积层更少的参数量，只有后者的(3 * 3 * 3)/(7 * 7)=55%。最重要的是，3个3 * 3的卷积层拥有比1个7 * 7的卷积层更多的非线性变换（前者可以使用三次ReLU激活函数，而后者只有一次），使得CNN对特征的学习能力更强。4. VGGNet在训练时有一个小技巧，先训练级别A的简单网络，再复用A网络的权重来初始化后面的几个复杂模型，这样训练收敛的速度更快。在预测时，VGG采用Multi-Scale的方法，将图像scale到一个尺寸Q，并将图片输入卷积网络计算。然后在最后一个卷积层使用滑窗的方式进行分类预测，将不同窗口的分类结果平均，再将不同尺寸Q的结果平均得到最后结果，这样可提高图片数据的利用率并提升预测准确率。在训练中，VGGNet还使用了Multi-Scale的方法做数据增强，将原始图像缩放到不同尺寸S，然后再随机裁切224*224的图片，这样能增加很多数据量，对于防止模型过拟合有很不错的效果。## 4.5 Network in Network### 4.5.1 模型结构### 4.5.2 模型创新点&nbsp;&nbsp;&nbsp;&nbsp;论文的创新点：1. 提出了抽象能力更高的Mlpconv层2. 提出了Global Average Pooling（全局平均池化）层- Mlpconv层 &nbsp;&nbsp;&nbsp;&nbsp; 传统的卷积神经网络一般来说是由线性卷积层、池化层、全连接层堆叠起来的网络，卷积层通过线性滤波器进行线性卷积运算，然后在接个非线性激活函数最终生成特征图。而这种卷积滤波器是一种GLM:(Generalized linear model)广义线性模型。然而GLM的抽象能力是比较低水平的。 &nbsp;&nbsp;&nbsp;&nbsp; 抽象：指得到对同一概念的不同变体保持不变的特征。 &nbsp;&nbsp;&nbsp;&nbsp; 一般用CNN进行特征提取时，其实就隐含地假设了特征是线性可分的，可实际问题往往是难以线性可分的。一般来说我们所要提取的特征一般是高度非线性的。在传统的CNN中，也许我们可以用超完备的滤波器，来提取各种潜在的特征。比如我们要提取某个特征，于是我就用了一大堆的滤波器，把所有可能的提取出来，这样就可以把我想要提取的特征也覆盖到，然而这样存在一个缺点，那就是网络太恐怖了，参数太多了。&nbsp;&nbsp;&nbsp;&nbsp;我们知道CNN高层特征其实是低层特征通过某种运算的组合。所以论文就根据这个想法，提出在每个局部感受野中进行更加复杂的运算，提出了对卷积层的改进算法：MLP卷积层。（这里也不知道是否有道理，因为在后面的深层网络没有提出此种说法，还是按照传统的cnn方法使用多个滤波器去学习同一特征的不同变体）。MLP中的激活函数采用的是整流线性单元（即ReLU:max（wx+b,0)。MLP的优点：1. 非常有效的通用函数近似器2. 可用BP算法训练，可以完美地融合进CNN3. 其本身也是一种深度模型，可以特征再利用 全局平均池化层 &nbsp;&nbsp;&nbsp;&nbsp; 另一方面，传统的CNN最后一层都是全连接层，参数个数非常之多，容易引起过拟合（如Alexnet），一个CNN模型，大部分的参数都被全连接层给占用了，所以论文提出采用了全局均值池化替代全连接层。与传统的全连接层不同，我们对每个特征图一整张图片进行全局均值池化，这样每张特征图都可以得到一个输出。这样采用均值池化，连参数都省了，可以大大减小网络参数，避免过拟合，另一方面它有一个特点，每张特征图相当于一个输出特征，然后这个特征就表示了我们输出类的特征。 全局平均池化的优势： 通过加强特征图与类别的一致性，让卷积结构更简单 不需要进行参数优化，所以这一层可以避免过拟合 它对空间信息进行了求和，因而对输入的空间变换更具有稳定性 &nbsp;&nbsp;&nbsp;&nbsp;在采用了微神经网络后，让局部模型有更强的抽象能力，从而让全局平均池化能具有特征图与类别之间的一致性，同时相比传统CNN采用的全连接层，不易过拟合（因为全局平均池化本身就是一种结构性的规则项）（PS:经典CNN容易过拟合，并严重依赖用dropout进行规则化）。 4.6 GoogleNet4.6.1 模型结构 4.6.2 Inception 结构 对上图做以下说明： 采用不同大小的卷积核意味着不同大小的感受野，最后拼接意味着不同尺度特征的融合； 之所以卷积核大小采用1、3和5，主要是为了方便对齐。设定卷积步长stride=1之后，只要分别设定pad=0、1、2，那么卷积之后便可以得到相同维度的特征，然后这些特征就可以直接拼接在一起了； 文章说很多地方都表明pooling挺有效，所以Inception里面也嵌入了。 网络越到后面，特征越抽象，而且每个特征所涉及的感受野也更大了，因此随着层数的增加，3x3和5x5卷积的比例也要增加。 但是，使用5x5的卷积核仍然会带来巨大的计算量。 为此，文章借鉴NIN2，采用1x1卷积核来进行降维。 例如：上一层的输出为100x100x128，经过具有256个输出的5x5卷积层之后(stride=1，padding=2)，输出数据为100x100x256。其中，卷积层的参数为128x5x5x256。假如上一层输出先经过具有32个输出的1x1卷积层，再经过具有256个输出的5x5卷积层，那么最终的输出数据仍为为100x100x256，但卷积参数量已经减少为128x1x1x32 + 32x5x5x256，大约减少了4倍。 具体改进后的Inception Module如下图： 4.7 Inception 系列4.7.1 Inception v1&nbsp;&nbsp;&nbsp;&nbsp;相比于GoogLeNet之前的众多卷积神经网络而言，inception v1采用在同一层中提取不同的特征（使用不同尺寸的卷积核），并提出了卷积核的并行合并（也称为Bottleneck layer），如下图 这样的结构主要有以下改进： 一层block就包含1x1卷积，3x3卷积，5x5卷积，3x3池化(使用这样的尺寸不是必需的，可以根据需要进行调整)。这样，网络中每一层都能学习到“稀疏”（3x3. 5x5）或“不稀疏”（1x1）的特征，既增加了网络的宽度，也增加了网络对尺度的适应性； 通过deep concat在每个block后合成特征，获得非线性属性。 虽然这样提高了性能，但是网络的计算量实在是太大了，因此GoogLeNet借鉴了Network-in-Network的思想，使用1x1的卷积核实现降维操作，以此来减小网络的参数量(这里就不对两种结构的参数量进行定量比较了)，如图所示。 &nbsp;&nbsp;&nbsp;&nbsp;最后实现的inception v1网络是上图结构的顺序连接，其中不同inception模块之间使用2x2的最大池化进行下采样，如表所示。 如表所示，实现的网络仍有一层全连接层，该层的设置是为了迁移学习的实现（下同）。在之前的网络中，最后都有全连接层，经实验证明，全连接层并不是很必要的，因为可能会带来以下三点不便：​ - 网络的输入需要固定​ - 参数量多​ - 易发生过拟合实验证明，将其替换为平均池化层（或者1x1卷积层）不仅不影响精度，还可以减少。 4.7.2 Inception v2在V1的基础之上主要做了以下改进： 使用BN层，将每一层的输出都规范化到一个N(0,1)的正态分布，这将有助于训练，因为下一层不必学习输入数据中的偏移，并且可以专注与如何更好地组合特征（也因为在v2里有较好的效果，BN层几乎是成了深度网络的必备）；&nbsp;&nbsp;&nbsp;&nbsp;（在Batch-normalized论文中只增加了BN层，而之后的Inception V3的论文提及到的inception v2还做了下面的优化） 使用2个3x3的卷积代替梯度（特征图，下同）为35x35中的5x5的卷积，这样既可以获得相同的视野(经过2个3x3卷积得到的特征图大小等于1个5x5卷积得到的特征图)，还具有更少的参数，还间接增加了网络的深度，如下图。 3x3的卷积核表现的不错，那更小的卷积核是不是会更好呢？比如2x2。对此，v2在17x17的梯度中使用1 * n和n * 1这种非对称的卷积来代替n * n的对称卷积，既降低网络的参数，又增加了网络的深度（实验证明，该结构放于网络中部，取n=7，准确率更高），如下。（基于原则3） 在梯度为8x8时使用可以增加滤波器输出的模块（如下图），以此来产生高维的稀疏特征。 输入从224x224变为229x229。 最后实现的Inception v2的结构如下表。 &nbsp;&nbsp;&nbsp;&nbsp;经过网络的改进，inception v2得到更低的识别误差率，与其他网络识别误差率对比如表所示。 &nbsp;&nbsp;&nbsp;&nbsp;如表，inception v2相比inception v1在imagenet的数据集上，识别误差率由29%降为23.4%。 4.7.3 Inception v3&nbsp;&nbsp;&nbsp;&nbsp;inception模块之间特征图的缩小，主要有下面两种方式： &nbsp;&nbsp;&nbsp;&nbsp;右图是先进行inception操作，再进行池化来下采样，但是这样参数量明显多于左图(比较方式同前文的降维后inception模块)，因此v2采用的是左图的方式，即在不同的inception之间（35/17/8的梯度）采用池化来进行下采样。 &nbsp;&nbsp;&nbsp;&nbsp;但是，左图这种操作会造成表达瓶颈问题，也就是说特征图的大小不应该出现急剧的衰减(只经过一层就骤降)。如果出现急剧缩减，将会丢失大量的信息，对模型的训练造成困难。&nbsp;&nbsp;&nbsp;&nbsp;因此，在2015年12月提出的Inception V3结构借鉴inception的结构设计了采用一种并行的降维结构，如下图： &nbsp;&nbsp;&nbsp;&nbsp;具体来说，就是在35/17/8之间分别采用下面这两种方式来实现特征图尺寸的缩小，如下图： figure 5’ 35/17之间的特征图尺寸减小 figure 6’ 17/8之间的特征图尺寸缩小 这样就得到Inception v3的网络结构，如表所示。 4.7.4 Inception V4&nbsp;&nbsp;&nbsp;&nbsp;其实，做到现在，Inception模块感觉已经做的差不多了，再做下去准确率应该也不会有大的改变。但是谷歌这帮人还是不放弃，非要把一个东西做到极致，改变不了Inception模块，就改变其他的。 &nbsp;&nbsp;&nbsp;&nbsp;因此，作者Christian Szegedy设计了Inception v4的网络，将原来卷积、池化的顺次连接（网络的前几层）替换为stem模块，来获得更深的网络结构。stem模块结构如下： stem模块 &nbsp;&nbsp;&nbsp;&nbsp;Inception v4 中的Inception模块（分别为Inception A Inception B Inception C） &nbsp;&nbsp;&nbsp;&nbsp;Inception v4中的reduction模块（分别为reduction A reduction B） &nbsp;&nbsp;&nbsp;&nbsp;最终得到的Inception v4结构如下图。 4.7.5 Inception-ResNet-v2&nbsp;&nbsp;&nbsp;&nbsp;ResNet的结构既可以加速训练，还可以提升性能（防止梯度消失）；Inception模块可以在同一层上获得稀疏或非稀疏的特征。有没有可能将两者进行优势互补呢？ &nbsp;&nbsp;&nbsp;&nbsp;Christian Szegedy等人将两个模块的优势进行了结合，设计出了Inception-ResNet网络。 &nbsp;&nbsp;&nbsp;&nbsp;(Inception-ResNet有v1和v2两个版本，v2表现更好且更复杂，这里只介绍了v2) &nbsp;&nbsp;&nbsp;&nbsp;Inception-ResNet的成功，主要是它的Inception-ResNet模块。 &nbsp;&nbsp;&nbsp;&nbsp;Inception-ResNet v2中的Inception-ResNet模块如下图： &nbsp;&nbsp;&nbsp;&nbsp;Inception-ResNet模块（分别为Inception-ResNet-A Inception-ResNet-B Inception-ResNet-C） &nbsp;&nbsp;&nbsp;&nbsp;Inception-ResNet模块之间特征图尺寸的减小如下图。（类似于Inception v4） &nbsp;&nbsp;&nbsp;&nbsp;Inception-ResNet-v2中的reduction模块（分别为reduction A reduction B） &nbsp;&nbsp;&nbsp;&nbsp;最终得到的Inception-ResNet-v2网络结构如图(stem模块同Inception v4)。 4.8 ResNet及其变体&nbsp;&nbsp;&nbsp;&nbsp;自从AlexNet在LSVRC2012分类比赛中取得胜利之后，深度残差网络（Deep Residual Network）可以说成为过去几年中，在计算机视觉、深度学习社区领域中最具突破性的成果了。ResNet可以实现高达数百，甚至数千个层的训练，且仍能获得超赞的性能。 &nbsp;&nbsp;&nbsp;&nbsp;得益于其强大的表征能力，许多计算机视觉应用在图像分类以外领域的性能得到了提升，如对象检测和人脸识别。 &nbsp;&nbsp;&nbsp;&nbsp;自从2015年ResNet进入人们的视线，并引发人们思考之后，许多研究界人员已经开始研究其成功的秘诀，并在架构中纳入了许多新的改进。本文分为两部分，第一部分我将为那些不熟悉ResNet的人提供一些相关的背景知识，第二部分我将回顾一些我最近读过的关于ResNet架构的不同变体及其论文的相关阐述。 4.8.1 重新审视ResNet&nbsp;&nbsp;&nbsp;&nbsp;根据泛逼近性原理（universal approximation theorem），我们知道，如果给定足够的容量，一个具有单层的前馈网络足以表示任何函数。然而，该层可能是巨大的，且网络可能容易过度拟合数据。因此，研究界有一个共同的趋势，即我们的网络架构需要更深。 &nbsp;&nbsp;&nbsp;&nbsp;自从AlexNet投入使用以来，最先进的卷积神经网络（CNN）架构越来越深。虽然AlexNet只有5层卷积层，但VGG网络和GoogleNet（代号也为Inception_v1）分别有19层和22层。 &nbsp;&nbsp;&nbsp;&nbsp;但是，如果只是通过简单地将层叠加在一起，增加网络深度并不会起到什么作用。随着网络层数的增加，就会出现梯度消失问题，这就会造成网络是难以进行训练，因为梯度反向传播到前层，重复乘法可能使梯度无穷小，这造成的结果就是，随着网络加深，其性能趋于饱和，或者甚至开始迅速退化。 &nbsp;&nbsp;&nbsp;&nbsp;增加网络深度导致性能下降 &nbsp;&nbsp;&nbsp;&nbsp;其实早在ResNet之前，已经有过好几种方法来处理梯度消失问题，例如，在中间层增加辅助损失作为额外的监督，但遗憾的是，似乎没有一个方法可以真正解决这个问题。 &nbsp;&nbsp;&nbsp;&nbsp;ResNet的核心思想是引入所谓的“恒等映射（identity shortcut connection）”，可以跳过一层或多层，如下图所示： 4.8.2 残差块&nbsp;&nbsp;&nbsp;&nbsp;Deep Residual Learning for Image Recognition的作者认为，堆积网络层数不应该降低网络性能，因为我们可以简单地在当前网络上堆积身份映射（层不做任何事情），并且所得到的架构将执行相同的操作。这表明，较深的模型所产生的训练误差不应该比较浅的模型高。他们假设让堆积层适应残差映射比使它们直接适应所需的底层映射要容易得多。下图的残差块可以明确地使它做到这一点。 4.8.3 ResNet架构&nbsp;&nbsp;&nbsp;&nbsp;事实上，ResNet并不是第一个利用short cut、Highway Networks引入门控近路连接的。这些参数化门控制允许多少信息流过近路（shortcut）。类似的想法可以在长短期记忆网络（LSTM）单元中找到，其中存在参数化的忘记门，其控制多少信息将流向下一个时间步。因此，ResNet可以被认为是Highway Networks的一种特殊情况。 &nbsp;&nbsp;&nbsp;&nbsp;然而，实验表明，Highway Networks的性能并不如ResNet，因为Highway Networks的解决方案空间包含ResNet，因此它应该至少表现得像ResNet一样好。这就表明，保持这些“梯度公路”干净简洁比获取更大的解决方案空间更为重要。 &nbsp;&nbsp;&nbsp;&nbsp;照着这种直觉，论文作者改进了残差块，并提出了一个残差块的预激活变体，其中梯度可以畅通无阻地通过快速连接到任何其他的前层。论文的实验结果表明，使用原始的残差块，训练1202层ResNet所展示的性能比其训练110层对等物要差得多。 4.8.4 ResNeXt&nbsp;&nbsp;&nbsp;&nbsp;S. Xie，R. Girshick，P. Dollar，Z. Tu和 K. He在Aggregated Residual Transformations for Deep Neural Networks中提出了一个代号为ResNeXt的ResNet变体，它具有以下构建块： &nbsp;&nbsp;&nbsp;&nbsp;左：《Deep Residual Learning for Image Recognition》中所提及的构建块，右图： ResNeXt构建块 基数=32 &nbsp;&nbsp;&nbsp;&nbsp;这可能看起来很熟悉，因为它非常类似于《IEEE计算机视觉与模式识别会议论文集》中《Going deeper with convolutions》的Inception模块，它们都遵循“拆分-转换-合并”范式，除了在这个变体中，不同路径的输出通过将它们相加在一起而被合并，而在《Going deeper with convolutions》中它们是深度连接的。另一个区别是，在《Going deeper with convolutions》中，每个路径彼此互不相同（1x1,3x3和5x5卷积），而在此架构中，所有路径共享相同的拓扑。 &nbsp;&nbsp;&nbsp;&nbsp;作者介绍了一个称为 “基数（cardinality）”的超参数——独立路径的数量，以提供调整模型容量的新方式。实验表明，可以通过增加基数，而不是深度或宽度，来更加有效地获得准确度。作者指出，与Inception相比，这种新颖的架构更容易适应新的数据集/任务，因为它具有一个简单的范式，且只有一个超参数被调整，而Inception却具有许多超参数（如每个路径中卷积层内核大小）待调整。 &nbsp;&nbsp;&nbsp;&nbsp;这个新颖的构建块有如下三种等效形式： 实际上，“分割-变换-合并”通常是通过点分组卷积层来完成的，它将其输入分成特征映射组，并分别执行正常卷积，其输出被深度级联，然后馈送到1x1卷积层。 4.8.5 ResNet作为小型网络的组合&nbsp;&nbsp;&nbsp;&nbsp;Deep Networks with Stochastic Depth提出了一种反直觉的方式，训练一个非常深层的网络，通过在训练期间随机丢弃它的层，并在测试时间内使用完整的网络。Veit等人有一个更反直觉的发现：我们实际上可以删除一些已训练的ResNet的一些层，但仍然具有可比性能。这使得ResNet架构更加有趣，该论文亦降低了VGG网络的层，并大大降低了其性能。该论文首先提供了ResNet的一个简单的视图，使事情更清晰。在我们展开网络架构之后，这是很显而易见的，具有i个残差块的ResNet架构具有$2^{i}$个不同的路径（因为每个残差块提供两个独立的路径）。 &nbsp;&nbsp;&nbsp;&nbsp;鉴于上述发现，我们很容易发现为什么在ResNet架构中删除几层，对于其性能影响不大——架构具有许多独立的有效路径，在我们删除了几层之后，它们大部分保持不变。相反，VGG网络只有一条有效的路径，所以删除一层是唯一的途径。 &nbsp;&nbsp;&nbsp;&nbsp;作者还进行了实验，表明ResNet中的路径集合具有集合行为。他们是通过在测试时间删除不同数量的层，然后查看网络的性能是否与已删除层的数量平滑相关，这样的方式做到的。结果表明，网络确实表现得像集合，如下图所示： 4.8.6 ResNet中路径的特点&nbsp;&nbsp;&nbsp;&nbsp;最后，作者研究了ResNet中路径的特点： &nbsp;&nbsp;&nbsp;&nbsp;很明显，所有可能的路径长度的分布都遵循二项式分布，如（a）所示。大多数路径经过19到35个残差块。 &nbsp;&nbsp;&nbsp;&nbsp;​ 调查路径长度与经过其的梯度大小之间的关系，同时获得长度为k的路径的梯度幅度，作者首先将一批数据馈送给网络，随机抽取k个残差块。当反向传播梯度时，它们仅传播到采样残余块的权重层。（b）表明随着路径变长，梯度的大小迅速下降。 &nbsp;&nbsp;&nbsp;&nbsp;​ 我们现在可以将每个路径长度的频率与其预期的梯度大小相乘，以了解每个长度的路径对于训练有多少帮助，如（c）所示。令人惊讶的是，大多数贡献来自长度为9至18的路径，但它们仅占总路径的一小部分，如（a）所示。这是一个非常有趣的发现，因为它表明ResNet并没有解决长路径上的梯度消失问题，而是通过缩短其有效路径，ResNet实际上能够实现训练非常深度的网络。 &nbsp;&nbsp;&nbsp;&nbsp;答案来源：ResNet有多大威力？最近又有了哪些变体？一文弄清 4.9 为什么现在的CNN模型都是在GoogleNet、VGGNet或者AlexNet上调整的？ 评测对比：为了让自己的结果更有说服力，在发表自己成果的时候会同一个标准的baseline及在baseline上改进而进行比较，常见的比如各种检测分割的问题都会基于VGG或者Resnet101这样的基础网络。 时间和精力有限：在科研压力和工作压力中，时间和精力只允许大家在有限的范围探索。 模型创新难度大：进行基本模型的改进需要大量的实验和尝试，并且需要大量的实验积累和强大灵感，很有可能投入产出比比较小。 资源限制：创造一个新的模型需要大量的时间和计算资源，往往在学校和小型商业团队不可行。 在实际的应用场景中，其实是有大量的非标准模型的配置。]]></content>
      <categories>
        <category>Machine Leaning</category>
      </categories>
      <tags>
        <tag>经典网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra 和 Ben-Ford算法]]></title>
    <url>%2F2018%2F12%2F14%2F2018%2F2018-12-14-dijkstra%2F</url>
    <content type="text"><![CDATA[1. Dijkstra算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxv = 1000; //最大顶点数const int inf = 10000000; //inf 表示最大的数即为不可达int n, m, s, G[maxv][maxv]; // n为顶点数，m为边数，G表示两顶点之间的权值int d[maxv]; // 记录起点到各个顶点之间的最短距离bool vis[maxv] = &#123;false&#125;; //数组标记，true表示已访问，初始为falsevoid Dijkstra(int s)&#123; fill(d, d + maxv, inf); // 将整个d数据初始化为inf d[s] = 0; for (int i = 0; i &lt; n; ++i)&#123; int u = -1, min = inf; // min存放d[u]的最小值 for (int j = 0; j &lt; n; ++j)&#123; // 找到未访问的顶点中d最小 if(vis[j] == false &amp;&amp; d[j] &lt; min)&#123; u = j; min = d[j]; &#125; &#125; if(u == -1) return; // 找不到小于inf的d[u]，说明剩下的顶点和起点不相通 vis[u] = true; for(int v = 0; v &lt; n; v++)&#123; //若v未访问，u能到达v,u为中间点d[v]更优，则跟新d if(vis[v] == false &amp;&amp; G[u][v] != inf &amp;&amp; d[u] + G[u][v] &lt; d[v])&#123; d[v] = d[u] + G[u][v]; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; int u, v, w; scanf("%d%d%d", &amp;n, &amp;m, &amp;s); fill(G[0], G[0] + maxv * maxv, inf); for (int i = 0; i &lt; m; ++i) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); G[u][v] = w; &#125; printf("Dijkstra:\n"); Dijkstra(s); for (int i = 0; i &lt; n; ++i) &#123; printf("%d ", d[i]); &#125; return 0;&#125; 2. Ben-Ford算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxv = 1000; //最大顶点数const int inf = 10000000; //inf 表示最大的数即为不可达struct Node&#123; int v, dis; //v 为邻接边的目标顶点，dis为其权值 Node(int _v, int _dis): v(_v), dis(_dis) &#123;&#125;&#125;;vector&lt;Node&gt; Adj[maxv]; // 邻接表int n, m, s, d[maxv];bool Bellman_Ford(int s) &#123; //s为起点 fill(d, d + maxv, inf); d[s] = 0; for (int i = 0; i &lt; n - 1; ++i)&#123; // 求解数d，执行n-1轮操作，每轮操作遍历整个边 for(int u = 0; u &lt; n; ++u)&#123; for(int j = 0; j &lt; Adj[u].size(); ++j)&#123; int v = Adj[u][j].v; int dis = Adj[u][j].dis; if(d[u] + dis &lt; d[v]) d[v] = d[u] + dis; // 以u为中介使d[v]更小 &#125; &#125; &#125; for(int u = 0; u &lt; n; ++u)&#123; // 判断是否有负环，对每条边都判断，返回false说明有负环 for(int j = 0; j &lt; Adj[u].size(); ++j)&#123; int v = Adj[u][j].v; int dis = Adj[u][j].dis; if(d[u] + dis &lt; d[v]) return false; &#125; &#125; return true;&#125;int main(int argc, char const *argv[])&#123; int u, v, w; scanf("%d%d%d", &amp;n, &amp;m, &amp;s); for (int i = 0; i &lt; m; ++i) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); Adj[u].push_back(Node(v, w)); &#125; printf("Bellman_Ford:\n"); if(Bellman_Ford(s) == true) &#123; for (int i = 0; i &lt; n; ++i)&#123; printf("%d ", d[i]); &#125; &#125; else printf("有负环\n"); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dijkstra算法</tag>
        <tag>Ben-Ford算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视觉3D点云图构建与深度测量]]></title>
    <url>%2F2018%2F12%2F12%2F2018%2F2018-12-12-%E8%A7%86%E8%A7%893d%E7%82%B9%E4%BA%91%E5%9B%BE%E6%9E%84%E5%BB%BA%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E9%87%8F%2F</url>
    <content type="text"><![CDATA[实验 2 视觉 3D 点云图构建与深度测量 实验内容： 矩阵运算库 Eigen 的使用 彩色图、深度图的读取与参数提取 相机参数加载与使用 点云地图拼接 双目视觉系统标定与深度测量(限实验设计) 实验设备： 自带笔记本 PC 机摄像头/USB 摄像头，安装 Ubuntu14.04 或以上系统，OpenCV 开发库 预备知识： 深度相机原理 深度图像采集过程及坐标转换关系 linux，C++编程基础，Cmake 编译器使用 Eigen 矩阵运算库，OpenCV 图像处理库 所需文件： color文件夹有5张彩色图depth有五张深度图joinMap.cpp如下pose.txt为相机参数 中心思想 三个坐标系：世界坐标系，相机坐标系，像素坐标系两个参数：K(内参)，(T)外参 K和T都是一个4*4欧式变换矩阵，k实现像素坐标系和像素坐标系之间转换，T实现世界坐标系和相机坐标系之间的转换如下公式，K由fx,fy,cx,cy四个参数决定，T由pose.txt中数据确定最终根据最下面的公式，由各个像素坐标中的像素点得到世界坐标系点，然后用pcl转化成点云图。注意：点云图中的点是三维点，所以还需要一个量–d深度，由depth文件夹中五张深度图获得，而深度图怎么获得呢？有三种相机可获得。。。后面再讲还有，opencv3安装，依赖；Eigen安装，pcl安装等问题如下图，实在不懂自己百度。。。。 代码及详细分析（我不相信你还有比我还详细的了，哼。。。）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;Eigen/Geometry&gt;#include &lt;boost/format.hpp&gt; // for formating strings#include &lt;pcl/point_types.h&gt;#include &lt;pcl/io/pcd_io.h&gt;#include &lt;pcl/visualization/pcl_visualizer.h&gt;/*通过点云拼接，我们就可以还原这个房间的三维场景。已知：5张RGB-D图像，每个图像的内参K和外参T目标：计算所有像素在世界坐标系的位置，把点云加起来，组成地图。思路：根据pose.txt中相机外参（平移向量+旋转四元数）转换成变换矩阵T（4*4）；对相机坐标（根据像素和实物关系得到）通T转换成世界坐标；之后根据5张图循环构造点云。 */int main( int argc, char** argv )&#123; vector&lt;cv::Mat&gt; colorImgs, depthImgs; // 彩色图和深度图 // 相机位姿, 5*7，表示五张图片，每张图片对应7个数前三个数是平移向量，后四个是旋转四元数 // poses 是长度为5的数组，每个元素是个矩阵（4*4） vector&lt;Eigen::Isometry3d, Eigen::aligned_allocator&lt;Eigen::Isometry3d&gt;&gt; poses; ifstream fin("./pose.txt"); if (!fin) &#123; cerr&lt;&lt;"请在有pose.txt的目录下运行此程序"&lt;&lt;endl; return 1; &#125; for ( int i=0; i&lt;5; i++ ) &#123; // 照片读取，boost::format 格式化字符串 拼接出图片文件名 boost::format fmt( "./%s/%d.%s" ); //图像文件格式 colorImgs.push_back( cv::imread( (fmt%"color"%(i+1)%"png").str() )); depthImgs.push_back( cv::imread( (fmt%"depth"%(i+1)%"pgm").str(), -1 )); // 使用-1读取原始图像 // 相机位姿读取到组data[] double data[7] = &#123;0&#125;; for ( auto&amp; d:data ) //auto自动类型转换 fin&gt;&gt;d; //文件流类型的变量fin将pose.txt中的数据给了d数组 Eigen::Quaterniond q( data[6], data[3], data[4], data[5] ); //四元数 data[6]是实数 但是coeffis输出的是先虚数后实数 Eigen::Isometry3d T(q); //变换矩阵T初始化旋转部分 T.pretranslate( Eigen::Vector3d( data[0], data[1], data[2] )); //T初始化平移向量部分 poses.push_back( T ); //存储T到位姿数组中 &#125; // 计算点云并拼接 // 相机内参 double cx = 325.5; double cy = 253.5; double fx = 518.0; double fy = 519.0; double depthScale = 1000.0; cout&lt;&lt;"正在将图像转换为点云..."&lt;&lt;endl; // 定义点云使用的格式：这里用的是XYZRGB typedef pcl::PointXYZRGB PointT; typedef pcl::PointCloud&lt;PointT&gt; PointCloud; // 新建一个点云 PointCloud::Ptr pointCloud( new PointCloud ); for ( int i=0; i&lt;5; i++ ) &#123; cout&lt;&lt;"转换图像中: "&lt;&lt;i+1&lt;&lt;endl; cv::Mat color = colorImgs[i]; cv::Mat depth = depthImgs[i]; Eigen::Isometry3d T = poses[i]; for ( int v=0; v&lt;color.rows; v++ ) for ( int u=0; u&lt;color.cols; u++ ) &#123; unsigned int d = depth.ptr&lt;unsigned short&gt; ( v )[u]; // 深度值v,u像素对应的深度值 if ( d==0 ) continue; // 为0表示没有测量到 // 将像素坐标(u,v,d)计算到相机坐标系下坐标 point Eigen::Vector3d point; point[2] = double(d)/depthScale; point[0] = (u-cx)*point[2]/fx; point[1] = (v-cy)*point[2]/fy; // 通过外参T将相机坐标系中的point转化成世界坐标系中的pointWorld Eigen::Vector3d pointWorld = T*point; // 将世界坐标系中的坐标放入点云图中的点中 PointT p ; p.x = pointWorld[0]; p.y = pointWorld[1]; p.z = pointWorld[2]; // 获取彩色图中各个像素点的bgr值 p.b = color.data[ v*color.step+u*color.channels() ]; p.g = color.data[ v*color.step+u*color.channels()+1 ]; p.r = color.data[ v*color.step+u*color.channels()+2 ]; pointCloud-&gt;points.push_back( p ); &#125; &#125; pointCloud-&gt;is_dense = false; cout&lt;&lt;"点云共有"&lt;&lt;pointCloud-&gt;size()&lt;&lt;"个点."&lt;&lt;endl; pcl::io::savePCDFileBinary("map.pcd", *pointCloud ); return 0;&#125;]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>OpenCV</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习入门必须理解这25个概念]]></title>
    <url>%2F2018%2F12%2F09%2F2018%2F2018-12-09-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E5%BF%85%E9%A1%BB%E7%90%86%E8%A7%A3%E8%BF%9925%E4%B8%AA%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[这篇博客对于DL小白或者用于复习还是有点好处的本文转载自这篇post 神经网络基础1）神经元（Neuron）——就像形成我们大脑基本元素的神经元一样，神经元形成神经网络的基本结构。想象一下，当我们得到新信息时我们该怎么做。当我们获取信息时，我们一般会处理它，然后生成一个输出。类似地，在神经网络的情况下，神经元接收输入，处理它并产生输出，而这个输出被发送到其他神经元用于进一步处理，或者作为最终输出进行输出。 2）权重（Weights）——当输入进入神经元时，它会乘以一个权重。例如，如果一个神经元有两个输入，则每个输入将具有分配给它的一个关联权重。我们随机初始化权重，并在模型训练过程中更新这些权重。训练后的神经网络对其输入赋予较高的权重，这是它认为与不那么重要的输入相比更为重要的输入。为零的权重则表示特定的特征是微不足道的。让我们假设输入为a，并且与其相关联的权重为W1，那么在通过节点之后，输入变为a * W1 3）偏差（Bias）——除了权重之外，另一个被应用于输入的线性分量被称为偏差。它被加到权重与输入相乘的结果中。基本上添加偏差的目的是来改变权重与输入相乘所得结果的范围的。添加偏差后，结果将看起来像a* W1 +偏差。这是输入变换的最终线性分量。 4）激活函数（Activation Function）——一旦将线性分量应用于输入，将会需要应用一个非线性函数。这通过将激活函数应用于线性组合来完成。激活函数将输入信号转换为输出信号。应用激活函数后的输出看起来像f（a * W1 + b），其中f（）就是激活函数。 在下图中，我们将“n”个输入给定为X1到Xn而与其相应的权重为Wk1到Wkn。我们有一个给定值为bk的偏差。权重首先乘以与其对应的输入，然后与偏差加在一起。而这个值叫做u。$ U = \sum W * X + b $ 激活函数被应用于u，即 f(u)，并且我们会从神经元接收最终输出，如yk = f（u）。 常用的激活函数最常用的激活函数就是Sigmoid，ReLU和softmax a）Sigmoid——最常用的激活函数之一是Sigmoid，它被定义为：$$sigmoid(x) = 1/(1 + e^{-x})$$ Sigmoid变换产生一个值为0到1之间更平滑的范围。我们可能需要观察在输入值略有变化时输出值中发生的变化。光滑的曲线使我们能够做到这一点，因此优于阶跃函数。 b）ReLU（整流线性单位）——与Sigmoid函数不同的是，最近的网络更喜欢使用ReLu激活函数来处理隐藏层。该函数定义为：$$f(x) = max(x, 0)$$ 当X&gt;0时，函数的输出值为X；当X&lt;=0时，输出值为0。函数图如下图所示： 使用ReLU函数的最主要的好处是对于大于0的所有输入来说，它都有一个不变的导数值。常数导数值有助于网络训练进行得更快。 c） Softmax——Softmax激活函数通常用于输出层，用于分类问题。它与sigmoid函数是很类似的，唯一的区别就是输出被归一化为总和为1。Sigmoid函数将发挥作用以防我们有一个二进制输出，但是如果我们有一个多类分类问题，softmax函数使为每个类分配值这种操作变得相当简单，而这可以将其解释为概率。 以这种方式来操作的话，我们很容易看到——假设你正在尝试识别一个可能看起来像8的6。该函数将为每个数字分配值如下。我们可以很容易地看出，最高概率被分配给6，而下一个最高概率分配给8，依此类推…… 5）神经网络（Neural Network）——神经网络构成了深度学习的支柱。神经网络的目标是找到一个未知函数的近似值。它由相互联系的神经元形成。这些神经元具有权重和在网络训练期间根据错误来进行更新的偏差。激活函数将非线性变换置于线性组合，而这个线性组合稍后会生成输出。激活的神经元的组合会给出输出值。 一个很好的神经网络定义——“神经网络由许多相互关联的概念化的人造神经元组成，它们之间传递相互数据，并且具有根据网络”经验“调整的相关权重。神经元具有激活阈值，如果通过其相关权重的组合和传递给他们的数据满足这个阈值的话，其将被解雇;发射神经元的组合导致“学习”。 6）输入/输出/隐藏层（Input / Output / Hidden Layer）——正如它们名字所代表的那样，输入层是接收输入那一层，本质上是网络的第一层。而输出层是生成输出的那一层，也可以说是网络的最终层。处理层是网络中的隐藏层。这些隐藏层是对传入数据执行特定任务并将其生成的输出传递到下一层的那些层。输入和输出层是我们可见的，而中间层则是隐藏的。 7）MLP（多层感知器）——单个神经元将无法执行高度复杂的任务。因此，我们使用堆栈的神经元来生成我们所需要的输出。在最简单的网络中，我们将有一个输入层、一个隐藏层和一个输出层。每个层都有多个神经元，并且每个层中的所有神经元都连接到下一层的所有神经元。这些网络也可以被称为完全连接的网络。 8）正向传播（Forward Propagation）——正向传播是指输入通过隐藏层到输出层的运动。在正向传播中，信息沿着一个单一方向前进。输入层将输入提供给隐藏层，然后生成输出。这过程中是没有反向运动的。 9）成本函数（Cost Function）——当我们建立一个网络时，网络试图将输出预测得尽可能靠近实际值。我们使用成本/损失函数来衡量网络的准确性。而成本或损失函数会在发生错误时尝试惩罚网络。 我们在运行网络时的目标是提高我们的预测精度并减少误差，从而最大限度地降低成本。最优化的输出是那些成本或损失函数值最小的输出。 如果我将成本函数定义为均方误差，则可以写为：$$C = \frac {1}{m} \sum (y - a)^2$$其中m是训练输入的数量，a是预测值，y是该特定示例的实际值。 学习过程围绕最小化成本来进行。 10）梯度下降（Gradient Descent）——梯度下降是一种最小化成本的优化算法。要直观地想一想，在爬山的时候，你应该会采取小步骤，一步一步走下来，而不是一下子跳下来。因此，我们所做的就是，如果我们从一个点x开始，我们向下移动一点，即Δh，并将我们的位置更新为x-Δh，并且我们继续保持一致，直到达到底部。考虑最低成本点。 在数学上，为了找到函数的局部最小值，我们通常采取与函数梯度的负数成比例的步长。 11）学习率（Learning Rate）——学习率被定义为每次迭代中成本函数中最小化的量。简单来说，我们下降到成本函数的最小值的速率是学习率。我们应该非常仔细地选择学习率，因为它不应该是非常大的，以至于最佳解决方案被错过，也不应该非常低，以至于网络需要融合。 12）反向传播（Backpropagation）——当我们定义神经网络时，我们为我们的节点分配随机权重和偏差值。一旦我们收到单次迭代的输出，我们就可以计算出网络的错误。然后将该错误与成本函数的梯度一起反馈给网络以更新网络的权重。 最后更新这些权重，以便减少后续迭代中的错误。使用成本函数的梯度的权重的更新被称为反向传播。 在反向传播中，网络的运动是向后的，错误随着梯度从外层通过隐藏层流回，权重被更新。 13）批次（Batches）——在训练神经网络的同时，不用一次发送整个输入，我们将输入分成几个随机大小相等的块。与整个数据集一次性馈送到网络时建立的模型相比，批量训练数据使得模型更加广义化。 14）周期（Epochs）——周期被定义为向前和向后传播中所有批次的单次训练迭代。这意味着1个周期是整个输入数据的单次向前和向后传递。 你可以选择你用来训练网络的周期数量，更多的周期将显示出更高的网络准确性，然而，网络融合也需要更长的时间。另外，你必须注意，如果周期数太高，网络可能会过度拟合。 15）丢弃（Dropout）——Dropout是一种正则化技术，可防止网络过度拟合套。顾名思义，在训练期间，隐藏层中的一定数量的神经元被随机地丢弃。这意味着训练发生在神经网络的不同组合的神经网络的几个架构上。你可以将Dropout视为一种综合技术，然后将多个网络的输出用于产生最终输出。 16）批量归一化（Batch Normalization）——作为一个概念，批量归一化可以被认为是我们在河流中设定为特定检查点的水坝。这样做是为了确保数据的分发与希望获得的下一层相同。当我们训练神经网络时，权重在梯度下降的每个步骤之后都会改变，这会改变数据的形状如何发送到下一层。 但是下一层预期分布类似于之前所看到的分布。 所以我们在将数据发送到下一层之前明确规范化数据。 卷积神经网络17）滤波器（Filters）——CNN中的滤波器与加权矩阵一样，它与输入图像的一部分相乘以产生一个回旋输出。我们假设有一个大小为28 28的图像，我们随机分配一个大小为3 3的滤波器，然后与图像不同的3 * 3部分相乘，形成所谓的卷积输出。滤波器尺寸通常小于原始图像尺寸。在成本最小化的反向传播期间，滤波器值被更新为重量值。 参考一下下图，这里filter是一个3 * 3矩阵： 与图像的每个3 * 3部分相乘以形成卷积特征。 18）卷积神经网络（CNN）——卷积神经网络基本上应用于图像数据。假设我们有一个输入的大小（28 28 3），如果我们使用正常的神经网络，将有2352（28 28 3）参数。并且随着图像的大小增加参数的数量变得非常大。我们“卷积”图像以减少参数数量（如上面滤波器定义所示）。当我们将滤波器滑动到输入体积的宽度和高度时，将产生一个二维激活图，给出该滤波器在每个位置的输出。我们将沿深度尺寸堆叠这些激活图，并产生输出量。 你可以看到下面的图，以获得更清晰的印象。 19）池化（Pooling）——通常在卷积层之间定期引入池层。这基本上是为了减少一些参数，并防止过度拟合。最常见的池化类型是使用MAX操作的滤波器尺寸（2,2）的池层。它会做的是，它将占用原始图像的每个4 * 4矩阵的最大值。 你还可以使用其他操作（如平均池）进行池化，但是最大池数量在实践中表现更好。 20）填充（Padding）——填充是指在图像之间添加额外的零层，以使输出图像的大小与输入相同。这被称为相同的填充。 在应用滤波器之后，在相同填充的情况下，卷积层具有等于实际图像的大小。 有效填充是指将图像保持为具有实际或“有效”的图像的所有像素。在这种情况下，在应用滤波器之后，输出的长度和宽度的大小在每个卷积层处不断减小。 21）数据增强（Data Augmentation）——数据增强是指从给定数据导出的新数据的添加，这可能被证明对预测有益。例如，如果你使光线变亮，可能更容易在较暗的图像中看到猫，或者例如，数字识别中的9可能会稍微倾斜或旋转。在这种情况下，旋转将解决问题并提高我们的模型的准确性。通过旋转或增亮，我们正在提高数据的质量。这被称为数据增强。 循环神经网络 22）循环神经元（Recurrent Neuron）——循环神经元是在T时间内将神经元的输出发送回给它。如果你看图，输出将返回输入t次。展开的神经元看起来像连接在一起的t个不同的神经元。这个神经元的基本优点是它给出了更广义的输出。 23）循环神经网络（RNN）——循环神经网络特别用于顺序数据，其中先前的输出用于预测下一个输出。在这种情况下，网络中有循环。隐藏神经元内的循环使他们能够存储有关前一个单词的信息一段时间，以便能够预测输出。隐藏层的输出在t时间戳内再次发送到隐藏层。展开的神经元看起来像上图。只有在完成所有的时间戳后，循环神经元的输出才能进入下一层。发送的输出更广泛，以前的信息保留的时间也较长。 然后根据展开的网络将错误反向传播以更新权重。这被称为通过时间的反向传播（BPTT）。 24）消失梯度问题（Vanishing Gradient Problem）——激活函数的梯度非常小的情况下会出现消失梯度问题。在权重乘以这些低梯度时的反向传播过程中，它们往往变得非常小，并且随着网络进一步深入而“消失”。这使得神经网络忘记了长距离依赖。这对循环神经网络来说是一个问题，长期依赖对于网络来说是非常重要的。 这可以通过使用不具有小梯度的激活函数ReLu来解决。 25）激增梯度问题（Exploding Gradient Problem）——这与消失的梯度问题完全相反，激活函数的梯度过大。在反向传播期间，它使特定节点的权重相对于其他节点的权重非常高，这使得它们不重要。这可以通过剪切梯度来轻松解决，使其不超过一定值。 本文原作：https://blog.csdn.net/pangjiuzala/article/details/72630166]]></content>
      <categories>
        <category>Machine Leaning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于OpenCV的颜色特征识别]]></title>
    <url>%2F2018%2F12%2F09%2F%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E9%A2%9C%E8%89%B2%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[这篇post是智能机器人技术实验 实验 1 基于OpenCV的颜色特征识别 实验设备：平台二选一： 平台一：树莓派, Linux OS, OpenCV 开发库 平台二： 个人计算机，Linux OS,USB 摄像头，OpenCV 开发库 预备知识： 数字图像处理基础 C++、python 编程基础 Linux 系统基本操作基础 关于颜色特征识别的一些知识：1. CamShift算法：全称是 Continuously AdaptiveMeanShift，顾名思义，它是对Mean Shift 算法的改进，能够自动调节搜索窗口大小来适应目标的大小，可以跟踪视频中尺寸变化的目标。它也是一种半自动跟踪算法，需要手动标定跟踪目标。基本思想是以视频图像中运动物体的颜色信息作为特征，对输入图像的每一帧分别作 Mean-Shift 运算，并将上一帧的目标中心和搜索窗口大小(核函数带宽)作为下一帧 Mean shift 算法的中心和搜索窗口大小的初始值，如此迭代下去，就可以实现对目标的跟踪。因为在每次搜索前将搜索窗口的位置和大小设置为运动目标当前中心的位置和大小，而运动目标通常在这区域附近，缩短了搜索时间；另外，在目标运动过程中，颜色变化不大，故该算法具有良好的鲁棒性。已被广泛应用到运动人体跟踪，人脸跟踪等领域。 2. 算法流程 3. 代码及分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#!/usr/bin/env python# -*- coding: utf-8 -*-import numpy as npimport cv2import serial# from picamera.array import PiRGBArray# from picamera import PiCamera# import time# import copyimport video # 调取摄像头from matplotlib import pyplot as pltclass App(object): def __init__(self, color): # 获取图片 self.cam = video.create_capture(0)# self.cam = PiCamera()# self.cam.resolution = (320,240)# self.cam.framerate = 32# self.rCa = PiRGBArray(self.cam, size=(320,240))# time.sleep(0.1)# self.cam.capture(self.rCa, format='bgr')# self.frame = self.rCa.array# ret, self.frame = self.cam.read() cv2.namedWindow('camshift') # 通过命名的方式，创建了一个窗口 if color == 0: self.roi = cv2.imread( 'lan.jpg' ) self.flag = "lan" else : self.flag = "hong" self.roi = cv2.imread('hong.png') self.selection = None self.tracking_state = 0 self.show_backproj = False# self.ser = serial.Serial('/dev/ttyAMA0',115200,timeout=0.5) def start(self): # start方法用来设置一些状态，初始化信息 # tracking_state 判断是否进行追踪 self.tracking_state = 0 #x, y = np.int16([220, 110]) # BUG if self.flag == 'Hong': self.selection = (4, 6, 407, 304) # 设置初始追踪窗口 else: self.selection = (40, 54, 296, 230) self.tracking_state = 1 # print "start" def show_hist(self): # 直方图显示 bin_count = self.hist.shape[0] # hist在行数，在这里是16，即有16个条纹 print("hist,bin",self.hist.shape, bin_count, self.hist) bin_w = 24 # 每条条纹宽度 img = np.zeros((256, bin_count*bin_w, 3), np.uint8) # 初始化img图像，用于显示直方图，大小为256*(24*16) for i in xrange(bin_count): # 对每一条纹绘制 h = int(self.hist[i]) cv2.rectangle(img, (i*bin_w+2, 255), ((i+1)*bin_w-2, 255-h), (int(180.0*i/bin_count), 255, 255), -1) img = cv2.cvtColor(img, cv2.COLOR_HSV2BGR) # 将图像格式HSV转化成BGR cv2.imshow('hist', img) def run(self): #主要功能函数 roi = self.roi # roi存放目标图像 self.start() while True: # 死循环，通过Ctrl + C 退出# for frame in self.cam.capture_continuous(self.rCa, format='bgr', use_video_port=True): ret, self.frame = self.cam.read() # 通过摄像头获取图像# self.frame = frame.array # frame为摄像头获取的图像 vis = self.frame.copy() # vis复制frame# vis = copy.deepcopy(self.frame) hsv = cv2.cvtColor(self.frame, cv2.COLOR_BGR2HSV) mask = cv2.inRange(hsv, np.array((0., 60., 32.)), np.array((180., 255., 255.))) # 掩模图像。要统计整幅图像的直方图就把它设为 None。但是如 果你想统计图像某一部分的直方图的话，你就需要制作一个掩模图像，并 使用它。# self.selection = 1 if self.selection:# x0, y0, x1, y1 = 220, 110, 358, 245 x0, y0, x1, y1 = self.selection self.track_window = (x0, y0, x1-x0, y1-y0) # 窗口缩小# hsv_roi = hsv[y0:y1, x0:x1]# mask_roi = mask[y0:y1, x0:x1] hsv_roi = cv2. cvtColor(roi,cv2. COLOR_BGR2HSV) mask_roi = cv2.inRange(hsv_roi, np.array((0., 60., 32.)), np.array((180., 255., 255.))) #一维直方图 hist = cv2.calcHist( [hsv_roi], [0], mask_roi, [16], [0, 180] ) #二维直方图# hist = cv2.calcHist( [hsv_roi], [0,2],None, [180,256], [0, 180,0 , 255] ) cv2.normalize(hist, hist, 0, 255, cv2.NORM_MINMAX); self.hist = hist.reshape(-1) #二维直方图显示# plt.imshow(hist,interpolation = 'nearest')# plt.show() self.show_hist() vis_roi = vis[y0:y1, x0:x1] cv2.bitwise_not(vis_roi, vis_roi) # 颜色反转 vis[mask == 0] = 0 if self.tracking_state == 1: self.selection = None prob = cv2.calcBackProject([hsv], [0], self.hist, [0, 180], 1) # 计算反向投影参数为：捕获的图片（转化成hsv格式），灰度值方式，目标图像直方图，直方图范围 prob &amp;= mask term_crit = ( cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 1 ) # 跳出条件，迭代10次或至少移动一次 track_box, self.track_window = cv2.CamShift(prob, self.track_window, term_crit) # 利用cameshift算法在追踪窗口中搜寻与直方图分布最相似的窗口，结果返回窗口和track_box# if track_box[0][1] &lt;= 240:# self.ser.write(str(int(track_box[0][0])-320) + " " + str(int(track_box[0][1])-240))# print str(int(track_box[0][0])-320) + " " + str(int(track_box[0][1])-240) if track_box[1][1] &lt;= 1: self.tracking_state = 0 self.start() else: if self.show_backproj: vis[:] = prob[...,np.newaxis] try: cv2.ellipse(vis, track_box, (0, 0, 255), 2)#利用返回的track_box画出椭圆# print track_box a = str(track_box[0][0])+" "+str(track_box[0][1])+" "+str(round(track_box[1][0],2))\ +" "+str(round(track_box[1][1],2))+" "+str(round(track_box[2],2))+"\r\n" print a# self.ser.write(a) except: print track_box cv2.imshow('camshift', vis) # 通过键盘输入来实现一些功能 ch = 0xFF &amp; cv2.waitKey(5) if ch == 27: break if ch == ord('b'): self.show_backproj = not self.show_backproj if ch == ord('r'): self.tracking_state = 0 self.start() cv2.destroyAllWindows()if __name__ == '__main__': import sys try: color = sys.argv[1] except: color = 1 print __doc__ a = App(color) a.run() video.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#!/usr/bin/env python'''Video capture sample.Sample shows how VideoCapture class can be used to acquire videoframes from a camera of a movie file. Also the sample providesan example of procedural video generation by an object, mimickingthe VideoCapture interface (see Chess class).'create_capture' is a convinience function for capture creation,falling back to procedural video in case of error.Usage: video.py [--shotdir &lt;shot path&gt;] [source0] [source1] ...' sourceN is an - integer number for camera capture - name of video file - synth:&lt;params&gt; for procedural videoSynth examples: synth:bg=../cpp/lena.jpg:noise=0.1 synth:class=chess:bg=../cpp/lena.jpg:noise=0.1:size=640x480Keys: ESC - exit SPACE - save current frame to &lt;shot path&gt; director'''import numpy as npimport cv2from time import clockfrom numpy import pi, sin, cosimport commonclass VideoSynthBase(object): def __init__(self, size=None, noise=0.0, bg = None, **params): self.bg = None self.frame_size = (1000, 480)# self.frame_size = (640, 480) if bg is not None: self.bg = cv2.imread(bg, 1) h, w = self.bg.shape[:2] self.frame_size = (w, h) if size is not None: w, h = map(int, size.split('x')) self.frame_size = (w, h) self.bg = cv2.resize(self.bg, self.frame_size) self.noise = float(noise) def render(self, dst): pass def read(self, dst=None): w, h = self.frame_size if self.bg is None: buf = np.zeros((h, w, 3), np.uint8) else: buf = self.bg.copy() self.render(buf) if self.noise &gt; 0.0: noise = np.zeros((h, w, 3), np.int8) cv2.randn(noise, np.zeros(3), np.ones(3)*255*self.noise) buf = cv2.add(buf, noise, dtype=cv2.CV_8UC3) return True, buf def isOpened(self): return Trueclass Chess(VideoSynthBase): def __init__(self, **kw): super(Chess, self).__init__(**kw) w, h = self.frame_size self.grid_size = sx, sy = 10, 7 white_quads = [] black_quads = [] for i, j in np.ndindex(sy, sx): q = [[j, i, 0], [j+1, i, 0], [j+1, i+1, 0], [j, i+1, 0]] [white_quads, black_quads][(i + j) % 2].append(q) self.white_quads = np.float32(white_quads) self.black_quads = np.float32(black_quads) fx = 0.9 self.K = np.float64([[fx*w, 0, 0.5*(w-1)], [0, fx*w, 0.5*(h-1)], [0.0,0.0, 1.0]]) self.dist_coef = np.float64([-0.2, 0.1, 0, 0]) self.t = 0 def draw_quads(self, img, quads, color = (0, 255, 0)): img_quads = cv2.projectPoints(quads.reshape(-1, 3), self.rvec, self.tvec, self.K, self.dist_coef) [0] img_quads.shape = quads.shape[:2] + (2,) for q in img_quads: cv2.fillConvexPoly(img, np.int32(q*4), color, cv2.CV_AA, shift=2) def render(self, dst): t = self.t self.t += 1.0/30.0 sx, sy = self.grid_size center = np.array([0.5*sx, 0.5*sy, 0.0]) phi = pi/3 + sin(t*3)*pi/8 c, s = cos(phi), sin(phi) ofs = np.array([sin(1.2*t), cos(1.8*t), 0]) * sx * 0.2 eye_pos = center + np.array([cos(t)*c, sin(t)*c, s]) * 15.0 + ofs target_pos = center + ofs R, self.tvec = common.lookat(eye_pos, target_pos) self.rvec = common.mtx2rvec(R) self.draw_quads(dst, self.white_quads, (245, 245, 245)) self.draw_quads(dst, self.black_quads, (10, 10, 10))classes = dict(chess=Chess)presets = dict( empty = 'synth:', lena = 'synth:bg=../cpp/lena.jpg:noise=0.1', chess = 'synth:class=chess:bg=../cpp/lena.jpg:noise=0.1:size=640x480')def create_capture(source = 0, fallback = presets['chess']): '''source: &lt;int&gt; or '&lt;int&gt;|&lt;filename&gt;|synth [:&lt;param_name&gt;=&lt;value&gt; [:...]]' ''' source = str(source).strip() chunks = source.split(':') # hanlde drive letter ('c:', ...) if len(chunks) &gt; 1 and len(chunks[0]) == 1 and chunks[0].isalpha(): chunks[1] = chunks[0] + ':' + chunks[1] del chunks[0] source = chunks[0] try: source = int(source) except ValueError: pass params = dict( s.split('=') for s in chunks[1:] ) cap = None if source == 'synth': Class = classes.get(params.get('class', None), VideoSynthBase) try: cap = Class(**params) except: pass else: cap = cv2.VideoCapture(source) params["size"] = "320x240" if 'size' in params: w, h = map(int, params['size'].split('x')) cap.set(cv2.CAP_PROP_FRAME_WIDTH, w) cap.set(cv2.CAP_PROP_FRAME_HEIGHT, h) if cap is None or not cap.isOpened(): print('Warning: unable to open video source: ', source) if fallback is not None: return create_capture(fallback, None) return capif __name__ == '__main__': import sys import getopt print(__doc__) args, sources = getopt.getopt(sys.argv[1:], '', 'shotdir=') args = dict(args) shotdir = args.get('--shotdir', '.') if len(sources) == 0: sources = [ 0 ] caps = map(create_capture, sources) shot_idx = 0 while True: imgs = [] for i, cap in enumerate(caps): ret, img = cap.read() imgs.append(img) cv2.imshow('capture %d' % i, img) ch = 0xFF &amp; cv2.waitKey(1) if ch == 27: break if ch == ord(' '): for i, img in enumerate(imgs): fn = '%s/shot_%d_%03d.bmp' % (shotdir, i, shot_idx) cv2.imwrite(fn, img) print(fn, 'saved') shot_idx += 1 cv2.destroyAllWindows() 参考： https://blog.csdn.net/tiemaxiaosu/article/details/51649401 http://www.opencv.org.cn/opencvdoc/2.3.2/html/modules/video/doc/motion_analysis_and_object_tracking.html?highlight=camshift#cv2.CamShift]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>OpenCV</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天津中汽所参观]]></title>
    <url>%2F2018%2F12%2F04%2F2018%2F2018-12-04-%E5%A4%A9%E6%B4%A5%E4%B8%8A%E6%B1%BD%E5%8F%82%E8%A7%82%2F</url>
    <content type="text"><![CDATA[12月1日苏州和合肥的同学一起去天津中国汽车技术研究中心参观学校真有钱啊！这次参观每个人的花费至少1000。 火车上的午餐（50元以内可以报销） 中汽所提供的早餐 中汽所给每个人送的礼物 中汽所的领导和科软老师介绍各自单位的情况，后面还有提问环节（各位大佬问的问题都比较专业，我听得一脸懵逼。。。） 参观无人驾驶技术工作区]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>参观</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm安装和破解]]></title>
    <url>%2F2018%2F12%2F04%2Fpycharm%E5%AE%89%E8%A3%85%E5%92%8C%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[pycharm2017专业破解版1. 安装pycharm安装包 链接: https://pan.baidu.com/s/1uxmCo8VJiHVbBCQw5RIMEw 提取码: 6666 正常安装即可 2. 下载jar包链接: https://pan.baidu.com/s/1p9DFN0X7rq0N0Y2iapKMDA 提取码: 6666 3. 文件修改将下载的jar包放入pycharm安装目录的/bin下, 并修改两个以 vmoptions为结尾的启动文件。将改启动文件以记事本形式打开然后分别在最后加上以下内容：1-javaagent:jar包所在目录\JetbrainsCrack-2.6.10-release-enc.jar 4. 破解重启pycharm 后在下图中点击 Activation code 然后复制以下代码后点击Activate1BIG3CLIK6F-eyJsaWNlbnNlSWQiOiJCSUczQ0xJSzZGIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9XSwiaGFzaCI6IjQ3NzU1MTcvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-iygsIMXTVeSyYkUxAqpHmymrgwN5InkOfeRhhPIPa88FO9FRuZosIBTY18tflChACznk3qferT7iMGKm7pumDTR4FbVVlK/3n1ER0eMKu2NcaXb7m10xT6kLW1Xb3LtuZEnuis5pYuEwT1zR7GskeNWdYZ0dAJpNDLFrqPyAPo5s1KLDHKpw+VfVd4uf7RMjOIzuJhAAYAG+amyivQt61I9aYiwpHQvUphvTwi0X0qL/oDJHAQbIv4Qwscyo4aYZJBKutYioZH9rgOP6Yw/sCltpoPWlJtDOcw/iEWYiCVG1pH9AWjCYXZ9AbbEBOWV71IQr5VWrsqFZ7cg7hLEJ3A==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9 5. 查看打开pycharm点击help-&gt;about查看 发现一直到2099年12月31日才过期。]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux2]]></title>
    <url>%2F2018%2F12%2F03%2Flinux2%2F</url>
    <content type="text"><![CDATA[Linux命令二 基本命令 Linux 程序编译GCC:GNU Compiler Collection(GUN 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。 gcc是GCC中的GUN C Compiler（C 编译器） g++是GCC中的GUN C++ Compiler（C++编译器） gcc在Linux下自带的可以手动安装g++1234//安装g++编译器sudo apt-get install build-essential//修复g++编译器sudo apt-get install build-essential --fix-missing]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表二]]></title>
    <url>%2F2018%2F11%2F30%2F2018%2F2018-11-30-%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[3. Remove Duplicates from Sorted List Description:Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1-&gt;1-&gt;2Output: 1-&gt;2 Example 2: Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 Analysis: 迭代法 Solution:12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(head == nullptr) return nullptr; ListNode *pre = head, *p = head-&gt;next; while(p)&#123; if(pre-&gt;val == p-&gt;val) &#123; pre-&gt;next = p-&gt;next; delete p; p = pre-&gt;next; &#125; else &#123; pre = p; p = p-&gt;next; &#125; &#125; return head; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表一]]></title>
    <url>%2F2018%2F11%2F29%2Fleetcode%2F</url>
    <content type="text"><![CDATA[从今天起，开启一个新专题，刷 LeetCode! 线性表一&emsp;&emsp;下面都是很简单的小题，先熟悉熟悉。。。 1. Remove Duplicates from Sorted ArrayDescription:&emsp;Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.&emsp;Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1:123Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length. Example 2:123Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn’t matter what values are set beyond the returned length. Analysis:So easy, nothing to say! Solution: 123456789101112class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int count = 0; for(int i = 1; i &lt; nums.size(); i++)&#123; if(nums[count] != nums[i]) nums[++count] = nums[i]; &#125; return count + 1; &#125;&#125;; 2. Search in Rotated Sorted ArrayDescription: &emsp;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).&emsp;You are given a target value to search. If found in the array return its index, otherwise return -1.&emsp;You may assume no duplicate exists in the array.&emsp;Your algorithm’s runtime complexity must be in the order of O(logn). Example 1:12Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 Example 2:12Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 Analysis:O(logn)很明显用二分查找，主要在于判断mid在pivot的左侧还是右侧。 Solution:1234567891011121314151617181920class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size(); while(left != right) &#123; const int mid = left + (right - left) / 2; // 用const那能显著减少运行时间，不用mid = (left + right) / 2 主要考虑left，right是两个大数相加可能会溢出。 if(nums[mid] == target) return mid; if(nums[mid] &gt;= nums[left]) &#123; // 说明mid在左侧 if(nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) right = mid; else left = mid + 1; &#125; else &#123; // mid在右侧 if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right-1]) left = mid + 1; else right = mid; &#125; &#125; return -1; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[番茄工作法图解一]]></title>
    <url>%2F2018%2F11%2F26%2F%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一次只做一件事！ 第一章 一次只做一件事导致无法完成工作的原因： 面对复杂，望而却步–别考虑任务有多复杂，重要的时开始、再开始 无聊所事，越拖越久–想着完成一个番茄钟没多久 小事忙活一天，大事一样没动–做任务清单和今日代办，确保你一直在做最重要的事 最后期限，步步紧逼–25分钟为一个原子操作 从休息回到工作，心智调整不过来–番茄工作法一动作为导向，当你按下番茄时钟时就是动作，充分利用条件反射 一错再错，不长记性–番茄工作法要求在一天结束前要做三件事，记录、处理和可视化。等到习惯后在调整 没想到一件事要做那么久–将活动拆分成几个小项目 没想到一件事越做越复杂–将事件纳入计划外紧急事件 头脑被各种想法占据–纳入计划外紧急事件 时间都花在用来学习适应复杂的工作方法了–番茄工作法 只顾低头干活，忘了抬头看路–每半个小时休息一下 把预估当做承诺–只关注于25分钟 流程管理，纸上谈兵–流程跟踪，计算中断数和完成番茄数 牵着不走，打着倒退–主动去选择今天要干的事 完美主义，碍手碍脚–不用惦记着“完美方案”，只需着重于一个番茄时钟 前怕狼，后怕虎，害怕失败和批评–这是一个进程指标 番茄工作法用到的工具：&emsp;&emsp;首先介绍一下用到的工具：三张白纸，一支笔和一个计时器（不一定是番茄计时器）。 三张纸的用途分别是：1) “活动清单”（ Activity Inventory）：列出最近需要完成的任务，言简意赅即可。2) “今日待办”（ To Do Today）：从活动清单中挑选出今天需要完成的任务，并计划好 完成任务需要的番茄钟个数。3) “记录表格”（ Records）： 记录每天完成了多少个番茄钟，多少个任务等信息。 番茄工作流程的简单介绍:&emsp;&emsp;按书中的介绍，一个番茄工作者一天的流程大致分 5 个阶段：1) 计划（Plan）：从活动清单中合理挑选任务到今日待办中。2) 跟踪（Track）：确定当天活动后从第一项开始工作，开始 25 分钟的番茄钟，并记 录中断的次数（后面介绍）和过程指标。“番茄钟+短暂休息”如此循环工作下去。3) 记录（Record）：一天结束后把当天的记录都统一归档到记录表格，方便以后回顾、 反思个人工作流程。4) 处理（Process）：每隔一段时间都要从记录的数据中分析自身工作的特点，如每天 能够完成多少个番茄钟，有多少次工作时遇到了中断等等。5) 可视化（Visualize）：最终将你得到的信息以某种方式组织起来（书中用的是思维导 图），从中找出改进工作流程的方法。]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>番茄工作法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS]]></title>
    <url>%2F2018%2F11%2F25%2F2018%2F2018-11-25-dfs%2F</url>
    <content type="text"><![CDATA[1. 背包问题 问题描叙：n件物品，物重数组w[i],价值数组c[i],从中取出若干物品放入一容器为V的背包中，使总质量少于V，而背包中物品价值之和最大。求最大价值。 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;const int maxn=30;int n,V,maxValue=0;int w[maxn],c[maxn];void DFS(int index,int sumW,int sumC)&#123; //出口为index增长到n，sumW,sumC满足条件时更新maxValue后结束 if(index==n)&#123; if(sumW&lt;=V &amp;&amp; sumC&gt;maxValue) maxValue=sumC; return; &#125; DFS(index+1,sumW,sumC); DFS(index+1,sumW+w[index],sumC+c[index]);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;V); for (int i = 0; i &lt; n; ++i) scanf("%d",&amp;w[i]); for (int i = 0; i &lt; n; ++i) scanf("%d",&amp;c[i]); DFS(0,0,0); printf("%d\n",maxValue); return 0;&#125; 2. 在DFS的基础上的修改在要进入选择index时，设置进入条件。123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;const int maxn=30;int n,V,maxValue=0;int w[maxn],c[maxn];void DFS(int index,int sumW,int sumC)&#123; if(index==n) return; DFS(index+1,sumW,sumC); if(sumW+w[index]&lt;=V)&#123; if(sumC+c[index]&gt;maxValue) maxValue=sumC+c[index]; DFS(index+1,sumW+w[index],sumC+c[index]); &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;V); for (int i = 0; i &lt; n; ++i) scanf("%d",&amp;w[i]); for (int i = 0; i &lt; n; ++i) scanf("%d",&amp;c[i]); DFS(0,0,0); printf("%d\n",maxValue); return 0;&#125; 3. 延伸 枚举从n个整数中选则K个数的所有方案使其满足某种条件问题描述：n个整数，从中选择K个数，使得这k个数之和恰好等于一个给定的整数X，如果有多个方案，选择他们中平方和最大的一个。 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;vector&gt;const int maxn=10;int n,k,x,maxSumsqu=-1,A[maxn];vector&lt;int&gt; temp,ans;void DFS(int index,int nowk,int sum,int sumsqu)&#123; if(nowk==k &amp;&amp; sum==x)&#123; if(sumsqu&gt;maxSumsqu)&#123; maxSumsqu=sumsqu; ans=temp; &#125; return; &#125; if(index==n || nowk&gt;k || sum&gt;x) return; //选择index时，先要将A[index]放入temp数组中。 temp.push_back(A[index]); DFS(index+1,nowk+1,sum+A[index],sumsqu+A[index]*A[index]); temp.pop_back(); DFS(index+1,nowk,sum,sumsqu);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>DFS</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝叶斯分类器]]></title>
    <url>%2F2018%2F11%2F25%2F%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. 预备知识：先验概率与后验概率 1.1. 先验概率 定义：In Bayesian statistical inference, a prior probability distribution, often simply called the prior, of an uncertain quantity is the probability distribution that would express one’s beliefs about this quantity before some evidence is taken into account. 解释：通俗来说，对于某一个概率事件，我们都会有基于自己已有的知识，对于这个概率事件会分别以什么概率出现各种结果会有一个预先的估计，而这个估计并未考虑到任何相关因素。 1.2. 后验概率 定义： In Bayesian statistics, the posterior probability of a random event or an uncertain proposition is the conditional probability that is assigned after the relevant evidence or background is taken into account. “Posterior”, in this context, means after taking into account the relevant evidence related to the particular case being examined. 解释：在贝叶斯推断中，一个随机事件的后验概率是指：当与事件相关的一些证据或背景也被考虑进来时的条件概率。“后验”在这个语境下即指的是在考虑了与要被检验的特定事件相关的证据。 两者区别：先验概率基于已有知识对随机事件进行概率预估，但不考虑任何相关因素(P(c))。后验概率基于已有知识对随机事件进行概率预估，并考虑相关因素(P(c|x))。 2. 贝叶斯定理 定义：In probability theory and statistics, Bayes’ theorem (alternatively Bayes’ law or Bayes’ rule) describes the probability of an event, based on prior knowledge of conditions that might be related to the event. For example, if cancer is related to age, then, using Bayes’ theorem, a person’s age can be used to more accurately assess the probability that they have cancer, compared to the assessment of the probability of cancer made without knowledge of the person’s age. 解释：在概率论与统计学中，贝叶斯定理（或称贝叶斯法则、贝叶斯规则）描述了一个事件的可能性，这个可能性是基于了预先对于一些与该事件相关的情况的知识。举例来说，如果癌症和年龄有关，那么使用贝叶斯定理的话，相比根本不了解关于此人的任何其他信息，知道了它的年龄的话就可以用来更准确地帮助评估它得癌症与否的概率。 那么其实很明显了，这里的“可能性”也是考虑了与随机事件相关的因素的，所以贝叶斯定理所阐述的也就是后验概率的获得方法。 贝叶斯公式： $P(c ∣ x) = \frac {P(c) * P(x∣c)} {P(x)} = \frac {P(x,c)}{P(x)}$ c表示的是随机事件发生的一种情况。x表示的就是证据（evidence）\状况(condition)，泛指与随机事件相关的因素。 P(c|x)：在x的条件下，随机事件出现c情况的概率。（后验概率） P(c)：（不考虑相关因素）随机事件出现c情况的概率。（先验概率） P(x|c)：在已知事件出现c情况的条件下，条件x出现的概率。（后验概率） P(x)：x出现的概率。（先验概率） 3. 朴素贝叶斯分类器两个前提条件： 各个特征之间相互独立 各个特征同等重要 认为每个特征之间不存在依赖关系根据相互独立事件的概率公式可以得到朴素的贝叶斯公式 $$P(c|x) = \frac {P(x|c) P(c)} {P(x)} = P(x_1|c)P(x_2|c)…P(x_m|c)P(c) = \frac {P(c)}{P(x)}\prod_{j=1}^m P(x_j|c) $$ 这里 $x=(x_1, x_2… x_m)$， x包含多个相关因素（是一个多种因素构成的向量），即它可能有多个需要考虑的属性值。 分类原则：$$h_{nb} = argmax_{c \in y }P(c) \prod_{i=1}^m P(x_i|c)$$$h_{nb}$代表一个由naive bayesian(nb)算法训练出来的hypothesis（假设），它的值就是贝叶斯分类器对于给定x的因素下，最可能出现的情况c。y是c的取值集合。等式右边的式子就是argmax加上基于属性条件独立性假设的贝叶斯定理的分子部分（分母P(x)前面提到过，可以在计算中略去），即我们的输出值就是这样的一个c，这个c使得$P(c)\prod_{i=1}^m P(x_i)|c$的计算结果最大。 4.离散属性与连续属性值的分别处理 在估计条件概率$P(x_i∣c)$ 若$x_i$为离散值属性，那么我们只需计算每个属性取值占所有样本的数量比例就行了。$$P(x_i|c) = \frac {|{D_{c,x_i}}|}{|{D_c}|}$$$D_c$表示训练集D中第c类样本组成的集合，外加两条竖线表示的是集合的元素数量。$D_{c,x_i}$表示的是$D_c$中在第i个属性值上取值为$x_i$的样本组成的集合。 但是如果$x_i$是连续值属性，那么我们就肯定不能这样做了，而是得用概率密度函数,$$p(x_i|c) = \frac {1}{\sqrt{2\pi} \sigma_{c,i}} exp(- \frac {(x_i - \mu_{c,i})^2}{2 \sigma_{c,i}^2})$$ 5. 拉普拉斯修正(Laplacian correction)朴素贝叶斯分类器在实际使用中还需要注意的一个问题是：若某个离散类型的属性值在训练集中没有与某个类同时出现过，那么当我们使用$P(x_i|c)=\frac{|D_{c,x_i}|}{|D_c|}$对其进行估计时$P(x_i|c)$会等于0，而若某个样本只是在属性i上恰好取值为$x_i$但是它其它的属性非常符合这个类型c的特征，于是在用最后的连乘式计算该样本属于该类的概率时，不管其它的属性如何取值，就会因为$P(x_i|c)$这一个零值导致分类器认为该样本属于这个类型c的概率为0，这显然是不合理的。 这个问题本质上是由于我们的训练集不够完整，没有包括足够多的样本。但是，为了避免这个问题的出现，我们通常还是在估计概率值时，对其进行“平滑”（smoothing）操作，通常使用“拉普拉斯修正”（Laplacian correction）。 具体做法是：令N表示训练集D中可能的类别数，$N_i$表示第i个属性可能的取值数，那么我们估计类别概率值的$P(c)$和离散属性条件概率的$P(x_i∣c)$的两个式子分别被调整为： $$ \hat {P}(c) = \frac {|{D_c}| + 1}{|{D}| + N}$$$$ \hat {P}(x_i|c) = \frac {|{D_{c,x_i}}| + 1}{|{D_c}| + N_i}$$即，我们在分母上都加上取值的可能性个数，分子上都加1，这就保证了即使是存在某个属性i的取值$x_i$未曾与类别$c_i$同时出现过，我们也不会把其概率$P(x_i∣c)$算成0。 6. 应用假设我们的任务是根据一个西瓜的特征来在它被吃之前判断它是否是个好瓜。现在我们有以下数据集：现在，基于已有的数据，我们想利用朴素贝叶斯算法训练出一个分类器，以判断一个具有特征{色泽=青绿，根蒂=蜷缩，敲声=浊响，纹理=清晰，脐部=凹陷，触感=硬滑，密度=0.697，含糖率=0.460}的测试样例瓜$(x_{test})$是否为好瓜。 其次，我们计算每个属性值的条件概率$P(x_i∣c)$:对于离散属性： 对于连续属性：最后，我们计算测试瓜$(x_{test})$分别属于好瓜和坏瓜的概率：很明显，测试瓜是好瓜的概率0.038远大于测试瓜是坏瓜的概率$6.80 * 10^{-5}$于是分类器判断测试瓜为好瓜。 另外在上面的西瓜训练集中，好瓜当中暂时没有具备特征{敲声=清脆}的样本，于是对于一个“敲声=清脆”的测试例：那么，不管该测试瓜在其它属性上有多么接近好瓜，都会被直接判定为是好瓜的概率为0。使用拉普拉斯修正后，对于类别概率就有对于具备特征{敲声=清脆}的测试瓜就有：]]></content>
      <categories>
        <category>Machine Leaning</category>
      </categories>
      <tags>
        <tag>贝叶斯分类器</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实算实验4之利用队列实现二叉树的层次遍历]]></title>
    <url>%2F2018%2F11%2F22%2F%E5%AE%9E%E7%AE%97%E5%AE%9E%E9%AA%8C4%E4%B9%8B%E5%88%A9%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[实验4 利用队列实现二叉树的层次遍历（4课时） 1. 实验目的:理解队列的受限操作（在一端插入，另一端删除）以及先进先出的特性，体会队列的应用场景的特点； 能利用《程序员实用算法》的程序清单2-9和2-10中的现有函数来解决实际应用问题。 2. 实验要求:应用需求：要求实现：若键盘输入t，则对当前二叉树进行非递归的层次遍历，并打印出来。（比如，若二叉树为： 则层次遍历后，打印出的结果为“33,23,44,12,37,46”。） 问题描述：利用队列作为数据结构来实现非递归的二叉树层次遍历的函数。 算法思想： 关键：实现非递归的二叉树层次遍历的函数（函数原型为：int LevelTraBintree(Bintree *t, DoFunc df); 输入：二叉排序树t，节点的操作函数df；输出：若是空树，则返回TREE_FAIL；否则，返回TREE_OK. 3. 算法设计思路： 分别创建队列和空闲列表； 为空闲链表分配QMAX个结点； 若二叉树为空，则退出程序； 将二叉树根节点入队； 重复执行下列操作，直至队列为空。 1）将队头节点出队并打印出其值； 2）若出队节点有左子树，则将该节点的左孩子入队； 3）若出队节点有右子树，则将该节点的右孩子入队； 返回成功，程序退出。 4. 代码与分析4.1.1 头文件qapp.h：队列节点的定义与创建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*--- qapp.h ------------------------------ Listing 2-9 -------- * Application-specific data items for linked-list queues. *-------------------------------------------------------------*/#ifndef QAPP_H#define QAPP_H 1/* * Our first list's nodes consist of a pointer to * text and a priority level. */#define TEXT_SIZE 20 /* the maximum size of our text string */extern int DataCopy ( void *, void * );/* * The data and functions for the queue */struct NodeData1 &#123; struct NodeData1 *link[2]; char text[20];&#125;;typedef struct NodeData1 * pND1;extern void * CreateData1 ( void * );extern int DeleteData1 ( void * );extern int DuplicatedNode1 ( Link, Link );extern int NodeDataCmp1 ( void *, void * );/* * The free list has identical nodes */struct NodeData2 &#123; struct NodeData2 *link[2]; char text[20];&#125;;typedef struct NodeData2 * pND2;extern void * CreateData2 ( void * );extern int DeleteData2 ( void * );extern int DuplicatedNode2 ( Link, Link );extern int NodeDataCmp2 ( void *, void * );#endif 4.1.2 接口qapp.c：队列函数的具体定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/*--- qapp.c ------------------------------ Listing 2-10 -------- * Application-specific functions for queue examples. * Replace these routines with your own. *-------------------------------------------------------------*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; /* for free() */#include &lt;string.h&gt; /* for strcmp() and strdup() */#include "llgen.h"#include "qapp.h"/*=== linked-list functions for queue ===*//* * our nodes come from the free list, * so this function is never called. */void * CreateData1 ( void * data )&#123; return ( NULL );&#125;int DeleteData1 ( void * data )&#123; /* * In this case, NodeData1 consists of a pointer and an int. * The integer will be returned to memory when the node * is freed. However, the string must be freed manually. */ //free ( ((pND1) data)-&gt;text );//yyw return ( 1 );&#125;/*--------------------------------------------------------------- * This function determines what to do when inserting a node * into a list if an existing node with the same data is found * in the list. In this case, since we are counting words, if a * duplicate word is found, we simply increment the counter. * * Note this function should return one of the following values: * 0 an error occurred * 1 delete the duplicate node * 2 insert the duplicate node * Any other processing on the duplicate should be done in this * function. *-------------------------------------------------------------*/int DuplicatedNode1 ( Link new_node, Link list_node )&#123; return 2;&#125;/* compare only the priority of the queue data */int NodeDataCmp1 ( void *first, void *second )&#123; return (0);&#125;/*=== Now the functions for the list of free nodes ===*//* data is a priority level (int) and text (string) */void * CreateData2 ( void * data )&#123; struct NodeData2 * new_data; /*--- allocate our data structure ---*/ new_data = (struct NodeData2 *)malloc ( sizeof ( struct NodeData2 )); if ( new_data == NULL ) return ( NULL ); /*--- move the values into the data structure ---*/ /* * we assign a priority of 0 * and allocate a string of TEXT_SIZE + 1 */ new_data-&gt;link[0]=NULL; new_data-&gt;link[1]=NULL; //new_data-&gt;text == (char *)malloc (TEXT_SIZE+1);//yyw if ( new_data-&gt;text == NULL ) /* error copying string */ &#123; free ( new_data ); return ( NULL ); &#125; else return ( new_data ); /* return a complete structure */&#125;int DeleteData2 ( void * data )&#123; /* * In this case, NodeData2 consists of a pointer. * The string must be freed manually. */ //free ( ((pND2) data)-&gt;text ); return ( 1 );&#125;/* this list inserts duplicated nodes */int DuplicatedNode2 ( Link new_node, Link list_node )&#123; return 2;&#125;/* this function is never called */int NodeDataCmp2 ( void *first, void *second )&#123; return ( 0 );&#125;/* function to copy our data */int DataCopy ( void * dest, void * src )&#123; pND2 s,d; s = src; d = dest; if ( dest == NULL || src == NULL ) return ( 0 ); /*printf ( "About to copy %s \n", s-&gt;text );*/ strncpy ( d-&gt;text, s-&gt;text, TEXT_SIZE ); d-&gt;link[0]=s-&gt;link[0]; d-&gt;link[1]=s-&gt;link[1]; return ( 1 );&#125; 4.2.1 头文件llgen.h:链表的声明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*--- llgen.h ----------------------------- Listing 2-2 --------- * Declarations for generic doubly linked lists. * Used in conjunction with llgen.c (Listing 2-3). *-------------------------------------------------------------*/#ifndef LLGEN_H /* make sure it's included only once */#define LLGEN_H 1struct Node &#123; struct Node *prev; /* link to previous node */ struct Node *next; /* link to next node */ void *pdata; /* generic pointer to data */&#125;;typedef struct Node *Link;/* a linked list data structure */struct List &#123; Link LHead; Link LTail; unsigned int LCount; void * ( * LCreateData ) ( void * ); int ( * LDeleteData ) ( void * ); int ( * LDuplicatedNode ) ( Link, Link ); int ( * LNodeDataCmp ) ( void *, void * );&#125;;/* The four functions specific to an individual linked list are: LCreateData: is passed a pointer to an application-defined object and is expected to return a pointer to whatever is to be stored in the linked list. LDeleteData: is passed a pointer to the object an application has stored in a linked list. LDeleteData must destroy the object. LDuplicatedNode: is passed two pointers. The first pointer is to a node that you would like to add to a linked list and the second is to a node that is already in the list but is a duplicate of the first pointer. LDuplicatedNode returns: 0 -&gt; do nothing to list 1 -&gt; destroy duplicate 2 -&gt; add duplicate to list LNodeDataCmp: is passed pointers to two application data objects and must compare them, returning a number that is &lt; 0, zero, or &gt; 0, depending on the relationship between the first and second objects.*//*--- generic linked-list primitives ---*/int AddNodeAscend ( struct List *, void * );int AddNodeAtHead ( struct List *, void * );struct List * CreateLList ( void * ( * ) ( void * ), /* create data */ int ( * ) ( void * ), /* delete data */ int ( * ) ( Link, Link ), /* duplicate */ int ( * ) ( void *, void * )); /* compare */Link CreateNode ( struct List * , void * );int DeleteNode ( struct List *, Link );Link FindNode ( struct List *, void * );Link FindNodeAscend ( struct List *, void * );Link GotoNext ( struct List *, Link );Link GotoPrev ( struct List *, Link );#endif 4.2.2 接口llgen.c：链表函数的具体定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283/*--- llgen.c ------------------------------ Listing 2-3 -------- * Generic primitive functions for doubly linked lists. * Contains no application-specific functions. * Functions are in alphabetical order. *------------------------------------------------------------*/#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define IN_LL_LIB 1 /* in the library of primitives */#include "llgen.h"/*--- Aliases to make the code more readable ---*/#define LLHead (L-&gt;LHead) /* The head of the current list */#define LLTail (L-&gt;LTail) /* The tail of the current list */#define NodeCount (L-&gt;LCount) /* Nodes in the current list */#define CreateData (*(L-&gt;LCreateData))#define DeleteData (*(L-&gt;LDeleteData))#define DuplicatedNode (*(L-&gt;LDuplicatedNode))#define NodeDataCmp (*(L-&gt;LNodeDataCmp))/*---------------------------------------------------- * Add a node at head: first allocate the space for * the data, then allocate a node with a pointer to * the data, then add the node to the list. *--------------------------------------------------*/int AddNodeAtHead ( struct List *L, void *nd )&#123; Link pn; pn = CreateNode ( L, nd ); if ( pn == NULL ) return ( 0 ); /*--- Add the node ---*/ if ( LLHead == NULL ) /* is it the first node? */ &#123; LLHead = LLTail = pn; /*--- yes ---*/ &#125; else /*--- no ---*/ &#123; LLHead-&gt;prev = pn; /* first goes node before Head */ pn-&gt;next = LLHead; /* put Head next */ LLHead = pn; /* then point Head to us */ &#125; NodeCount += 1; return ( 1 );&#125;/*---------------------------------------------------- * Add ascending. Adds a node to an ordered list. *--------------------------------------------------*/int AddNodeAscend ( struct List *L, void *nd )&#123; Link pn; /* to node we're creating */ Link prev, curr; /* our current search */ struct Node dummy; /* a dummy node */ int compare; pn = CreateNode ( L, nd ); if ( pn == NULL ) return ( 0 ); /* attach dummy node to head of list */ dummy.next = LLHead; dummy.prev = NULL; if ( dummy.next != NULL ) dummy.next-&gt;prev = &amp;dummy; prev = &amp;dummy; curr = dummy.next; for ( ; curr != NULL; prev = curr, curr = curr-&gt;next ) &#123; compare = NodeDataCmp ( pn-&gt;pdata, curr-&gt;pdata ); if ( compare &lt;= 0 ) break; /* new node equals or precedes curr */ &#125; if ( curr != NULL &amp;&amp; compare == 0 ) &#123; compare = DuplicatedNode ( pn, curr ); if ( compare == 2 ) /* do nothing -- will get inserted */; else &#123; /* first, repair the linked list */ LLHead = dummy.next; LLHead-&gt;prev = NULL; /* delete the duplicated node, if appropriate */ if ( compare == 1 ) &#123; DeleteData( pn-&gt;pdata ); free ( pn ); &#125; return ( 1 ); &#125; &#125; prev-&gt;next = pn; pn-&gt;prev = prev; pn-&gt;next = curr; if ( curr != NULL ) curr-&gt;prev = pn; else LLTail = pn; /* this node is the new tail */ NodeCount += 1; /* now, unhook the dummy head node */ LLHead = dummy.next; LLHead-&gt;prev = NULL; return ( 1 );&#125;/*--------------------------------------------------------------- * Creates a linked-list structure and returns a pointer to it. * On error, returns NULL. This functions accepts pointers * to the four list-specific functions and initializes the * linked-list structure with them. *-------------------------------------------------------------*/struct List * CreateLList ( void * ( * fCreateData ) ( void * ), int ( * fDeleteData ) ( void * ), int ( * fDuplicatedNode ) ( Link, Link ), int ( * fNodeDataCmp ) ( void *, void * ))&#123; struct List * pL; pL = (struct List *) malloc ( sizeof ( struct List )); if ( pL == NULL ) return NULL; pL-&gt;LHead = NULL; pL-&gt;LTail = NULL; pL-&gt;LCount = 0; pL-&gt;LCreateData = fCreateData; pL-&gt;LDeleteData = fDeleteData; pL-&gt;LDuplicatedNode = fDuplicatedNode; pL-&gt;LNodeDataCmp = fNodeDataCmp; return ( pL );&#125;/*--------------------------------------------------------------- * Creates a node and then calls the application-specific * function CreateData() to create the node's data structure. * Returns NULL on error. *-------------------------------------------------------------*/Link CreateNode ( struct List *L, void *data )&#123; Link new_node; new_node = (Link) malloc ( sizeof ( struct Node )); if ( new_node == NULL ) return ( NULL ); new_node-&gt;prev = NULL; new_node-&gt;next = NULL; /*--- now call the application-specific data allocation ---*/ new_node-&gt;pdata = CreateData( data ); if ( new_node-&gt;pdata == NULL ) &#123; free ( new_node ); return ( NULL ); &#125; else return ( new_node );&#125;/*--------------------------------------------------------------- * Deletes the node pointed to by to_delete. * Function calls list-specific function to delete data. *-------------------------------------------------------------*/int DeleteNode ( struct List *L, Link to_delete )&#123; Link pn; if ( to_delete == NULL ) /* Double check before */ return ( 0 ); /* deleting anything. */ if ( to_delete-&gt;prev == NULL ) /* we're at the head */ &#123; LLHead = to_delete-&gt;next; /* update head */ LLHead-&gt;prev = NULL; /* update next node??? */ &#125; else if ( to_delete-&gt;next == NULL ) &#123; /* we're at the tail */ pn = to_delete-&gt;prev; /* get the previous node */ pn-&gt;next = NULL; //??? LLTail = pn; /* update tail */ &#125; else /* we're in the list */ &#123; pn = to_delete-&gt;prev; /* get the previous node */ pn-&gt;next = to_delete-&gt;next; /* update previous node to */ /* point to the next one. */ pn = to_delete-&gt;next; /* get the next node */ pn-&gt;prev = to_delete-&gt;prev; /* update it to point to */ /* the previous one. */ &#125; DeleteData ( to_delete-&gt;pdata ); /* delete the data */ free ( to_delete ); /* free the node */ NodeCount -= 1; return ( 1 );&#125;/*--------------------------------------------------------------- * Finds node by starting at the head of the list, stepping * through each node, and comparing data items with the search * key. The Ascend version checks that the data in the node * being examined is not larger than the search key. If it is, * we know the key is not in the list. Returns pointer to node * on success or NULL on failure. *-------------------------------------------------------------*/Link FindNode ( struct List *L, void *nd )&#123; Link pcurr; /* the node we're examining */ if ( LLHead == NULL ) /* empty list */ return ( NULL ); for ( pcurr = LLHead; pcurr != NULL; pcurr = pcurr-&gt;next) &#123; if ( NodeDataCmp ( nd, pcurr-&gt;pdata ) == 0 ) return ( pcurr ); &#125; return ( NULL ); /* could not find node */&#125;Link FindNodeAscend ( struct List *L, void *nd )&#123; Link pcurr; /* the node we're examining */ int cmp_result; if ( LLHead == NULL ) /* empty list */ return ( NULL ); for ( pcurr = LLHead; pcurr != NULL; pcurr = pcurr-&gt;next) &#123; cmp_result = NodeDataCmp ( nd, pcurr-&gt;pdata ); if ( cmp_result &lt; 0 ) return ( NULL ); /* too far */ if ( cmp_result == 0 ) /* just right */ return ( pcurr ); &#125; return ( NULL ); /* could not find node */&#125;/*--------------------------------------------------------------- * The Goto functions return the pointer to the requested node * or NULL on error. *-------------------------------------------------------------*/Link GotoNext ( struct List *L, Link pcurr )&#123; if ( pcurr-&gt;next == NULL || pcurr == LLTail ) return ( NULL ); else return ( pcurr-&gt;next );&#125;Link GotoPrev ( struct List *L, Link pcurr )&#123; if ( pcurr-&gt;prev == NULL || pcurr == LLHead ) return ( NULL ); else return ( pcurr-&gt;prev );&#125; 4.3.1 头文件bintree.h：二叉树定义123456789101112131415161718192021222324252627282930313233343536373839404142/*--- bintree.h --------------------------- Listing 6-2 --------- * Binary-tree definitions * *-------------------------------------------------------------*/#define TREE_OK (0)#define TREE_FAIL (-1)#define LEFT 1#define RIGHT 0typedef struct sBnode &#123; struct sBnode *link[2];&#125; Bnode;/* Our binary tree is made up of these */typedef struct sMynode &#123; /* A copy of the items in a Bnode */ struct sMynode *link[2]; char text[20];&#125; Mynode;/* Control structure for a binary tree */typedef int (*CompFunc) (void *node1, void *node2);typedef int (*DoFunc) (void *node, int level);typedef struct sBintree &#123; Bnode *DummyHead; CompFunc Compare; int DuplicatesOk; size_t NodeSize;&#125; Bintree;/* Prototypes */Bintree *NewBintree (Bnode *dummy, CompFunc cf, int dup_ok, size_t node_size);Bnode *FindBintree(Bintree *t, Bnode *n);int InsBintree (Bintree *t, Bnode *n);Bnode *DelBintree (Bintree *t, Bnode *n);int WalkBintree(Bintree *t, DoFunc df);Bnode *InitBintreeNode(size_t size);int LevelTraBintree(Bintree *t, DoFunc df); 4.3.2 bintree.c：二叉树主要功能定义和问题算法思路的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713/*--- bintree.c --------------------------- Listing 6-1 --------- * Binary tree routines. Provides plain binary search * *-------------------------------------------------------------*/#define TEST#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include "bintree.h"#include "llgen.h"#include "qapp.h"#define QMAX 100 /* maximum number of elements in a queue */ //yyw/* A safe malloc() */static void * tmalloc(size_t size)&#123; void *p; if ((p = malloc(size)) == NULL) &#123; printf("Out of memory\n"); exit(1); &#125; return p;&#125;/* * Create and initialize a node for the user. 'size' both can * and should be greater than sizeof(Bnode) to allow for a * data area for the user. */Bnode *InitBintreeNode(size_t size)&#123; Bnode *n; n = tmalloc(size); n -&gt; link[LEFT] = n -&gt; link[RIGHT] = NULL; return n;&#125;/* Create an empty tree */Bintree *NewBintree (Bnode *dummy, CompFunc cf, int dup_ok, size_t node_size)&#123; Bintree *t; t = tmalloc(sizeof(Bintree)); t -&gt; DummyHead = dummy; t -&gt; Compare = cf; t -&gt; DuplicatesOk = dup_ok; t -&gt; NodeSize = node_size; return t;&#125;/* Find node n in tree t */Bnode *FindBintree(Bintree *t, Bnode *n)&#123; Bnode *s; int dir; s = t -&gt; DummyHead -&gt; link[RIGHT]; while (s != NULL) &#123; dir = (t -&gt; Compare) (n, s); /* * If a match, we're done. * For Red-Black, must also be a leaf. */ if (dir == 0 ) return s; dir = dir &lt; 0; s = s -&gt; link[dir]; &#125; return NULL; /* no match */&#125;Bnode * DelBintree (Bintree *t, Bnode *n)&#123; Bnode *p, *s, *save; int dir, dir_old; p = t -&gt; DummyHead; s = p -&gt; link[RIGHT]; dir_old = dir = RIGHT; /* Look for a match */ while (s != NULL &amp;&amp; (dir = (t-&gt;Compare)(n, s)) != 0) &#123; p = s; dir = dir &lt; 0; dir_old = dir; s = p -&gt; link[dir]; &#125; if (s == NULL) return NULL; /* no match found */ save = s; /* * First case: if s has no right child, then replace s * with s's left child. */ if (s -&gt; link[RIGHT] == NULL) s = s -&gt; link[LEFT]; /* * Second case: if s has a right child that lacks a left * child, then replace s with s's right child and * copy s's left child into the right child's left child. */ else if (s -&gt; link[RIGHT] -&gt; link[LEFT] == NULL) &#123; s = s -&gt; link[RIGHT]; s -&gt; link[LEFT] = save -&gt; link[LEFT]; &#125; /* * Final case: find leftmost (smallest) node in s's right * subtree. By definition, this node has an empty left * link. Free this node by copying its right link to * its parent's left link and then give it both of s's * links (thus replacing s). */ else &#123; Bnode *small; small = s -&gt; link[RIGHT]; while (small -&gt; link[LEFT] -&gt; link[LEFT]) small = small -&gt; link[LEFT]; s = small -&gt; link[LEFT]; small -&gt; link[LEFT] = s -&gt; link[RIGHT]; s -&gt; link[LEFT] = save -&gt; link[LEFT]; s -&gt; link[RIGHT] = save -&gt; link[RIGHT]; &#125; p -&gt; link[dir_old] = s; return save;&#125;/* Insert node n into tree t */int InsBintree (Bintree *t, Bnode *n)&#123; int p_dir; Bnode *p, *s; /* Search until we find an empty arm. */ p = t -&gt; DummyHead; p_dir = RIGHT; /* direction from p to s */ s = p -&gt; link[RIGHT]; while (s != NULL) &#123; p = s; p_dir = (t -&gt; Compare) (n, s); if (p_dir == 0 &amp;&amp; t -&gt; DuplicatesOk == 0) return TREE_FAIL; /* duplicate */ p_dir = p_dir &lt; 0; //printf(" Compare with '%s'.", ((struct sMynode *)s) -&gt; text); s = s -&gt; link[p_dir]; &#125; /* Add the new node */ p -&gt; link[p_dir] = n; //printf("\n"); return TREE_OK;&#125;/* * Recursive tree walk routines. The entry point is * WalkBintree. It will do an inorder traversal of the * tree, call df() for each node and leaf. */void rWalk(Bnode *n, int level, DoFunc df)&#123; if (n != NULL) &#123; rWalk(n -&gt; link[LEFT], level + 1, df); df(n, level); rWalk(n -&gt; link[RIGHT], level + 1, df); &#125;&#125;int WalkBintree(Bintree *t, DoFunc df)&#123; if (t -&gt; DummyHead -&gt; link[RIGHT] == NULL) &#123; fputs("Empty tree\n", stdout); return TREE_FAIL; &#125; rWalk(t -&gt; DummyHead -&gt; link[RIGHT], 0, df); return TREE_OK;&#125;#if defined(TEST)/* * Test driver */#define BUFLEN 100int LoadString(Bintree *t, char *string)&#123; Mynode *m; m = (Mynode *) InitBintreeNode(sizeof(Mynode)); strncpy(m-&gt;text, string, sizeof(m-&gt;text)); m-&gt;text[sizeof(m-&gt;text) - 1] = 0; return InsBintree(t, (Bnode *) m);&#125;void FindString(Bintree *t, char *string)&#123; Mynode m, *r; strncpy(m.text, string, sizeof(m.text)); m.text[sizeof(m.text) - 1] = 0; if ((r = (Mynode *) FindBintree(t, (Bnode *) &amp;m)) == NULL) puts(" Not found.\n"); else printf(" Found '%s'.\n", r -&gt; text);&#125;void DeleteString(Bintree *t, char *string)&#123; Mynode m, *n; strncpy(m.text, string, sizeof(m.text)); m.text[sizeof(m.text) - 1] = 0; n = (Mynode *) DelBintree(t, (Bnode *) &amp;m); if (n) free (n); else fprintf(stdout, " Did not find '%s'.\n", string);&#125;void LoadFile(Bintree *t, char *fname)&#123; FILE *infile; char buffer[BUFLEN], *s; int i = 0, j = 0; if ((infile = fopen(fname, "r")) == NULL) &#123; fputs(" Couldn't open the file.\n", stdout); return; &#125; while (fgets(buffer, BUFLEN, infile)) &#123; s = buffer + strlen(buffer); while(iscntrl(*s)) *s-- = 0; if (buffer[0] == ';') /* a comment */ ; else if (buffer[0] == '-' &amp;&amp; buffer[1] != 0) &#123; DeleteString(t, buffer+1); j++; &#125; else &#123; LoadString(t, buffer); i++; &#125; &#125; fclose(infile); printf("Loaded %d items and deleted %d from %s.\n", i, j, fname);&#125;/* * A sample action function: it prints out the data * at each node along with the node's level in the tree */int ShowFunc(void *m, int level)&#123; fprintf(stdout, "%s (%d)\n", ((Mynode *)m) -&gt; text, level); return TREE_OK;&#125;/* * A pair of functions to print the tree as a diagram. */#if !defined(ALTDRAW) #define TOP '+' //yyw #define BOT '+' //yyw #define HOR '-' //yyw #define VRT '|' //yyw //#define TOP '? //#define BOT '? //#define HOR '? //#define VRT '?#else #define TOP '/' #define BOT '\\' #define HOR '-' #define VRT '|'#endif#define DRAWBUF 100char draw[DRAWBUF];char work[DRAWBUF * 2];int maxdepth;FILE *outfile;void xrWalk(Bnode *n, int level)&#123; int i; if (n != NULL) &#123; /* Monitor */ if (level &gt; maxdepth) maxdepth = level; /* * Go right */ draw[level * 2] = TOP; draw[level * 2 + 1] = ' '; xrWalk(n -&gt; link[RIGHT], level + 1); /* * Show current node */ strncpy(work, draw, level * 2); if (level &gt; 0) &#123; int c; c = work[0]; for (i = 2; i &lt; level * 2; i += 2) if (work[i] == c) work[i - 2] = ' '; else c = work[i]; work[level * 2 - 1] = HOR; for (i = 0; i &lt; level * 2 - 2; i += 2) if (work[i] != ' ') &#123; work[i] = VRT; &#125; &#125; sprintf(work + level * 2, "%s (%d)", ((Mynode *)n)-&gt;text, level); fputs(work, outfile); fputs("\n", outfile); /* * Go left */ draw[level * 2] = BOT; draw[level * 2 + 1] = ' '; xrWalk(n -&gt; link[LEFT], level + 1); &#125;&#125;int xWalkBintree(Bintree *t, char *name, char *mode)&#123; if (t -&gt; DummyHead -&gt; link[RIGHT] == NULL) &#123; fputs("Empty tree\n", stdout); return TREE_FAIL; &#125; maxdepth = -1; outfile = stdout; if (name) &#123; outfile = fopen(name, mode); if (outfile == NULL) &#123; fprintf(stdout, "Can't open %s.\n", name); name = NULL; outfile = stdout; &#125; &#125; xrWalk(t -&gt; DummyHead -&gt; link[RIGHT], 0); fprintf(outfile, "Max depth %d.\n", maxdepth); if (name) fclose(outfile); /* a real file */ else fflush(outfile); /* stdout */ return TREE_OK;&#125;int compare_length = 0;int CompareFunc(void *n1, void *n2)&#123; if (compare_length) return strncmp(((Mynode *)n1)-&gt;text, ((Mynode *)n2)-&gt;text, compare_length); else return strcmp(((Mynode *)n1)-&gt;text, ((Mynode *)n2)-&gt;text);&#125;/*--------------------------------------------------------------- * enqueue loads the data items in entry into the head node of * the free list, then adds that node to the queue based on * priority. *-------------------------------------------------------------*/int enqueue ( struct List *lqueue, struct List *lfree, void *new_entry )&#123; Link curr, new_node; /* Are there any free nodes left? */ if ( lfree-&gt;LCount == 0 ) &#123; fprintf ( stderr, "Exceeded maximum queue size\n" ); return ( 0 ); &#125; /* load the data into the head of the free list */ new_node = lfree-&gt;LHead; if ( DataCopy ( new_node-&gt;pdata, new_entry ) == 0 ) return ( 0 ); lfree-&gt;LHead = lfree-&gt;LHead-&gt;next; /* adding to an empty list? */ if ( lqueue-&gt;LCount == 0 ) &#123; new_node-&gt;prev = NULL; new_node-&gt;next = NULL; lqueue-&gt;LTail = new_node; lqueue-&gt;LHead = new_node; lqueue-&gt;LCount = 1; lfree-&gt;LCount -= 1; &#125; /* Traverse the list to find the insertion position */ else &#123; new_node-&gt;prev = lqueue-&gt;LTail; new_node-&gt;next = NULL; new_node-&gt;prev-&gt;next = new_node; lqueue-&gt;LTail = new_node; lqueue-&gt;LCount += 1; /* update the free list */ lfree-&gt;LCount -= 1; &#125; return ( 1 );&#125;/*--------------------------------------------------------------- * dequeue takes a pointer that will be set to the data in the * node at the head of the queue. It then moves the node being * dequeued from the queue to the free list. Note that if you do * not use the dequeued data before next queue operation, the * data is lost, so copy it if you need to. Returns 0 on error. *-------------------------------------------------------------*/int dequeue ( struct List *lqueue, struct List *lfree, void * our_data )&#123; Link dequeued_link; /* is there anything to dequeue? */ if ( lqueue-&gt;LCount == 0 ) &#123; fprintf ( stderr, "Error dequeue from empty queue\n" ); return ( 0 ); &#125; /* make a copy of the data being dequeued */ if ( DataCopy ( our_data, lqueue-&gt;LHead-&gt;pdata ) == 0 ) return ( 0 ); /* remove the node from the queue */ dequeued_link = lqueue-&gt;LHead; lqueue-&gt;LHead = lqueue-&gt;LHead-&gt;next; lqueue-&gt;LCount -= 1; /* add the node to the free list */ dequeued_link-&gt;prev = NULL; dequeued_link-&gt;next = lfree-&gt;LHead; lfree-&gt;LHead = dequeued_link; lfree-&gt;LCount += 1; return ( 1 );&#125;int LevelTraBintree(Bintree *t, DoFunc df)&#123; // 层序遍历 int count; void *temp;/* temporary data area*/ struct List *queue, *free_list; /* our two queues */ int level=0; Mynode * PCurrTnode;//指向当前要操作的节点 /*--- set up linked-list data structures for queues ---*/ queue = CreateLList ( CreateData1, /* in qapp.c */ DeleteData1, /* " */ DuplicatedNode1, /* " */ NodeDataCmp1 ); /* " */ free_list = CreateLList ( CreateData2, /* in qapp.c */ DeleteData2, /* " */ DuplicatedNode2, /* " */ NodeDataCmp2 ); /* " */ if ( queue == NULL || free_list == NULL ) //要求queue,free_list 指向非空 &#123; fprintf ( stderr, "Error creating queue\n" ); exit ( EXIT_FAILURE ); &#125; /*--- allocate the free list ---*/ for ( count = 0; count &lt; QMAX; count++ ) // 向free_list中填充所需节点 &#123; if ( ! AddNodeAtHead ( free_list, PCurrTnode )) &#123; fprintf ( stderr, "Could not create queue of %d\n", QMAX ); exit ( EXIT_FAILURE ); &#125; &#125; /*--- begin processing file ---*/ if (t -&gt; DummyHead -&gt; link[RIGHT] == NULL) &#123; // 要求树非空 fputs("Empty tree\n", stdout); return TREE_FAIL; &#125; PCurrTnode = CreateData2 ( NULL ); if ( PCurrTnode == NULL ) // PCurrTnode 创建失败处理 &#123; fprintf ( stderr, "Error creating temporary data area\n" ); exit ( EXIT_FAILURE ); &#125; if ( DataCopy ( PCurrTnode, t -&gt; DummyHead -&gt; link[RIGHT] ) == 0 ) // 树头节点值赋给PCurrTnode return ( 0 ); if ( enqueue ( queue, free_list, PCurrTnode ) == 0 )//将树的根节点入队 &#123; printf ( "Error enqueueing %s\n", ((pND2)PCurrTnode)-&gt;text ); exit ( EXIT_FAILURE ); &#125; else printf ( "Enqueued %s\n", ((pND2)PCurrTnode)-&gt;text ); while ( queue-&gt;LCount &gt; 0 ) //队非空时循环操作，队空结束循环 &#123; if ( dequeue ( queue, free_list, PCurrTnode ) == 0 ) // 队首元素出队，即PCurrTnode所指向的元素 &#123; printf ( "Error dequeueing %s\n", ((pND2)PCurrTnode)-&gt;text ); return ( EXIT_FAILURE ); &#125; else printf ( "Dequeued %s\n", ((pND2)PCurrTnode)-&gt;text ); df(PCurrTnode, level++); if (PCurrTnode -&gt; link[LEFT] != NULL) if ( enqueue ( queue, free_list, PCurrTnode -&gt; link[LEFT] ) == 0 )//将PCurrTnode所指节点的左孩子入队 &#123; printf ( "Error enqueueing %s\n", ((pND2)PCurrTnode -&gt; link[LEFT])-&gt;text ); exit ( EXIT_FAILURE ); &#125; else printf ( "Enqueued %s\n", ((pND2)PCurrTnode -&gt; link[LEFT])-&gt;text ); if (PCurrTnode -&gt; link[RIGHT] !=NULL) if ( enqueue ( queue, free_list, PCurrTnode -&gt; link[RIGHT] ) == 0 )//将PCurrTnode所指节点的右孩子入队 &#123; printf ( "Error enqueueing %s\n", ((pND2)PCurrTnode -&gt; link[RIGHT])-&gt;text ); exit ( EXIT_FAILURE ); &#125; else printf ( "Enqueued %s\n", ((pND2)PCurrTnode -&gt; link[RIGHT])-&gt;text ); &#125; return TREE_OK;&#125;main(int argc, char **argv)&#123; char inbuf[BUFLEN], *s; Bintree *tree; Mynode *dummy; /* create a dummy node for the tree algorithms */ dummy = (Mynode *) InitBintreeNode(sizeof(Mynode)); dummy-&gt;text[0] = 0; /* must contain valid data */ /* create a tree */ tree = NewBintree((Bnode *) dummy, CompareFunc, 1, sizeof(Mynode)); for (;;) &#123; fputs("Action (? for help): ", stdout); fflush(stdout); fgets(inbuf, BUFLEN, stdin); s = inbuf + strlen(inbuf); while(iscntrl(*s)) *s-- = 0; switch (inbuf[0]) &#123; case '?': fputs( "@file - Load strings in file to tree\n" "d string - Delete string from tree\n" "dup [0|1] - Disallow/allow duplicates\n" "s [file] - Display tree (overwrite file)\n" "w - Walk tree, running ShowFunc()\n" "t - travel tree by level, running ShowFunc()\n" "q - Quit\n" , stdout); fflush(stdout); break; case '@': LoadFile(tree, inbuf + 1); break; case 'd': if (inbuf[1] == 'u' &amp;&amp; inbuf[2] == 'p') &#123; if (inbuf[3] == ' ' &amp;&amp; (inbuf[4] == '0' || inbuf[4] == '1')) tree -&gt; DuplicatesOk = inbuf[4] == '0' ? 0 : 1; fputs("Duplicates are ", stdout); if (tree -&gt; DuplicatesOk == 0) fputs("not ", stdout); fputs("allowed.\n", stdout); break; &#125; if (inbuf[1] != ' ' || inbuf[2] == 0) fputs(" Not a valid command\n", stdout); else DeleteString(tree, inbuf + 2); break; case 's': if (inbuf[1] == ' ' &amp;&amp; inbuf[2] != 0) xWalkBintree(tree, inbuf + 2, inbuf[0] == 's' ? "w" : "a"); else xWalkBintree(tree, NULL, NULL); break; case 'w': WalkBintree(tree, ShowFunc); break; case 't': LevelTraBintree(tree, ShowFunc); break; case 'q': return; case ';': break; /* comment */ default: fputs(" Not a valid command\n", stdout); break; &#125; &#125;&#125;#endif 5. 测试5.1 若键盘依次输入3个命令“@Lab4.DAT”、“s”和“t”，则程序运行结果为： 5.2 若键盘依次输入3个命令：“d 12”、“s”和“t”，则程序运行结果: 5.3 若键盘依次输入3个命令：“d 20”、“s”和“t”，则程序运行结果： 附件：文件Lab4.DAT内容如下：1234567891020102212150608012500]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>queue</tag>
        <tag>layer travel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFS之迷宫最小步数]]></title>
    <url>%2F2018%2F11%2F21%2F2018%2F2018-11-21-%E8%BF%B7%E5%AE%AB%E6%9C%80%E5%B0%8F%E6%AD%A5%E6%95%B0%2F</url>
    <content type="text"><![CDATA[问题：给定一个n*m大小迷宫，@代表不可通过墙壁，.代表平地，S起点，T终点。 12345......*.*..*S*..***....T* 代码与解析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 100;struct node&#123; int x, y; int step;&#125;S, T, Node;int n, m;char maze[maxn][maxn]; //迷宫信息bool inq[maxn][maxn] = &#123;false&#125;; //记录是否入过队int X[] = &#123;0, 0, -1, 1&#125;;//用X，Y数组来来表示上下左右移动大小int Y[] = &#123;-1, 1, 0, 0&#125;;//测试（x, y）是否有效bool test(int x, int y)&#123; if(x &gt;= n || x &lt; 0 || y &gt;= m || y &gt; 0) return false; if(inq[x][y] == true) return false; if(maze[x][y] == '*') return false; return true;&#125;//BFS算法int BFS()&#123; queue&lt;node&gt; q; q.push(S); while(!q.empty())&#123; node top = q.front(); q.pop(); if(top.x == T.x &amp;&amp; top.y == T.y) return top.step; for (int i = 0; i &lt; 4; ++i) &#123; int newX = top.x + X[i]; int newY = top.y + Y[i]; if(test(newX, newY))&#123; Node.x = newX; Node.y = newY; Node.step = top.step + 1; q.push(Node); inq[newX][newY] = true; &#125; &#125; &#125; return -1;&#125;int main(int argc, char const *argv[])&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) &#123; getchar(); for (int j = 0; j &lt; m; ++j) &#123; maze[i][j] = getchar(); &#125; maze[i][m+1] = '\0'; &#125; scanf("%d%d%d%d", &amp;S.x, &amp;S.y, &amp;T.x, &amp;T.y); S.step = 0; printf("The layer: %d\n", BFS()); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blockchain3]]></title>
    <url>%2F2018%2F11%2F18%2F2018-11-17-Blockchain3%2F</url>
    <content type="text"><![CDATA[区块链三：区块链考试复习 &emsp;&emsp;感觉老是转载没啥意思，以后区块链不怎么更新了。大家如果对区块链技术感兴趣可以看一下咱们燕姐的知乎。&emsp;&emsp;另外我再推荐几个网站： 人人都懂区块链： http://www.readblocks.com/以太坊：https://ethfans.org/区块链兄弟：http://www.blockchainbrother.com/巨推链: https://www.jutuilian.com/ 区块链复习 燕姐所给复习内容： &emsp;&emsp;区块链技术提供了一种交易记录和执行的新的形式，具有去中心化、不可篡改和抵赖等优秀的性质，在金融和公共事务方面有着巨大的潜力应用。目前为止，区块链最成功的应用仍然是比特币，因此，课程中，我们主要以比特币为例子来讲解区块链。主要介绍了区块链中最基本和最重要的概念：分布式记账、共识机制、区块（Merkle树）、脚本等。在延伸介绍区块链2.0以太坊时，涉及了以太坊上智能合约的编写，以及区块链安全。最后，提及区块链3.0，讨论了PoW、PoS和DPoS的特点和区别。&emsp;&emsp;首先，我们讨论了数字货币的概念，通过回顾人类史上货币的发展历程，讨论货币的特点，它可以不具有实体、本质特征是账本上记录的交易。为了让金融系统公开、公正、不可篡改，需要一个分布式的具有不可篡改的记账系统。&emsp;&emsp;在这样的分布式记账系统的发展过程中，出现了很多优秀的思想，例如CyberPunk曾先后提出的ecash、hashcash和B-money，比特币也是在这些尝试的基础上发展而来。ecash提出了盲签的概念，“这是第一次有人认为数字本身是有价值的，这个想法是你可以通过盲签名方法来获得这些数字，且没人知道你得到的是哪个数字，但他们知道这些是有价值的数字，银行会兑现他们的款项。”HashCash中提出了工作量证明的方法，“使用部分哈希的想法是它们可以被任意地设置为昂贵的计算成本，但是可以对其立即进行验证”。B-money中提出了公共账簿和使用公钥作为身份标识的方法，交易通过网络向所有节点进行广播。&emsp;&emsp;分布式的、不可篡改、而且防止双重支付的公共账本的思想需要有强有力的技术支撑。区块链中依赖于密码学的技术，哈希和非对称加密。&emsp;&emsp;比特币区块链中使用的哈希算法是SHA-256，它有一些很好的特性，如确定性、快速计算、隐藏性、雪崩效应以及抗冲突。哈希在区块链中的应用是工作量证明，在区块链中的节点为了争取到记账的权利，需要进行大量的哈希运算，找到满足条件的随机数，才能形成链上的区块。&emsp;&emsp;比特币区块链中使用的非对称加密的算法是椭圆曲线。当前应用较广的非对称加密算法是RSA。课上我们详细介绍了RSA中公私密钥对生成的方法，以及使用RSA进行身份认证以及加密传输的过程。&emsp;&emsp;接下来我们讨论了比特币中的共识机制PoW。共识机制本质上就是要保证所有节点认可的账本是唯一的。做到这一点，在中心化的系统中很容易，但是在分布式系统中，必须要考虑到参与节点的故障可能以及潜在的恶意攻击者的情况。在区块链上，所有的交易向所有的节点广播，矿工收到的交易的内容和顺序都可能不同；而且出块有奖励的情况下，所有的节点都会尽量出块。那么由哪个节点产生区块以及如何防止恶意节点攻击（如拒绝服务、双重支付等）？PoW通过让参与节点进行算力的竞争，使得在大部分的节点是诚实节点的情况下，DoS攻击以及双重支付攻击不会成功（支付等待6次确认）；即使有节点真正掌握了51%的算力，考虑到控制算力的巨大投入，节点也会主动维持区块链的正常运行。&emsp;&emsp;在产生区块之后，接下来就是要理解区块上记录的内容。区块上的内容主要是一笔笔的交易。由于缺少对全局数据（如余额）的支持，比特币并没有采用基于账户的方式来表示交易，而是以UTXO（Unspent Transaction Output），将之前交易的输出作为新交易的输入。我们详细地察看了交易的具体内容，并介绍了输出位置上的ScriptPubKey以及输入部分的ScriptSig。先前交易的输出需要设置相应的条件，之后的交易必须要满足这个条件才能使用这笔输出中包含的钱。所以如果矿工在接收到交易时，将新交易中的ScriptSig和先前交易中的ScriptPubKey结合起来，能顺利运行结束返回True，那么这个交易便是合法的，可以被打包进区块。同时，因为所有的验证必须由矿工完成，为了防止矿工陷入死循环，比特币能支持的脚本语言是图灵不完备的，仅能够完成有限的操作。举一个简单的例子，如果之前交易中ScriptPubKey中设置的条件是 3 op_add 5 op_equal，那么新交易中的ScriptKey应该是什么呢？&emsp;&emsp;考虑到比特币使用的是基于栈的操作。op_add是一个操作指令，需要有两个操作数，所以scriptSig中一定需要一个数字作为操作数。而后面的指令也很简单，需要和5进行比较操作。所以ScriptSig中需要输入2。&emsp;&emsp;实际中常用的交易类型是P2PKH。使用P2PKH所需要的脚本是这样的。 &emsp;&emsp;除了P2PKH之外，还有其他形式的交易，如P2PK，multiSig、P2SH等。另外介绍了一个例子Time_Lock。&emsp;&emsp;在介绍完交易之后，我们讨论了区块的头部。在区块的头部有一个数据结构，Merkle root。在比特币网络中，Merkle树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹，且提供了一种校验区块是否存在某交易的高效途径。生成一棵完整的Merkle树需要递归地对哈希节点对进行哈希，并将新生成的哈希节点插入到Merkle树中，直到只剩一个哈希节点，该节点就是Merkle树的根。这里我们需要了解Merkle证明和Merkle路径是怎么回事。&emsp;&emsp;在之后我们介绍了SPV和Bloom过滤器。这里要理解Bloom过滤器的工作特点，为什么Bloom过滤器会造成false positive而不会造成false negative？&emsp;&emsp;接下来，结合310比特币挑战，我们重点讨论了比特币钱包，用户应该如何管理比特币。这里我们主要讨论了助记词。助记词是如何生成的呢？&emsp;&emsp;为了生成大量的密钥对，引入了HD钱包的概念。应该理解HD钱包是如何生成大量的密钥的。&emsp;&emsp;以上是比特币的内容。接下来，我们开始介绍以太坊。以太坊提供了远比比特币广的应用场景，主要是因为它大大提高了区块的生成速度，以及提供了图灵完备的脚本语言。为了支持这些特性，相比于比特币，它引入一些新的概念，如Gas。请问Gas的目的是什么？另外，为了支持基于账户的交易的支持，以太坊维护了状态树，因为状态树需要经常更新，所以以太坊使用了MPT。要求能够根据给出的键值对，画出相应的MPT。&emsp;&emsp;接下来重点考虑了区块链的安全问题。我们主要考虑以太坊上的智能合约的安全问题。在介绍智能合约的安全问题时，我们讨论了THE DAO 和 Fomo3d的攻击。要能够理解攻击产生的原因。针对燕姐所给的复习内容我所做的复习总结： 1. 电子货币历史： 主要介绍三种电子货币，分别是eCash、 HashCash和B-money。 盲签：简单地说，盲签是一种特殊类型的数字签名。一般数字签名中，签名者知道所签署的消息内容。而在盲签中，签名者是他人（接收者）发来的信息进行签名，接收者首先对原始信息进行盲化，然后发送给签名者；签名者对盲化后的信息进行签名；接收者可以对这个签名后的数据去盲化，最终得到签名者关于原始信息的正确签名。 2. 哈希： 概念：譬如学校里以学生名字为索引建了一张表，存储学生的信息。同时希望在查找的时候能够高效率地查找到学生。可以怎么实现呢？所以这个时候的一个做法就是，首先在存储时，对名字进行一次哈希，得到一个数字；然后将名字存在相应数字所对应的位置。在进行查找时，再对希望查找的名字进行一次哈希，得到位置。在算法上，哈希的平均复杂度是O(1)。 基本特征：collision冲突。因为理论上，哈希函数可以接收所有的字符串作为输入，从输出的话，一般会限定一个范围，所以，极有可能有两个或多个输入产生同一个输出，这个时候就称为产生了一个冲突。常见的哈希算法如取模运算。加密哈希是哈希函数的一种，它具有某些属性，使其适用于加密。通过加密哈希，它将任意大小的数据映射到固定大小的位串（散列），并被设计为单向函数，即一个不可逆的函数。从理想的加密散列函数输出重新创建输入数据的唯一方法是尝试对可能的输入进行暴力搜索，以查看它们是否产生匹配，或使用匹配哈希的彩虹表。输入数据通常称为消息（Message），输出（散列值或散列）通常称为消息摘要或简称为摘要（Digest）。 理想的加密哈希函数有五个主要属性：(1) 它是确定性的，因此相同的消息总是产生相同的散列（只要计算过程中没有引入随机数/调度，应该都满足）(2)可以快速计算任何给定消息的哈希值（SHA-256算法的主要操作时异或运算，位运算非常快。）(3)除了通过尝试所有可能的消息之外，从其散列值生成消息是不可行的（单向hiding就是知道哈希的结果不能倒推输入。简单来说，譬如 x mod 100这样的哈希函数，如果结果是1，那么x可能是1、101、201等无穷的数。从SHA族算法，从结果完全得不到输入的任何信息。）(4)对消息进行小的更改便能引起哈希值的巨大改变，以使新哈希值看起来与旧哈希值不相关（ 雪崩效应，以使新哈希值看起来与旧哈希值不相关）(5)找到具有相同散列值的两个不同消息是不可行的（即抗冲突）（当两个输入产生同一个输出，就发生了冲突。这里的抗冲突不是说肯定不会冲突，由鸽笼原理很容易看出，只要定义域大于值域，肯定会有冲突的。哈希函数的抗冲突指的是，虽然冲突就在那里，那就是找不到——或者说在可接受的时间内找不到） 三个特点：抗冲突、隐藏（hiding）以及puzzle friendliness，以及它们的应用 抗冲突：注意这里说的冲突是不可能找到，而不是说不存在。 应用：抗冲突的一个主要应用是信息摘要（message digest）。（MD5散列摘要）问题：当我们下载开源的软件使用时，怎么可以保证下载到的软件是官方的而不是经过第三方恶意修改过的呢？可以在第三方下载软件之后，使用同样的算法做一次散列，如果相同，可以放心使用。 Hiding：Hiding的意思是如果有哈希函数的输出y，那么不可能找到x，使得h(x)=y。即单向性。问题：掷骰子，输入值的空间太小，如果想要知道输入是什么，只需要遍历一遍，把所有可能的值计算一下，然后进行比对就行。如果想对head/tail的结果进行隐藏，有什么办法吗？答案就是通过对简单的”head”和”tail”后面跟上一个随机性较强的串r，这样就能实现hiding。譬如，后面跟上长度为256bit的串，这样因为r的随机性足够强，即使head和tail很简单，也有足够的隐藏性。hiding的应用：commitment（承诺）在密码学中，可以这样计算：com := commit(msg, nonce), nonce是一个随机的秘密的数字（譬如256位）；然后公开com；相当于把公布了一个密封的信封；大家都知道做出了承诺，但是具体值是什么还没有公开verify(com,msg,nonce)，如果要检验，则用户提供原始的msg和nonce，通过同样的方法计算，看com是否和commit计算出来的结果相同（考虑一下，为什么需要一个Nonce？增加破解难度，这样不易从com看出原来的msg）这里的commit就可以使用哈希函数来实现。commit就是哈希函数 puzzle friendliness：对于每一个可能的 n位输出 y ，如果 k 是随机性很强的值（譬如长度为256位的随机二进制串），那么找到一个合适的x使得 H(k||x)=y 是不可能显著地低于 2^n的时间复杂度。这个特点强调的是，如果给定特殊的哈希结果 y ，并且输入中有一部分随机性很强 k，那么找到输入的另一个部分 x 使得哈希的结果等于y，那么就只能依靠暴力搜索。应用： search puzzle ；区块链中的工作量证明。 哈希算法SHA-256在区块链中的应用哈希在区块链中的用处包括： 利用puzzle-friendliness的工作量证明，也即，要求生成一个新区块时，哈希值一定要是以一定数量的连续的0开始的； 对每个区块的内容进行哈希，后面的区块相当于一直在对前面的区块进行哈希，所以一般来说，如果一个区块之后如果跟上其他6个区块之后，一般认为该区块的内容已经被公认了，不可更改。 3. RSA算法： (1) 原根：DH算法为什么在DH算法中，要强调使用的是原根？而不是和p 互质的任意数字？因为根据素数的特性，不论是不是原根，下面的等式总是成立的。这里主要涉及的问题是，破解的难度。如果使用的 g 不是 p的原根，那么 g 的所有指数只能生成小于p 的整数的一个子集。那么对于攻击者而言，此时即使是暴力破解，需要计算的也只是小于 p 的整数的子集，而不是小于 p 的整数全部。（因为若不是原根的话，由它的指数生成的是小于p的子集，使破解难度降低） (2) 中间人攻击：Eve在Alice和Bob之间，拦截他们的通信，并且维持通信，就称为中间人攻击。为了防御中间人攻击，就需要一个能够验证通信双方身份的机制来防止这种攻击。数字签名实现 (3) RSA中公私密钥对生成的方法：p,q质数（后面重点讲） (4) RSA进行身份认证（RSA应用）：数字签名 ① 数字签名能保证：当数据从发送方传送到接收方时，数据不会被修改；数据由某一确定的发送方创建；发送方无法否认发送过数据这一事实。 ​ ② 数据签名并不是加密，你无法从一个签名重新构造出数据 ​ ③ 在比特币中，每一笔交易输入都会由创建交易的人签名。在被放入到一个块之前，必须要对每一笔交易进行验证。除了一些其他步骤，验证意味着：检查交易输入有权使用来自之前交易的输出；检查交易签名是正确的 (5) 在区块链中，公钥==身份 ​ 数字签名：两个特点：1. 签名不能伪造，也即只有自己能做出这个签名；2. 签名是针对一份文档的，也即，一个签名只能和一个文档相关联，不能拿到一个签名用于多个文档，类似于不能把一份文件上的签名撕下来贴到另一个文件上。 ​ 具体是怎么实现呢？ 首先生成一对公私钥 （pk, sk）。 pk 是公钥， sk是私钥。 签名sign。sig = sign(sk,message) ，使用私钥对一份消息message进行处理，譬如先对message进行哈希得到摘要，然后使用私钥对摘要进行加密。 验证verify。Verify(pk,message,sig) 。验证方法，获得输入message，签名的结果sig，以及公钥。譬如，可以使用公钥对签名结果进行解密，对message进行同样散列得到的摘要，比较解密的结果和摘要结果，如果两个相同，这验证通过，否则，验证失败。 &emsp;&emsp;也即，如果能够进行verify(pk,msg,sig)==true，那么，就可以认为pk确实说了msg。当然，为了以pk的身份说话，就必须有相应的私钥sk。 &emsp;&emsp;所以，可以认为pk 就是身份identity，在比特币区块链中，使用 pk 的哈希作为身份。在生成一对公私钥之后，拥有 sk 的人可以控制 pk。 4. 比特币中的共识机制PoW：(1) 共识机制本质上就是要保证所有节点认可的账本是唯一的。做到这一点，在中心化的系统中很容易，但是在分布式系统中，必须要考虑到参与节点的故障可能以及潜在的恶意攻击者的情况。PoW通过让参与节点进行算力的竞争，使得在大部分的节点是诚实节点的情况下，DoS攻击以及双重支付攻击不会成功。 (2) 简化的比特币的共识算法过程： ① 向所有的节点广播新的交易。 ② 每个节点将新交易打包进区块。 ③ 每一轮中一个随机的节点广播该区块。 ④ 如果区块中所有的交易都是有效的（比特币没有重花，签名正确等），则其他节点接受这个区块； ⑤ 节点表示接受该区块的方式是在之后新创建的区块中包括这个块的哈希。 (3) 针对这个算法讨论一下在货币网路中可能的攻击方法： ① 偷比特币：区块中Alice试图伪造一个交易“Bob发送10个比特币给Alice。”如果要让这个交易合法，那么Alice必须能够伪造Bob的签名，但是Alice如果没有Bob的私钥，那么Alice就不能伪造签名。 ② 拒绝服务（Dos攻击）：Alice区块忽视有关Bob交易，这个攻击的问题是，Alice并不能控制区块的产生。即使Alice在一个区块中忽略了Bob的交易，其他诚实的节点会在交易中包括Bob的交易。 ③ 双重支付：她先广播了一条交易“Alice付给Bob一些比特币”，Bob认为Alice已经支付了，所以将软件发送给了Alice，Alice后来又把刚才付给Bob的币付给自己。问题是，双重攻击能否成功，完全取决于区块链到底沿着那条链延续。诚实的节点会沿着最长的链创建自己的区块。所以答案就是，没有正确的答案。那么Bob如何应对这个问题呢？只要Bob等足够的时间，确定最终区块链中到底包含了哪一个块。而且，随着区块的增加（确认数的增加），交易变无效的可能性是指数级降低的。因此，可以等待6个区块，也即差不多1个小时的时间，基本上不会再翻盘了。 (4) 也正是因为工作量证明，保证了如果大部分的节点（以算力而不是个数）是诚实的，那么至少有50%的可能，下一个区块来自于诚实的节点。 (5) 51%攻击。 ① 不能偷比特币，要私钥签名 ② 攻击者能不能进行DoS攻击？如果攻击者特别不喜欢Bob，那么确实有可能Bob的交易不会出现在所有的区块中。但是，Bob的交易可以被广播到网络中，所以，即使Bob确实是拒绝服务了，但是至少对于诚实节点而言，能够发现攻击发生了。 ③ 双重支付，在51%的算力控制下，确实有可能，一旦人们发觉到比特币网络被人控制，那么人们会主动放弃比特币，那么比特币的价值会直接崩溃。而攻击者呢，考虑到控制51%算力的代价，出现这种情况就相当于所有的投资都会打水漂。 5. UTXO交易方式：&emsp;&emsp;将之前交易的输出作为新交易的输入。我们详细地察看了交易的具体内容，并介绍了输出位置上的ScriptPubKey以及输入部分的ScriptSig。先前交易的输出需要设置相应的条件，之后的交易必须要满足这个条件才能使用这笔输出中包含的钱。所以如果矿工在接收到交易时，将新交易中的ScriptSig和先前交易中的ScriptPubKey结合起来，能顺利运行结束返回True，那么这个交易便是合法的，可以被打包进区块。如果之前交易中ScriptPubKey中设置的条件是 3 op_add 5 op_equal，那么新交易中的ScriptKey应该是什么呢？ 2 6. P2SH给步骤用钱怎么弄2 of 3：(1) 问题：譬如Alice向Bob购买一件物品，但是Bob的物品不是自己独有的，他需要和其他人一起分享Alice付的币，就例如上面介绍的MULTICHECK，需要3个人中的两人同意才能使用币。把这个任务交给Alice是不合理的，因为Alice只关心自己付了钱能够拿到物品，并不关心Bob拿到钱之后怎么分。这个时候Bob可以创建一个Script，然后Alice可以将币发送到这个Script地址。 (2) 怎样实现呢？P2SH的脚本是一个2-of-3的多签名。 ① 首先Bob需要创建2-of-3 multisig P2SH地址。生成的P2SH地址提供给Alice。同时生成了Redeem Script（组成为：&lt; OP_2 &gt; &lt; A pubkey &gt; &lt; B pubkey &gt; &lt; C pubkey &gt; &lt; OP_3 &gt; &lt; OP_CHECKMULTISIG&gt; ），也即Bob在将Alice支付的钱赎出的时候提供的签名脚本。使用这个redeemScript， ② 又经过两个步骤生成了P2SH地址: 对redeemScript进行两次哈希； Base58check使用前缀0x05对redeemscriptHash进行编码； ③ 使用P2SH地址生成交易：为了形成交易，Alice需要以下的信息：来自标准P2PKH的输出,该 P2PKH的交易id(txid），相对应的私钥，需要发送的币的个数，以及目标P2SH地址（也就是上面刚生成的地址)。 7. 怎样验证交易一定存在证明过程(1) 由于哈希的单向性，可以得出结论，如果两棵Merkle树的merkle root相同，那么这两棵树的结构和每个节点也必然是相同的。另外，只要存储的叶子节点数据有任何的变动，就会逐级向上传递到相应的父节点，最终使得Merkle树的根节点哈希值发生变化。 典型merkle树如下： (2) 譬如用户Bob收到用户Alice发来的一笔支付交易，这时Bob必须要验证这笔交易（1）确实存在，并且（2）不是双重支付。对于SPV用户而言，需要从可信节点获得区块链的完整的头部信息，以及和他想验证的交易的Merkle分支。这样，虽然用户不能自己验证交易，但如果能够从区块链的某处找到符合的交易，就可以知道这笔交易已被网络确认，也可以确认该笔交易得到网络多少笔确认。譬如，SPV节点要验证第300,000号区块中的某个交易，它需要获得300,000区块中交易的Merkle分支（Merkle路径）进行验证，并且等到序号从300,001到300,006的六个区块堆叠在该交易所在的区块上。如果网络中的其他节点都接受了第300,000区块，并通过足够的工作在该块之上又生成了六个区块，就可以证明该交易不是双重支付 (3) 使用Merkle分支进行验证是Merkle树的Tamper proof性质， 使用Merkle树之后，可以很容易验证区块中的交易有没有被篡改。譬如在下图中的例子，如果一个交易 TH 被篡改成了T？ ，那么交易的哈希值会不同，沿着从底层到根节点的路径向上，会导致最终树的merkle root不同，也即保存在区块链头的值不同。相反，如果从叶子节点到Merkle根的路径上，所有的哈希值都验证正确，那么可以证明这个交易确实存在于这个区块中。 (4) 如上图，如果需要证明某个区块上是否存在一笔交易Tx3，那么全节点返回的Merkle路径是Hash2和Hash01。只需要这两个值就可以进行验证过程如下： ① Step1：计算交易Tx3的哈希值，得到Hash3 ② Step2：通过Hash2和Hash3的哈希值，得到父节点的哈希值Hash23 ③ Step3：同上，通过计算Hash23和Hash01哈希值，得到根节点的哈希值。 Step4：将上一步得到的根哈希值对比区块头中MerkleTree的根哈希值，如果相同，则证明该区块中存在交易Tx3，否则说明不存在。 8. Bloom过滤器&emsp;&emsp;这里要理解Bloom过滤器的工作特点，为什么Bloom过滤器会造成false positive而不会造成false negative？（m个哈希函数，n位二进制数组） 这里使用十六位数组（N=16）和三个哈希函数（M=3）来演示Bloom过滤器的应用原理。 &emsp;&emsp;Bloom过滤器数组里的每一个数的初始值为零。关键词被加到Bloom过滤器中之前，会依次通过每一个哈希函数运算一次。该输入经第一个哈希函数运算后得到了一个在1和N之间的数，它在该数组（编号依次为1至N）中所对应的位被置为1，从而把哈希函数的输出记录下来。接着再进行下一个哈希函数的运算，把另外一位置为1；以此类推。当全部M个哈希函数都运算过之后，一共有M个位的值从0变成了1，这个关键词也被“记录”在了Bloom过滤器里。 向上图中的简易Bloom过滤器添加关键词“A”: 会造成False positive是因为这些字节1也有可能是其他关键词运算的重叠结果。简单来说，Bloom过滤器正匹配代表着“可能是”。 一定不会造成false negative，如果我们代入关键词计算后的结果某位为0，说明该关键词并没有被记录在过滤器里。负匹配的结果不是可能，而是一定。也就是说，负匹配代表着“一定不是”。 9. 助记词(1) 第二种类型是确定性钱包（deterministic wallet），其中所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子（seed）。该类型钱包中所有密钥都相互关联，如果有原始种子，则可以再次生成全部密钥。确定性钱包中使用了许多不同的密钥推导方法。最常用的推导方法是使用树状结构，称为分级确定性钱包或HD钱包。确定性钱包由种子衍生创造。为了便于使用，种子被编码为英文单词，也称为助记词。 (2) HD钱包有两个主要的优势。第一，树状结构可以被用来表达额外的组织含义。比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门、子公司、具体功能以及会计类别。第二，用户可以建立一个公钥的序列而不需要访问相对应的私钥 (3) 助记词生成过程：助记词是由钱包使用BIP-39中定义的标准化过程自动生成的。 钱包从熵源开始，增加校验和，然后将熵映射到单词列表： 1) 创建一个128到256位的随机序列（熵）。 2) 提出SHA256哈希前几位（熵长/ 32），就可以创造一个随机序列的校验和。 3) 将校验和添加到随机序列的末尾。 4) 将序列划分为包含11位的不同部分。 5) 将每个包含11位部分的值与一个已经预先定义（2^11）2048个单词的字典做对应。 6) 生成的有顺序的单词组就是助记码。 7) PBKDF2密钥延伸函数的第一个参数是从步骤6生成的助记符。 8) PBKDF2密钥延伸函数的第二个参数是盐。 由字符串常数“助记词”与可选的用户提供的密码字符串连接组成。 9) PBKDF2使用HMAC-SHA512算法，使用2048次哈希来延伸助记符和盐参数，产生一个512位的值作为其最终输出。 这个512位的值就是种子。（将6步生成的助记词与盐一起构成新的字符串，然后用HMAC-sha512 进行2048次哈希产生一个512为种子） 10. 从root seed生成公私钥对的过程就是对root seed进行一次HMAC-SHA512的加密哈希，在生成512的结果之后，将512位结果划分为两个256部分，分别是Master private key（主私钥）和Master Chain Code（主链码）。然后从私钥生成到公钥。 123child_private_key == (parent_private_key + lefthand_hash_output) % Gchild_public_key == point( (parent_private_key + lefthand_hash_output) % G )child_public_key == point(child_private_key) == parent_public_key + point(lefthand_hash_output) 上面的三个等式，第一个是子私钥的生成；第二个是从子私钥生成子公钥；第三个是从父公钥直接生成子公钥。【注1：因为子公钥和父公钥之间的关系依赖于 point(lefthand_hash_output)， 而point(lefthand_hash_output)的值依赖于链码、父公钥和索引，缺少的值仅仅是链码】【注2：因为父公钥已知，链码在同一对父公私钥的情况下的是固定的，如果链码泄露的情况下，还是可以推导出兄弟姐妹公钥；】【注3：因此，扩展公钥，不同于公钥，公钥是理所当然应该公开的；而扩展公钥因为是公钥和链码的连接，为了保护链码，应该保护扩展公钥】因为创建子密钥需要父密钥和链码，所以讲密钥和链码一起称为扩展密钥。扩展私钥和相对应的扩展公钥具有相同的链码。如果攻击者获得了父链码和父公钥，那么就可以获得所有的子链码。有了子链码，如果又获得了底层的某一个私钥（孙子密钥），那么可以根据这个链码生成所有的扩展私钥。更惨的是，攻击者可能通过子密钥逆推回祖先私钥。也即，如果攻击者获得了一个扩展公钥，以及任何它的子孙私钥，那么就能够这个公钥对应的私钥，以及所有的后代密钥。 因此，扩展公钥的链码部分需要好好保存。也因此提出了强化子密钥的概念。 11. gas 有什么用&emsp;&emsp;合约可以利用的每个命令都会有一个相应的费用值，费用使用gas作为单位计数，也即用户付给矿工的佣金。这样如果恶意用户在交易中包括了死循环，那么不论付出多少gas，最终都会消耗完。另外，也正是因为这样的代价问题，虽然以太坊的脚本语言是图灵完备的，也即当前的所有代码都可以在以太坊区块链上运行，但是作为开发者，需要认真考虑代码的效率。两个同样功能的合同，效率高的那个才能生存下来。 12. Hex编码到HP编码 [ 1, 2, 3, 4, 5, …] //扩 展结点，路径长度为奇数，添加01（bit），也即1(nibble)‘11 23 45’ [ 0, 1, 2, 3, 4, 5, …] //扩展结点，路径长度为偶数，添加00，也即0，然后补一个0‘00 01 23 45’ [ 0, f, 1, c, b, 8, 10] //叶子节点，长度为偶数（最后一个10也即16，补充位，需要移除），添加10，也即0，然后补一个0‘20 0f 1c b8’ [ f, 1, c, b, 8, 10] //叶子节点，长度为奇数，添加11，也即3‘3f 1c b8’ 13. 画出MPT树 &lt; 64 6f &gt; : ‘verb’&lt; 64 6f 67 &gt; : ‘puppy’&lt; 64 6f 67 65 &gt; : ‘coin’&lt; 68 6f 72 73 65 &gt; : ‘stallion’ 14 The DAO攻击The DAO攻击：不让别人打包交易，给多gas，优先多的打包，其它的交易延迟 （1） 提供了三种方法实现send功能： .transfer() 当发送失败时会 throw; 回滚状态 只会传递 2300 Gas 供调用，防止重入（reentrancy） .send() 当发送失败时会返回 false 布尔值 只会传递 2300 Gas 供调用，防止重入（reentrancy） .gas().call.value()() 当发送失败时会返回 false 布尔值 传递所有可用 Gas 进行调用（可通过 gas(gas_value) 进行限制），不能有效防止重入（reentrancy） （2）分析以下代码漏洞和防御 1234567891011121314151617181920212223EtherStore.sol：contract EtherStore &#123; uint256 public withdrawalLimit = 1 ether; mapping(address =&gt; uint256) public lastWithdrawTime; mapping(address =&gt; uint256) public balances; function depositFunds() public payable &#123; balances[msg.sender] += msg.value; &#125; function withdrawFunds (uint256 _weiToWithdraw) public &#123; require(balances[msg.sender] &gt;= _weiToWithdraw); // limit the withdrawal require(_weiToWithdraw &lt;= withdrawalLimit); // limit the time allowed to withdraw require(now &gt;= lastWithdrawTime[msg.sender] + 1 weeks); require(msg.sender.call.value(_weiToWithdraw)()); balances[msg.sender] -= _weiToWithdraw; lastWithdrawTime[msg.sender] = now; &#125; &#125; 以上代码就是被攻击代码。它的功能是充当公共账户，类似于银行，接收用户存款（depositFund），提供用户取现功能（withdrawFunds）。 depositFund中，简单增加用户账户的余额，在用户取现的时候，首先做检查，确保用户账户的余额超出所要提取的金额，然后检查取现金额的最大值；接下来再对取现的时间进行限制，确保一周支取一次。然后将钱转给调用者账户，随后修改调用者msg.send的余额，并更新最新的取现时间。 这段合约的漏洞就在于：require(msg.sender.call.value(_weiToWithdraw)()); 当被攻击代码执行到这一句的时候，它会调用msg.send代码中的fallback函数。因为withdraw函数中使用了call.value()，所以会调用攻击者合约中的匿名函数，而在攻击者的匿名函数中，又再次调用withdrawFunds函数，这样，只要攻击者的gas足够多，它会一直将公共账户也即Bank里的钱全部移走。 效果如下： balance 下溢 Reentrance 账户余额 0 ether Attack 账户余额 1 ether (3) 防御： 在将 Ether 发送给外部合约时使用内置的 transfer() 函数 。transfer转账功能只发送 2300 gas 不足以使目的地址/合约调用另一份合约（即重入发送合约）。 确保所有改变状态变量的逻辑发生在 Ether 被发送出合约（或任何外部调用）之前。在这个 EtherStore 例子中，EtherStore.sol 中对账户余额和账户时间的修改应该在发送以太币之前。将任何对未知地址执行外部调用的代码，放置在本地化函数或代码执行中作为最后一个操作，是一种很好的做法。这被称为 检查效果交互（checks-effects-interactions） 模式。 引入互斥锁。也就是说，要添加一个在代码执行过程中锁定合约的状态变量，阻止重入调用；这样在本次发送–修改余额这一整套操作完成之前，不能再次执行发送操作。 15. RSA中公私密钥对生成的方法已知：两质数 $ p = 61, q = 53 $ 和$ e = 17 $，求 $ d $（用Euclid扩展算法求模逆）$ N = p * q = 3233 $ $ (p-1)(q-1)= 60 * 52 = 3120 $ 利用3120 和 17 来分解： $ 3120 = 17 * 183 + 9 $ $ 17 = 9 * 1 + 8 $ $ 9 = 8 * 1 + 1 $ 将余数放在左边: $ 9 = 3120 - 17 * 183 (1) $ $ 8 = 17 - 9 * 1 (2) $ $ 1 = 9 - 8 *1 (3) $ 将（3）中8用（2）替换，（2）中9用（1）替换 $ 1 = 9 - 1 * (17 - 9 * 1) = 2 * 9 - 17 = 2 * (3120 - 17 * 183) - 17 $ $ = 2 * 3120 - (2 * 183 + 1 ) * 17 $ 由此可得 $ - ( 2 * 183 + 1) = -367 $为d, 再转化为正数为 $ 3120 - 367 = 2753 $ 故$ d = 2753 $]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[占坑]]></title>
    <url>%2F2018%2F11%2F17%2F%E5%8D%A0%E5%9D%91%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;此post的目的是防止您点击阅读时出现404。顺带预告下第一次要讲的书是《三体》。]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>三体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blockchain2]]></title>
    <url>%2F2018%2F11%2F17%2FBlockchain2%2F</url>
    <content type="text"><![CDATA[哈希函数–密码学中“瑞士军刀” 区块链二：哈希 1. 哈希函数概念来自维基百科的解释： A hash function is any function that can be used to map data of arbitrary size to data of a fixed size. The values returned by a hash function are called hash values, hash codes, digests, or simply hashes. &emsp;&emsp;通过一个问题来理解一下，譬如学校里以学生名字为索引建了一张表，存储学生的信息。同时希望在查找的时候能够高效率地查找到学生。可以怎么实现呢？&emsp;&emsp;这个时候的一个做法就是，首先在存储时，对名字进行一次哈希，得到一个数字；然后将名字存在相应数字所对应的位置。在进行查找时，再对希望查找的名字进行一次哈希，得到位置。在算法上，哈希的平均复杂度是O(1)。 2. 哈希函数的基本特征&emsp;&emsp;这里重点讨论的是加密哈希（cryptographic hash）。加密哈希是哈希函数的一种，它具有某些属性，使其适用于加密。通过加密哈希，它将任意大小的数据映射到固定大小的位串（散列），并被设计为单向函数，即一个不可逆的函数。从理想的加密散列函数输出重新创建输入数据的唯一方法是尝试对可能的输入进行暴力搜索，以查看它们是否产生匹配，或使用匹配哈希的彩虹表。布鲁斯施奈尔称单向散列函数是“现代密码学的主力”。输入数据通常称为消息（Message），输出（散列值或散列）通常称为消息摘要或简称为摘要（Digest）。 理想的加密哈希函数有五个主要属性： 它是确定性的，因此相同的消息总是产生相同的散列（只要计算过程中没有引入随机数/调度，应该都满足） 可以快速计算任何给定消息的哈希值（SHA-256算法的主要操作时异或运算，位运算非常快。） 除了通过尝试所有可能的消息之外，从其散列值生成消息是不可行的（单向hiding就是知道哈希的结果不能倒推输入。简单来说，譬如 x mod 100这样的哈希函数，如果结果是1，那么x可能是1、101、201等无穷的数。从SHA族算法，从结果完全得不到输入的任何信息。） 对消息进行小的更改便能引起哈希值的巨大改变，以使新哈希值看起来与旧哈希值不相关（ 雪崩效应，以使新哈希值看起来与旧哈希值不相关） 找到具有相同散列值的两个不同消息是不可行的（即抗冲突）（当两个输入产生同一个输出，就发生了冲突。这里的抗冲突不是说肯定不会冲突，由鸽笼原理很容易看出，只要定义域大于值域，肯定会有冲突的。哈希函数的抗冲突指的是，虽然冲突就在那里，那就是找不到——或者说在可接受的时间内找不到） 三个特点：抗冲突、隐藏（hiding）以及puzzle friendliness，以及它们的应用。 抗冲突：注意这里说的冲突是不可能找到，而不是说不存在。 应用：抗冲突的一个主要应用是信息摘要（message digest）。（MD5散列摘要）问题：当我们下载开源的软件使用时，怎么可以保证下载到的软件是官方的而不是经过第三方恶意修改过的呢？可以在第三方下载软件之后，使用同样的算法做一次散列，如果相同，可以放心使用。 Hiding：Hiding的意思是如果有哈希函数的输出y，那么不可能找到x，使得h(x)=y。即单向性。问题：掷骰子，输入值的空间太小，如果想要知道输入是什么，只需要遍历一遍，把所有可能的值计算一下，然后进行比对就行。如果想对head/tail的结果进行隐藏，有什么办法吗？答案就是通过对简单的”head”和”tail”后面跟上一个随机性较强的串r，这样就能实现hiding。譬如，后面跟上长度为256bit的串，这样因为r的随机性足够强，即使head和tail很简单，也有足够的隐藏性。hiding的应用：commitment（承诺）在密码学中，可以这样计算：com := commit(msg, nonce), nonce是一个随机的秘密的数字（譬如256位）；然后公开com；相当于把公布了一个密封的信封；大家都知道做出了承诺，但是具体值是什么还没有公开verify(com,msg,nonce)，如果要检验，则用户提供原始的msg和nonce，通过同样的方法计算，看com是否和commit计算出来的结果相同（考虑一下，为什么需要一个Nonce？增加破解难度，这样不易从com看出原来的msg）这里的commit就可以使用哈希函数来实现。commit就是哈希函数 puzzle friendliness：对于每一个可能的 n位输出 y ，如果 k 是随机性很强的值（譬如长度为256位的随机二进制串），那么找到一个合适的x使得 H(k||x)=y 是不可能显著地低于 2^n的时间复杂度。这个特点强调的是，如果给定特殊的哈希结果 y ，并且输入中有一部分随机性很强 k，那么找到输入的另一个部分 x 使得哈希的结果等于y，那么就只能依靠暴力搜索。应用： search puzzle ；区块链中的工作量证明。 3. 哈希算法SHA-256&emsp;&emsp;SHA-256是SHA-2中的一个算法。SHA-2，也即第二代安全散列算法（Secure Hash Algorithm 2），由美国国家安全局2001年公布的标准哈希算法，是SHA-1的后继。SHA-2下包括六个不同的算法标准：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。这些不同的算法使用不同生成摘要的长度 、循环运行的次数，但算法的基本结构是一致的。现在已知SHA-2容易受到长度扩展攻击，所以推荐使用SHA-3来取代它。对于任意长度的消息，SHA256都产生256bit长的哈希值，也即32字节，或者64位的16进制数，或者8个8位的16机制数 。为什么要强调这个呢？&emsp;&emsp;简单说一下SHA-256的计算过程。 这里A～H共有8个，初始值分别是12345678h0 := 0x6a09e667h1 := 0xbb67ae85h2 := 0x3c6ef372h3 := 0xa54ff53ah4 := 0x510e527fh5 := 0x9b05688ch6 := 0x1f83d9abh7 := 0x5be0cd19 &emsp;&emsp;看一下，分别是8个16进制数，所以总共有256位，这个就叫做初始向量（IV）。这8个数是前8个素数取平方根，前32位小数。最终生成的哈希值也是这么长，所以，每一轮的计算就是如上图所示，更新这8个值。那怎么更新呢？ &emsp;&emsp;每一轮计算64次。在上图中可以看到，除了A～H外，有两个输入，分别是 w_{t} 和 k_{t} 。也即每一轮中有64个 w ，以及64个 k 。每个 w 长度为32bit，也即4个字据诶。64个 w 来自于哈希函数的输入，也即，对于输入，不论长短，长的就分成每512bit一个块（64个字节），短的补足512bit。这64个字节构成了前16个 w ，后面的48个 w 通过前面的16个生成。1234for i from 16 to 63 s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3) s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor (w[i-2] rightshift 10) w[i] := w[i-16] + s0 + w[i-7] + s1 64个 k 是64个常量1234k[0..63] :=0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2 这64个常量来自于自然数中前64个质数{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97…}，取立方根，前32bit而来。然后每一次的计算，12345678h := gg := ff := ee := d + temp1d := cc := bb := aa := temp1 + temp2 temp1和temp2就是经过异或、右移、循环右移等操作生成的。 &emsp;&emsp;关于短的输入如何补足也有一些细节，在输入末尾进行填充，使输入长度在对512取模以后的余数是448。填充的具体过程：先补第一个比特为1，然后都补0，直到长度满足对512取模后余数是448。需要注意的是，信息必须进行填充，也就是说，即使长度已经满足对512取模后余数是448，补位也必须要进行，这时要填充512个比特。因此，填充是至少补一位，最多补512位。为什么余数是448呢?因为，还有需要有64位的数据表示原始输入的长度，加上这64bit的长度信息448+64=512，刚好512位。 在区块链中的应用 哈希在区块链中的用处包括： &emsp;&emsp;利用puzzle-friendliness的工作量证明，也即，要求生成一个新区块时，哈希值一定要是以一定数量的连续的0开始的；&emsp;&emsp;对每个区块的内容进行哈希，后面的区块相当于一直在对前面的区块进行哈希，所以一般来说，如果一个区块之后如果跟上其他6个区块之后，一般认为该区块的内容已经被公认了，不可更改。 本文来自燕姐的授课内容，详情见她的知乎]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[立flag]]></title>
    <url>%2F2018%2F11%2F17%2F%E7%AB%8Bflag%2F</url>
    <content type="text"><![CDATA[立一个大大的Flag: 每两到三天至少发一篇post 所包含内容： 技术类 算法 区块链 python编程 AI 等等 生活类 见闻和感想 生活记录 阅读 其他 转载我感觉比较好的文章]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>flag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blockchain1]]></title>
    <url>%2F2018%2F11%2F16%2FBlockchain1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;区块链这个词现在实在太火了。有人认为它是一项颠覆性的革命性的技术，还有很多人认为它不过是一个庞氏骗局，那我们到底应该怎么样看待区块链和数字货币呢？ 区块链一：区块链、比特币历史 1. 区块链主要事件： 1976年 Bailey W.Diffe、Martin E.Hellman发表《密码学的新方向》 1977年 RSA算法诞生 1980年 Merkle-Tree 被提出 1982年 提出拜占庭将军问题；同年，David Chaum提出密码学网路支付系统ECash 1985年 提出椭圆曲线密码学 1990年 提出Paxos 1991年 使用时间戳确保数位文件安全 1992年 提出椭圆曲线数位签章演算法 1997年 Adam Back发明Hashcash技术 1998年 Wei Dai发表匿名的分散式电子现金系统B-money 1999年-2001年 Napster、EDonkey和BitTorrent先后出现，奠定P2P基础 2001年 NSA发布SHA-2系列算法也是比特币采用的哈希算法 2005年 可重复使用的工作量证明机制（RPOW）出现 2008年 Blockchain 1.0：加密货币发布，11月中本聪发布著名论文《比特币：一种点对点的电子现金系统》 2009年 1月创世区块诞生，潘多拉魔盒打开 2010年 比特币挖矿开端 2011年 第一个版本：0.3.21发布 2014年2月 俄罗斯小伙子V神(Vitalik Buterin)创立以太坊(Ethereum)，当年20岁，绝对的天才 2014年4月 Gavin Wood发布以太坊黄皮书 2015年7月 以太坊发布第一个正式版本Frontier 2016年 The DAO被攻击事件 2017年 Metropols发布，POW最后一个阶段 图片来自众安保险 2.比特币&emsp;&emsp;Dai Wei评价说：“要想开发出比特币，必须得： 对货币有非常深入的思考； 要了解密码学； 认为比特币这样的系统从理论上是可行的； 要有足够的动力去将这个理念开发成实际产品； 编程能力出色，能保证产品安全； 有足够的社交技巧，才能围绕这个产品建立一个成功的社区。 密码学圈子能符合前三个条件的人就已是凤毛麟角。”&emsp;&emsp;中本聪（匿名性做的最好的密码朋克的成员）提出的“该网络通过随机散列（hashing）对全部交易加上时间戳（timestamps），将它们合并入一个不断延伸的基于随机散列的工作量证明（proof-of-work）的链条作为交易记录，除非重新完成全部的工作量证明，形成的交易记录将不可更改。最长的链条不仅将作为被观察到的事件序列（sequence）的证明，而且被看做是来自CPU计算能力最大的池（pool）。只要大多数的CPU计算能力都没有打算合作起来对全网进行攻击，那么诚实的节点将会生成最长的、超过攻击者的链条”。比特币中的交易和B-money中的相似，包含了转账双方的公钥，并且使用Payer的私钥加密；&emsp;&emsp;比特币引入了PoW，工作量证明，来解决分布式系统中的一致性问题，也即，PoW对应着的是算力，相当于是一个CPU一票。想要在投票中作弊，就必须控制占多数的算力。网络运行步骤：1) 新的交易向全网进行广播；2) 每一个节点都将收到的交易信息纳入一个区块中；3) 每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明；4) 当一个节点找到了一个工作量证明，它就向全网进行广播；5) 当且仅当包含在该区块中的所有交易都是有效的且之前未存在过的，其他节点才认同该区块的有效性；6) 其他节点表示他们接受该区块，而表示接受的方法，则是在跟随该区块的末尾，制造新的区块以延长该链条，而将被接受区块的随机散列值视为先于新区快的随机散列值。 &emsp;&emsp;对于类似于B-money中的双重支付问题，如果Alice试图用同一笔钱来支付两个交易，那么两个交易不可能都存在于区块链上，因为每一个交易都会被检查；即使Alice强制性地将两个交易都打包进一个区块，其他用户也不会接受包括了不正确交易的区块。如果有两个矿工分别将两笔交易打包进了自己的区块，并且都成功地完成了工作量证明，那么哪一个交易会真正地成为被大家公认的交易就要看运气了。&emsp;&emsp;如果Bob不相信Alice，那么他可以等待Alice的支付消息被成功地打包进了区块，而且在其后又链接更多区块之后，才完成与Alice的交易。譬如Alice向Bob买一本书，按照10分钟生成一个区块的速度，Bob可以等一个小时，也即Alice的支付消息之后有了另外5个区块之后，才将书交给Alice。比特币网络中 还有其他的一些技术细节，譬如Merkle树等，之后再讨论。&emsp;&emsp;关于比特币的传说还有很多，譬如来自《纽约客》的报道：“When I first looked at the code, I was sure I was going to be able to break it,” Kaminsky said, noting that the programming style was dense and inscrutable. “The way the whole thing was formatted was insane. Only the most paranoid, painstaking coder in the world could avoid making mistakes.”Kaminsky lives in Seattle, but, while visiting family in San Francisco in July, he retreated to the basement of his mother’s house to work on his bitcoin attacks. In a windowless room jammed with computers, Kaminsky paced around talking to himself, trying to build a mental picture of the bitcoin network. He quickly identified nine ways to compromise the system and scoured Nakamoto’s code for an insertion point for his first attack. But when he found the right spot, there was a message waiting for him. “Attack Removed,” it said. The same thing happened over and over, infuriating Kaminsky. “I came up with beautiful bugs,” he said. “But every time I went after the code there was a line that addressed the problem.”He was like a burglar who was certain that he could break into a bank by digging a tunnel, drilling through a wall, or climbing down a vent, and on each attempt he discovered a freshly poured cement barrier with a sign telling him to go home. “I’ve never seen anything like it,” Kaminsky said, still in awe.Kaminsky ticked off the skills Nakamoto would need to pull it off. “He’s a world-class programmer, with a deep understanding of the C++ programming language,” he said. “He understands economics, cryptography, and peer-to-peer networking.”“Either there’s a team of people who worked on this,” Kaminsky said, “or this guy is a genius.” 本部分来自燕姐的授课内容，详情见她的知乎 3. 以太坊黄皮书 参考文献： https://en.wikipedia.org/wiki/Blockchain https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system https://zhuanlan.zhihu.com/p/44449024 https://en.wikipedia.org/wiki/Vitalik_Buterin]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise6]]></title>
    <url>%2F2018%2F11%2F02%2FExercise6%2F</url>
    <content type="text"><![CDATA[Case Study: Dice Poker1. Program Specification&ensp;&ensp;Our goal is to write a game program that allows a user to play video poker using dice. The program will display a hand consisting of five dice. The basic set of rules is as follows: The player starts with $100. Each round costs $10 to play. This amount is subtracted from the player’s money at the start of the round. The player initially rolls a completely random hand (i.e., all five dice are rolled). The player gets two chances to enhance the hand by rerolling some or all of the dice. At the end of the hand, the player’s money is updated according to the following payout schedule: hand pay Two Pairs $5 Three of a Kind $8 Full House (A Pair and a Three of a Kind) $12 Four of a Kind $15 Straight (1-5 or 2-6) $20 Five of a Kind $30 &ensp;&ensp;Ultimately, we want this program to present a nice graphical interface. Our interaction will be through mouse clicks. The interface should have the following characteristics: The current score (amount of money) is constantly displayed. The program automatically terminates if the player goes broke. The player may choose to quit at appropriate points during play. The interface will present visual cues to indicate what is going on at any given moment and what the valid user responses are. The interface looks like: 2. Identifying Candidate ObjectsCandidate Objects including: the Dice class constuctor rollAll roll values score A PokerApp object run playRound doRolls A PokerInterface object setMoney setDice wantToPlay showResult chooseDice 3.Implementing the Model3.1 Implementing Dice&ensp;&ensp;The Dice class implements a collection of dice, which are just changing numbers. The obvious representation is to use a list of five ints. 12345678910111213141516171819202122232425262728293031323334353637383940from random import *class Dice: def __init__(self): self.dice = [0]*5 self.rollAll() def roll(self, which): for pos in which: self.dice[pos] = randrange(1, 7) def rollAll(self): self.roll(range(5)) def values(self): return self.dice[:] def score(self): # Create the counts list # Counts[i] will be the number of times that the value i occurs in dice. # if the dice are: [3,2,5,2,3] then the counts list would be [0,0,2,2,0,1,0] counts = [0]*7 for value in self.dice: counts[value] = counts[value] + 1 # score the hand if 5 in counts: return &quot;Five of a Kind&quot; , 30 elif 4 in counts: return &quot;Four of a Kind&quot; , 15 elif (3 in counts) and (2 in counts) : return &quot;Full House&quot;, 12 elif 3 in counts: return &quot;Three of a Kind&quot;, 8 elif not (2 in counts) and (counts[1] == 0 or counts[6] == 0): return &quot;Straight&quot;, 20 elif counts.count(2) == 2: return &quot;Two Pairs&quot;, 5 else: return &quot;Garb age&quot;, 0 &ensp;&ensp;At this point, we could try out the Dice class to make sure that it is working correctly. Here is a short interaction showing some of what the class can do: 1234from dice import Diced = Dice()print(d.values())print(d.score()) 3.2 Implementing PokerApp&ensp;&ensp;Now we are ready to turn our attention to the task of actually implementing the poker game. We can use top-down design to flesh out the details and also suggest what methods will have to be implemented in the Poker Interface class. 1234567891011121314151617181920212223242526272829303132from dice import Diceclass PokerApp: def __init__(self, interface): self.dice = Dice() self.money = 100 self.interface = interface def run(self): while self.money &gt;= 10 and self.interface.wantToPlay(): self.playRound() self.interface.close() def playRound(self): self.money = self.money - 10 self.interface.setMoney(self.money) self.doRolls() result, score = self.dice.score() self. interface. showResult (result, score) self.money = self.money + score self.interface.setMoney(self.money) def doRolls(self): self.dice.rollAll() roll = 1 self.interface.setDice(self.dice.values()) toRoll = self.interface.chooseDice() while roll &lt; 3 and toRoll != []: self.dice.roll(toRoll) roll = roll + 1 self.interface.setDice(self.dice.values()) if roll &lt; 3: toRoll = self.interface.chooseDice() 3.3 A Text-Based Ul&ensp;&ensp;In designing PokerApp, we have also developed a specification for a generic Pokerinterface class. Our interface must support the methods for displaying information: setMoney, setDice, and showResul t. It must also have methods that allow for input from the user: wantToPlay and chooseDice. These methods can be implemented in many different ways, producing programs that look quite different even though the underlying model, PokerApp, remains the same. 12345678910111213141516171819202122class TextInterface: def __init__(self): print(&quot;Welcome to video poker.&quot;) def setMoney(self, amt): print(&quot;You currently have $&#123;0&#125;.&quot;.format(amt)) def setDice(self, values): print(&quot;Dice:&quot;, values) def wantToPlay(self): ans = input(&quot;Do you wish to try your luck? &quot;) return ans[0] in &quot;yY&quot; def close(self): print(&quot;\nThanks for playing!&quot;) def showResult(self, msg, score): print(&quot;&#123;0&#125;. You win $&#123;1&#125;.&quot;.format(msg, score)) def chooseDice(self): return eval(input(&quot;Enter list of which to change ([] to stop) &quot;)) &ensp;&ensp;Using this interface, we can test out our PokerApp program to see whether we have implemented a correct model. Here is a complete program making use of the modules that we have developed: 123456from pokerapp import PokerAppfrom textpoker import TextInterfaceinter = TextInterface()app = PokerApp(inter)app.run() &ensp;&ensp;Basically, all this program does is create a text -based interface and then build a PokerApp using this interface and start it running. Instead of creating a separate module for this, we could also just add the necessary launching code at the end of our textpoker module. When running this program, we get a rough but usable interaction: 1234567891011121314151617181920212223242526272829Welcome to video poker.Do you wish to try your luck? yYou currently have $90 .Dice: [6 , 4, 4, 2, 4]Enter list of which to change ([] to stop) [0 ,4]Dice: [1, 4, 4, 2, 2]Enter list of which to change ([] to stop) [0]Dice: [2 , 4, 4, 2, 2]Full House. You win $12.You currently have $102 .Do you wish to try your luck? yYou currently have $92 .Dice: [5 , 6, 4, 4, 5]Enter list of which to change ( [] to stop) [1]Dice: [5&apos; 5&apos; 4&apos; 4&apos; 5]Enter list of which to change ( [] to stop) []Full House. You win $12.You currently have $104 .Do you wish to try your luck? yYou currently have $94 .Dice: [3&apos; 2, 1, 1, 1]Enter list of which to change ( [] to stop) [0&apos; 1]Dice: [5&apos; 6&apos; 1, 1, 1]Enter list of which to change ( [] to stop) [0&apos; 1]Dice: [1&apos; 5&apos; 1, 1, 1]Four of a Kind. You win $15.You currently have $109 .Do you wish to try your luck? nThanks for playing! &ensp;&ensp;You can see how this interface provides just enough so that we can test out the model. In fact, we’ve got a game that’s already quite a bit of fun to play! 4. Developing a GUI&ensp;&ensp;Now that we have a working program, let’s turn our attention to a graphical interface. Our first step must be to decide exactly how we want our interface to look and function. The interface will have to support the various methods found in the text-based version and will also probably have some additional helper methods. 4.1 Designing the Interaction&ensp;&ensp;Let’s start with the basic methods that must be supported and decide exactly how interaction with the user will occur. Clearly, in a graphical interface, the faces of the dice and the current score should be continuously displayed. The setDice and setMoney methods will be used to change those displays. That leaves one output method, showResult, that we need to accommodate. One common way to handle this sort of transient information is with a message at the bottom of the window. This is sometimes called a status bar.&ensp;&ensp;To get information from the user, we will make use of buttons. In wantToPlay, the user will have to decide between either rolling the dice or quitting. We could include “Roll Dice” and “Quit” buttons for this choice. That leaves us with figuring out how the user should choose dice.&ensp;&ensp;To implement chooseDice, we could provide a button for each die and have the user click the buttons for the dice they want to roll. When the user is done choosing the dice, they could click the “Roll Dice” button again to roll the selected dice. Elaborating on this idea, it would be nice if we allowed the user to change his or her mind while selecting the dice. Perhaps clicking the button of a currently selected die would cause it to become deselected. The clicking of the button will serve as a sort of toggle that selects/unselects a particular die. The user commits to a certain selection by clicking on “Roll Dice.”&ensp;&ensp;Our vision for chooseDice suggests a couple of tweaks for the interface. First, we should have some way of showing the user which dice are currently selected. There are lots of ways we could do this. One simple approach would be to change the color of the dice. Let’s “gray out” the pips on the dice selected for rolling. Second, we need a good way for the user to indicate that they wish to stop rolling. That is, they would like the dice scored just as they stand. We could handle this by having them click the “Roll Dice” button when no dice are selected, hence asking the program to roll no dice. Another approach would be to provide a separate button to click that causes the dice to be scored. The latter approach seems a bit more intuitive/informative. Let’s add a “Score” button to the interface.&ensp;&ensp;Now we have a basic idea of how the interface will function. We still need to figure out how it will look. What is the exact layout of the widgets? The figure above is a sample of how the interface might look. I’m sure those of you with a more artistic eye can come up with a more pleasing interface, but we’ll use this one as our working design. 4.2 Managing the Widgets&ensp;&ensp;The graphical interface that we are developing makes use of buttons and dice. Our intent is to reuse the Button and DieView classes. Button This class needs the graphics class that we developed in previous exercise. 1234567891011121314151617181920212223242526272829303132333435363738394041from graphics import *class Button: &quot;&quot;&quot; A button is a labeled rectangle in a window. It is activated or deactivated with the activate() and deactivate() methods.The clicked(p) method returns true if the button is active and pi s inside it. &quot;&quot;&quot; def __init__(self, win, center, width, height, label): w,h = width/2.0, height/2.0 x = center.getX() y = center.getY() self.xmax, self.xmin = x + w, x - w self.ymax, self.ymin = y + h, y - h p1 = Point(self.xmin, self.ymin) p2 = Point(self.xmax, self.ymax) self.rect = Rectangle(p1, p2) self.rect.setFill(&apos;gray&apos;) self.rect.draw(win) self.label = Text(center, label) self.label.draw(win) self.deactivate() def clicked(self, p): return (self.active and self.xmin &lt;= p.getX() &lt;= self.xmax and self.ymin &lt;= p.getY() &lt;= self.ymax) def getLabel(self): return self.label.getText() def activate(self): self.label.setFill(&apos;black&apos;) self.rect.setWidth(2) self.active = True def deactivate(self): self.label.setFill(&quot;gray&quot;) self.rect.setWidth(1) self.active = False DieView the class constructor draws a square and seven circles to represent the positions where the pips of various values will appear. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from graphics import *class DieView: &quot;&quot;&quot; DieView is a widget that displays a graphical representation of a standard six-sided die. &quot;&quot;&quot; def __init__(self, win, center, size): &quot;&quot;&quot;Create a view of a die, e.g. : d1 = GDie(myWin, Point (40,50) , 20) creates a die centered at (40,50) having sides of length 20.&quot;&quot;&quot; # first define some standard values self.win = win self.background = &quot;white&quot; # color of die face self.foreground = &quot;black&quot; # color of the pips self.psize = 0.1 * size #radius of each pip hsize = size/2.0 # half of size offset = 0.6 * hsize # distance from center to outer pips # create a square for the face cx, cy = center.getX(), center.getY() p1 = Point(cx - hsize, cy - hsize) p2 = Point(cx + hsize, cy + hsize) rect = Rectangle(p1, p2) rect.draw(win) rect.setFill(self.background) # Create 7 circles for standard pip locations self.pips = [self.__makePip(cx - offset, cy - offset), self.__makePip(cx - offset, cy), self.__makePip(cx - offset, cy + offset), self.__makePip(cx, cy), self.__makePip(cx + offset, cy - offset), self.__makePip(cx + offset, cy), self.__makePip(cx + offset, cy + offset)] # Create a table for which pips are on for each value self.onTable = [[], [3], [2, 4], [2, 3, 4], [0, 2, 4, 6],[0,2,3,4,6],[0, 1, 2, 4, 5, 6]] self.setValue(1) def __makePip(self, x, y): &quot;&quot;&quot;Internal helper method to draw a pip at(x, y)&quot;&quot;&quot; pip = Circle(Point(x, y), self.psize) pip.setFill(self.background) pip.setOutline(self.background) pip.draw(self.win) return pip def setValue(self, value): &quot;&quot;&quot; Set this die to display value.&quot;&quot;&quot; # Turn all the pips off for pip in self.pips: pip.setFill(self.background) # Turn the appropriate pips back on for i in self.onTable[value]: self.pips[i].setFill(self.foreground)class ColorDieView(DieView): def setValue(self, value): self.value = value DieView.setValue(self, value) def setColor(self, color): self.foreground = color self.setValue(self.value) 4.3 Creating the Interface&ensp;&ensp;Now that we have our widgets under control, we are ready to actually implement our GUI poker interface. The constructor will create all of our widgets, setting up the interface for later interactions: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122from button import Buttonfrom graphics import *from dieview2 import DieView, ColorDieViewfrom dice import Diceclass Graphicsinterface: def __init__(self): self.win = GraphWin(&quot;Dice Poker&quot;, 600, 400) self.win.setBackground(&quot;green3&quot;) banner = Text(Point(300, 30), &quot;Python Poker Parlor&quot;) banner.setSize(24) banner.setFill(&quot;yellow2&quot;) banner.setStyle(&quot;bold&quot;) banner.draw(self.win) self.msg = Text(Point(300, 380), &quot;Welcome to the Dice Table&quot;) self.msg.setSize(18) self.msg.draw(self.win) self.createDice(Point(300, 100), 75) self.buttons = [] self.addDiceButtons(Point(300, 170), 75, 30) b = Button(self.win, Point(300, 230), 400, 40, &quot;Roll Dice&quot;) self.buttons.append(b) b = Button(self.win, Point(300, 280), 150, 40, &quot;Score&quot;) self.buttons.append(b) b = Button(self.win, Point(570, 375), 40, 30, &quot;Quit&quot;) self.buttons.append(b) self.money = Text(Point(300, 325), &quot;$100&quot;) self.money.setSize(18) self.money.draw(self.win) def choose(self, choices): buttons = self.buttons # activate choice buttons, deactivate others for b in buttons: if b.getLabel() in choices: b.activate() else: b.deactivate() # get mouse clicks unt il an active button is clicked while True: p = self.win.getMouse() for b in buttons: if b.clicked(p): return b.getLabel() # function ex it here. def setValue(self, value): # Turn all the pips off for pip in self.pips: pip.setFill(self.background) # Turn the appropriate pips back on for i in self.onTable[value]: self.pips[i].setFill(self.foreground) def createDice(self, center, size): center.move(-3 * size, 0) self.dice = [] for i in range(5): view = ColorDieView(self.win, center, size) self.dice.append(view) center.move(1.5 * size, 0) def setColor(self, color): self.foreground = color self.setValue(self.value) def addDiceButtons(self, center, width, height): center.move(-3 * width, 0) for i in range(1, 6): label = &quot;Die &#123;0&#125;&quot;.format(i) b = Button(self.win, center, width, height, label) self.buttons.append(b) center.move(1.5 * width, 0) def setMoney(self, amt): self.money.setText(&quot;$&#123;0&#125;&quot;.format(amt)) def showResult(self, msg, score): if score &gt; 0: text = &quot;&#123;0&#125; ! You win $&#123;1&#125;&quot;.format(msg, score) else: text = &quot;You rolled &#123;0&#125;&quot;.format(msg) self.msg.setText(text) def setDice(self, values): for i in range(5): self.dice[i].setValue(values[i]) def wantToPlay(self): ans = self.choose([&quot;Roll Dice&quot;, &quot;Quit&quot;]) self.msg.setText(&quot;&quot;) return ans == &quot;Roll Dice&quot; def chooseDice(self): # choices is a list of the indexes of the selected dice choices = [] # No dice chosen yet while True: # wait for user to click a valid button b = self.choose([&quot;Die 1&quot;, &quot;Die 2&quot;, &quot;Die 3&quot;, &quot;Die 4&quot;, &quot;Die 5&quot;, &quot;Roll Dice&quot;, &quot;Score&quot;]) if b[0] == &quot;D&quot;: i = int(b[4]) - 1 if i in choices: choices.remove(i) self.dice[i].setColor(&quot;black&quot;) else: choices.append(i) self.dice[i].setColor(&quot;gray&quot;) else: for d in self.dice: d.setColor(&quot;black&quot;) if b == &quot;Score&quot;: return [] elif choices != []: return choices def close(self): self.win.close() &ensp;&ensp;Finally, we need a few lines to actually get our graphical poker-playing program started. This code is exactly like the start code for the textual version, except that we use a Graphicsinterface in place of the Textinterface: 123456from graphicspoker import Graphicsinterfacefrom pokerapp import PokerAppinter = Graphicsinterface()app = PokerApp(inter)app.run() 5. The Completed Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290from graphics import *from random import randrangefrom random import *class Dice: def __init__(self): self.dice = [0]*5 self.rollAll() def roll(self, which): for pos in which: self.dice[pos] = randrange(1, 7) def rollAll(self): self.roll(range(5)) def values(self): return self.dice[:] def score(self): # Create the counts list # Counts[i] will be the number of times that the value i occurs in dice. # if the dice are: [3,2,5,2,3] then the counts list would be [0,0,2,2,0,1,0] counts = [0]*7 for value in self.dice: counts[value] = counts[value] + 1 # score the hand if 5 in counts: return &quot;Five of a Kind&quot; , 30 elif 4 in counts: return &quot;Four of a Kind&quot; , 15 elif (3 in counts) and (2 in counts) : return &quot;Full House&quot;, 12 elif 3 in counts: return &quot;Three of a Kind&quot;, 8 elif not (2 in counts) and (counts[1] == 0 or counts[6] == 0): return &quot;Straight&quot;, 20 elif counts.count(2) == 2: return &quot;Two Pairs&quot;, 5 else: return &quot;Garbage&quot;, 0class PokerApp: def __init__(self, interface): self.dice = Dice() self.money = 100 self.interface = interface def run(self): while self.money &gt;= 10 and self.interface.wantToPlay(): self.playRound() self.interface.close() def playRound(self): self.money = self.money - 10 self.interface.setMoney(self.money) self.doRolls() result, score = self.dice.score() self. interface. showResult (result, score) self.money = self.money + score self.interface.setMoney(self.money) def doRolls(self): self.dice.rollAll() roll = 1 self.interface.setDice(self.dice.values()) toRoll = self.interface.chooseDice() while roll &lt; 3 and toRoll != []: self.dice.roll(toRoll) roll = roll + 1 self.interface.setDice(self.dice.values()) if roll &lt; 3: toRoll = self.interface.chooseDice()class Button: def __init__(self, win, center, width, height, label): w,h = width/2.0, height/2.0 x = center.getX() y = center.getY() self.xmax, self.xmin = x + w, x - w self.ymax, self.ymin = y + h, y - h p1 = Point(self.xmin, self.ymin) p2 = Point(self.xmax, self.ymax) self.rect = Rectangle(p1, p2) self.rect.setFill(&apos;gray&apos;) self.rect.draw(win) self.label = Text(center, label) self.label.draw(win) self.deactivate() def clicked(self, p): return (self.active and self.xmin &lt;= p.getX() &lt;= self.xmax and self.ymin &lt;= p.getY() &lt;= self.ymax) def getLabel(self): return self.label.getText() def activate(self): self.label.setFill(&apos;black&apos;) self.rect.setWidth(2) self.active = True def deactivate(self): self.label.setFill(&quot;gray&quot;) self.rect.setWidth(1) self.active = Falseclass DieView: &quot;&quot;&quot; DieView is a widget that displays a graphical representation of a standard six-sided die.&quot;&quot;&quot; def __init__(self, win, center, size): &quot;&quot;&quot;Create a view of a die, e.g. : d1 = GDie(myWin, Point (40,50) , 20) creates a die centered at (40,50) having sides of length 20.&quot;&quot;&quot; # first define some standard values self.win = win self.background = &quot;white&quot; # color of die face self.foreground = &quot;black&quot; # color of the pips self.psize = 0.1 * size #radius of each pip hsize = size/2.0 # half of size offset = 0.6 * hsize # distance from center to outer pips # create a square for the face cx, cy = center.getX(), center.getY() p1 = Point(cx - hsize, cy - hsize) p2 = Point(cx + hsize, cy + hsize) rect = Rectangle(p1, p2) rect.draw(win) rect.setFill(self.background) # Create 7 circles for standard pip locations self.pips = [self.__makePip(cx - offset, cy - offset), self.__makePip(cx - offset, cy), self.__makePip(cx - offset, cy + offset), self.__makePip(cx, cy), self.__makePip(cx + offset, cy - offset), self.__makePip(cx + offset, cy), self.__makePip(cx + offset, cy + offset)] # Create a table for which pips are on for each value self.onTable = [[], [3], [2, 4], [2, 3, 4], [0, 2, 4, 6],[0,2,3,4,6],[0, 1, 2, 4, 5, 6]] self.setValue(1) def __makePip(self, x, y): &quot;&quot;&quot;Internal helper method to draw a pip at(x, y)&quot;&quot;&quot; pip = Circle(Point(x, y), self.psize) pip.setFill(self.background) pip.setOutline(self.background) pip.draw(self.win) return pip def setValue(self, value): &quot;&quot;&quot; Set this die to display value.&quot;&quot;&quot; # Turn all the pips off for pip in self.pips: pip.setFill(self.background) # Turn the appropriate pips back on for i in self.onTable[value]: self.pips[i].setFill(self.foreground)class ColorDieView(DieView): def setValue(self, value): self.value = value DieView.setValue(self, value) def setColor(self, color): self.foreground = color self. setValue(self.value)class Graphicsinterface: def __init__(self): self.win = GraphWin(&quot;Dice Poker&quot;, 600, 400) self.win.setBackground(&quot;green3&quot;) banner = Text(Point(300, 30), &quot;Python Poker Parlor&quot;) banner.setSize(24) banner.setFill(&quot;yellow2&quot;) banner.setStyle(&quot;bold&quot;) banner.draw(self.win) self.msg = Text(Point(300, 380), &quot;Welcome to the Dice Table&quot;) self.msg.setSize(18) self.msg.draw(self.win) self.createDice(Point(300, 100), 75) self.buttons = [] self.addDiceButtons(Point(300, 170), 75, 30) b = Button(self.win, Point(300, 230), 400, 40, &quot;Roll Dice&quot;) self.buttons.append(b) b = Button(self.win, Point(300, 280), 150, 40, &quot;Score&quot;) self.buttons.append(b) b = Button(self.win, Point(570, 375), 40, 30, &quot;Quit&quot;) self.buttons.append(b) self.money = Text(Point(300, 325), &quot;$100&quot;) self.money.setSize(18) self.money.draw(self.win) def choose(self, choices): buttons = self.buttons # activate choice buttons, deactivate others for b in buttons: if b.getLabel() in choices: b.activate() else: b.deactivate() # get mouse clicks unt il an active button is clicked while True: p = self.win.getMouse() for b in buttons: if b.clicked(p): return b.getLabel() # function ex it here. def setValue(self, value): # Turn all the pips off for pip in self.pips: pip.setFill(self.background) # Turn the appropriate pips back on for i in self.onTable[value]: self.pips[i].setFill(self.foreground) def createDice(self, center, size): center.move(-3 * size, 0) self.dice = [] for i in range(5): view = ColorDieView(self.win, center, size) self.dice.append(view) center.move(1.5 * size, 0) def setColor(self, color): self.foreground = color self.setValue(self.value) def addDiceButtons(self, center, width, height): center.move(-3 * width, 0) for i in range(1, 6): label = &quot;Die &#123;0&#125;&quot;.format(i) b = Button(self.win, center, width, height, label) self.buttons.append(b) center.move(1.5 * width, 0) def setMoney(self, amt): self.money.setText(&quot;$&#123;0&#125;&quot;.format(amt)) def showResult(self, msg, score): if score &gt; 0: text = &quot;&#123;0&#125; ! You win $&#123;1&#125;&quot;.format(msg, score) else: text = &quot;You rolled &#123;0&#125;&quot;.format(msg) self.msg.setText(text) def setDice(self, values): for i in range(5): self.dice[i].setValue(values[i]) def wantToPlay(self): ans = self.choose([&quot;Roll Dice&quot;, &quot;Quit&quot;]) self.msg.setText(&quot;&quot;) return ans == &quot;Roll Dice&quot; def chooseDice(self): # choices is a list of the indexes of the selected dice choices = [] # No dice chosen yet while True: # wait for user to click a valid button b = self.choose([&quot;Die 1&quot;, &quot;Die 2&quot;, &quot;Die 3&quot;, &quot;Die 4&quot;, &quot;Die 5&quot;, &quot;Roll Dice&quot;, &quot;Score&quot;]) if b[0] == &quot;D&quot;: i = int(b[4]) - 1 if i in choices: choices.remove(i) self.dice[i].setColor(&quot;black&quot;) else: choices.append(i) self.dice[i].setColor(&quot;gray&quot;) else: for d in self.dice: d.setColor(&quot;black&quot;) if b == &quot;Score&quot;: return [] elif choices != []: return choices def close(self): self.win.close()def main(): inter = Graphicsinterface() app = PokerApp(inter) app.run()if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BST Summary]]></title>
    <url>%2F2018%2F10%2F29%2F2018%2F2018-10-29-bst-summary%2F</url>
    <content type="text"><![CDATA[Data Structure – BST1. 定义：BST(Binary Search Tree)或者是一棵空树，或者是具有下列性质的二叉树： 若左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若右子树不空，则右子树上所有结点的值均大于它的根结点的值； 左、右子树也分别为二叉排序树； 没有键值相等的节点。 2.基本操作主要包括：查找、插入、建立、删除1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798struct node &#123; int data; node *lchild; node *rchild;&#125;;// 新建节点，返回一个节点指针node* newNode(int v)&#123; node* Node = new node; Node-&gt;data = v; Node-&gt;lchild = Node-&gt;rchild = NULL; return Node;&#125;// search x 只需搜索一边子树即可,O(h) h表示树高void search(node* root, int x)&#123; if(root == NULL) &#123; printf(&quot;search failed!\n&quot;); return; &#125; if(x == root-&gt;data) printf(&quot;%d\n&quot;, root-&gt;data); else if(x &lt; root-&gt;data) search(root-&gt;lchild, int x); else search(root-&gt;rchild, int x);&#125;// insert x 当root==NULL时，即为插入之处 O(h)void insert(node* &amp;root, int x)&#123; if(root == NULL)&#123; root = newNode(x); return; &#125; if(x == root-&gt;data) return; else if(x &lt; root-&gt;data) insert(root-&gt;lchild, x); else insert(root-&gt;rchild, x);&#125;// BST的建立(注意：同一组数据，如果插入的顺序不同最后形成的BST可能也不同)// 复杂度O(h)*n = O(nlog2n)node *Create(int data[], int n)&#123; node* root = NULL; for (int i = 0; i &lt; n; ++i) &#123; insert(root, data[i]); &#125; return root;&#125;//BST的节点删除，删除根节点//删除根节点后，用直接后继或者直接前驱来替换//直接前驱：左子树一直向右直到某一节点的右子树为NULL的节点//直接后继：右子树一直向左直到某一节点的左子树为NULL的节点//FindMin()函数用于寻找树root的最小权值节点node* FindMin(node* root)&#123; while(root-&gt;lchild != NULL) root = root-&gt;lchild; return root;&#125;//FindMax()函数用于寻找树root的最大权值节点node* FindMax(node* root)&#123; while(root-&gt;rchild != NULL) root = root-&gt;rchild; return root;&#125;/*BST删除节点步骤:1. 当前节点root空，直接返回2. 当前节点root的data值等于x，进入删除操作 a)当前节点root为叶子节点，直接删除。 b)当前节点root存在左子树，找到前驱pre，覆盖root，删除pre c)当前节点root存在右子树，找到后继next，覆盖root，删除next3. 若当前节点root权值大于x，则root = root-&gt;lchild 递归删除4. 若当前节点root权值小于x，则root = root-&gt;rchild 递归删除*/void deleteNode(node* &amp;root, int x)&#123; if(root == NULL) return; if(root-&gt;data == x) &#123; if(root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) root = NULL; else if(root-&gt;lchild != NULL) &#123; node *pre = FindMax(root-&gt;lchild); root-&gt;data = pre-&gt;data; deleteNode(root-&gt;lchild, pre-&gt;data); //删除pre节点 &#125; else &#123; node* next = FindMin(root-&gt;rchild); root-&gt;data = next-&gt;data; deleteNode(root-&gt;rchild, next-&gt;data); //删除next 节点 &#125; &#125; else if(root-&gt;data &gt; x) deleteNode(root-&gt;lchild, x); else deleteNode(root-&gt;rchild, x);&#125; 3. 应用利用PAT1043_Is It a Binary Search Tree 来练习一下BST。 1043 Is It a Binary Search Tree （25 分）A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. If we swap the left and right subtrees of every node, then the resulting tree is called the Mirror Image of a BST.Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST. Input Specification: Each input file contains one test case. For each case, the first line contains a positive integer N (≤1000). Then N integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification: For each test case, first print in a line YES if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or NO if not. Then if the answer is YES, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1:1278 6 5 7 10 8 11 Sample Output 1:12YES5 7 6 8 11 10 8 Sample Input 2:1278 10 11 8 6 7 5 Sample Output 2:12YES11 8 10 7 5 6 8 Sample Input 3:1278 6 8 5 10 9 11 Sample Output 3:1NO Code and Analysis:(1) 题意：判断给定序列是不是BST或者BST的镜像的先序遍历序列。是，输出YES和后序遍历序列；否，输出NO结束。(2) 思路步骤： 对给定的序列建立BST 对BST先序遍历，后序遍历，BST镜像先序遍历，BST镜像后序遍历 将给定序列与BST先序遍历，BST镜像先序遍历比较，相等，输出YES和对应后序序列，不相等，输出NO。 (3) 数据结构：用vector存储给定序列origin, BST先序序列pre, BST后序序列post, BST镜像先序序列preM, BST镜像后序序列postM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;struct node&#123; int data; node* lchild; node* rchild;&#125;;void insert(node* &amp;root, int x)&#123; if(root == NULL) &#123; root = new node; root-&gt;data = x; root-&gt;lchild = root-&gt;rchild = NULL; return; &#125; else if(root-&gt;data &gt; x) insert(root-&gt;lchild, x); else insert(root-&gt;rchild, x);&#125;// 先序遍历：中左右 --- 镜像先序遍历：中右左// 后序遍历：左右中 --- 镜像后序遍历：右左中// 中序遍历：左中右 --- 镜像中序遍历：右中左void preOrder(node* root, vector&lt;int&gt;&amp;vi)&#123; if(root == NULL) return; vi.push_back(root-&gt;data); preOrder(root-&gt;lchild, vi); preOrder(root-&gt;rchild, vi);&#125;void preMirror(node* root, vector&lt;int&gt;&amp;vi)&#123; if(root == NULL) return; vi.push_back(root-&gt;data); preMirror(root-&gt;rchild, vi); preMirror(root-&gt;lchild, vi);&#125;void postOrder(node* root, vector&lt;int&gt;&amp;vi)&#123; if(root == NULL) return; postOrder(root-&gt;lchild, vi); postOrder(root-&gt;rchild, vi); vi.push_back(root-&gt;data);&#125;void postMirror(node* root, vector&lt;int&gt;&amp;vi)&#123; if(root == NULL) return; postMirror(root-&gt;rchild, vi); postMirror(root-&gt;lchild, vi); vi.push_back(root-&gt;data);&#125;vector&lt;int&gt; origin, pre, post, preM, postM;int main(int argc, char const *argv[])&#123; int n, data; node* root = new node; root = NULL; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, &amp;data); origin.push_back(data); insert(root, data); &#125; preOrder(root, pre); preMirror(root, preM); postOrder(root, post); postMirror(root, postM); if(origin == pre)&#123; printf(&quot;YES\n&quot;); for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d&quot;,post[i]); if(i &lt; n-1) printf(&quot; &quot;); &#125; &#125; else if(origin == preM)&#123; printf(&quot;YES\n&quot;); for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d&quot;, postM[i]); if(i &lt; n-1) printf(&quot; &quot;); &#125; &#125; else printf(&quot;NO\n&quot;); return 0;&#125;/*78 6 5 7 10 8 11 */]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>PAT</tag>
        <tag>Traversal</tag>
        <tag>Order</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise5]]></title>
    <url>%2F2018%2F10%2F28%2FExercise5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这是我们老师布置的作业，以下是我的一些总结。 1. Programming Exercise Modify the cannonball simulation from the chapter so that it also calculates the maximum height achieved by the cannonball. Program Specification Suppose we want to write a program that simulates the flight of a cannonball (or any other projectile such as a bullet, baseball, or shot put). We are particularly interested in finding out how far the cannonball will travel when fired at various launch angles and initial velocities. The input to the program will be the launch angle (in degrees), the initial velocity (in meters per second), and the initial height (in meters) of the cannonball. The output will be the distance that the projectile travels before striking the ground (in meters). In addition, the program also can calculate the maximum height. 2. Code and Analysis2.1 The First Version&ensp;&ensp;Let’s start by designing an algorithm. Given the problem statement, it’s clear that we need to consider the flight of the cannonball in two dimensions: height, so we know when it hits the ground; and distance, to keep track of how far it goes. We can think of the position of the cannonball as a point ( x, y) in a 2D graph where the value of y gives the height above the ground and the value of x gives the distance from the starting point. &ensp;&ensp;The Projectile class must have an init method that uses these values to initialize the instance variables of cball. But what should the instance variables be? Of course, they will be the four pieces of information that characterize the flight of the cannonball: xpos, ypos, xvel, yvel and MaxHeight. &ensp;&ensp; Notice how we have created five instance variables inside the object using the self dot notation. The value of theta is not needed after ini t terminates, so it is just a normal (local) function variable. The methods for accessing the position of our projectiles are straightforward; the current position is given by the instance variables xpos, ypos and MaxHeight. We just need a couple of methods that return these values. &ensp;&ensp;Finally, we come to the update method. This method takes a single normal parameter that represents an interval of time. We need to update the state of the projectile to account for the passage of that much time. Here’s the code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from math import sin, cos, radiansclass Projectile: def __init__(self, angle, velocity, height): self.xpos = 0.0 self.ypos = height theta = radians(angle) self.xvel = velocity * cos(theta) self.yvel = velocity * sin(theta) self.MaxHeight = self.ypos def update(self, time): self.xpos = self.xpos + time * self.xvel yvel1 = self.yvel - 9.8 * time self.ypos = self.ypos + time * (self.yvel + yvel1) / 2.0 self.yvel = yvel1 if self.ypos &gt; self.MaxHeight: self.MaxHeight = self.ypos def getY(self): return self.ypos def getX(self): return self.xpos def getMaxHeight(self): return self.MaxHeightdef getInputs(): a = float(input(&quot;Enter the launch angle (in degrees): &quot;)) v = float(input(&quot;Enter the initial velocity (in meters/sec): &quot;)) h = float(input(&quot;Enter the initial height (in meters): &quot;)) t = float(input(&quot;Enter the time interval between position calculations: &quot;)) return a, v, h, tdef main(): angle, vel, h0, time = getInputs() cball = Projectile(angle, vel, h0) cball.update(time) while cball.getY() &gt;= 0: cball.update(time) print(&quot;\nDistance traveled: &#123;0:0.1f&#125; meters.&quot;. format(cball.getX())) print(cball.xvel) print(cball.getMaxHeight())if __name__ == &quot;__main__&quot;: main() 2.2 The Second Version&ensp;&ensp;Based on the first version, let’s use our new object ideas to add a nicer interface to the cannonball example that started the chapter. Instead of having a boring text -based interface, the program would be more fun to use if it had a graphical interface. It would be nice to actually “see” where the canonball ends up and how it gets there. Figure 10.4 shows what I have in mind. Here you can see a cannonball currently in flight as well as where two previous shots ended. 2.2.1 Creating a Graphics Window&ensp;&ensp;The first step in the program is to create a graphics window and draw the appropriate scale line across the bottom. Using our graphics library; this is straightforward. Here’s the start of the program:123456789101112def main(): # create animation window win = GraphWin(&quot;Projectile Animation&quot;, 640, 480, autoflush = False) win.setCoords(-10, -10, 210, 155) # draw baseline Line(Point(-10, 0), Point(210, 0)).draw(win) # draw labeled tricks every 50 meters for x in range(0, 210, 50): Text(Point(x, -5), str(x)).draw(win) Line(Point(x, 0), Point(x, 2)).draw(win) 2.2.2 ShotTracker Class&ensp;&ensp;The next thing we need is a graphical object that acts like a cannonball. We can use our existing Projectile class to model the flight of a cannonball, but a Projectile is not a graphics object; we can’t draw it in the window. On the other hand, a Circle is a good candidate for the graphical representation of the cannonball, but it does not know how to model projectile flight. What we really want is something that has elements of both. We can create this new hybrid circle-projectile by defining a suitable class for it. Let’s call it a ShotTracker. &ensp;&ensp;Our Shot Tracker will contain both a Projectile and a Circle. Its job is to make sure that these instance variables stay in sync with each other. &ensp;&ensp;Notice how the parameters provide all of the information needed to create both a Projectile and a Circle, which are stored in the instance variables proj and marker, respectively. I used the name marker because the circle is graphically marking the projectile’s current location. I chose the radius 3 because it shows up nicely in the animation. Realistically, a 3-meter radius would be way too large for an actual cannonball. Now that we have a suitable projectile and circle, we just need to ensure that whenever an update occurs, both the projectile and the position of the circle are modified appropriately. We can do that by giving our ShotTracker an update method that handles both pieces. Updating the Projectile object is a simple matter of calling its own update method with the appropriate time interval. For the circle, we calculate the distance it must move in the x and y directions to put the center of the circle where the updated projectile is located. 12345678910111213141516171819202122232425262728293031323334353637class ShotTracker(object): def __init__(self, win, angle, velocity, height): &quot;&quot;&quot; win is the GraphWin to display the shot. angle, velocity, and height are initial projectile parameters. &quot;&quot;&quot; self.proj = Projectile(angle, velocity, height) self.marker = Circle(Point(0, height), 3) self.marker.setFill(&quot;red&quot;) self.marker.setOutline(&quot;red&quot;) self.marker.draw(win) def update(self, dt): &quot;&quot;&quot; Move the shot dt seconds farther along its flight &quot;&quot;&quot; # update the projectile self.proj.update(dt) # move the circle to the new projectile location center = self.marker.getCenter() dx = self.proj.getX() - center.getX() dy = self.proj.getY() - center.getY() self.marker.move(dx, dy) def getX(self): return self.proj.getX() def getY(self): return self.proj.getY() def getMaxHeight(self): return self.proj.getMaxHeight() def undraw(self): self.marker.undraw() 2.2.3 Creating a Button Class&ensp;&ensp;Our buttons will support the following methods: constructor Creates a button in a window. We will have to specify the window in which the button will be displayed, the location/size of the button, and the label that will be on the button. activate Sets the state of the button to active. deactivate Sets the state of the button to inactive. clicked Indicates whether the button was clicked. If the button is active, this method will determine if the point clicked is inside the button region. The point will have to be sent as a parameter to the method. getLabel Returns the label string of the button. This is provided so that we can identify a particular button.Here’s the code:1234567891011121314151617181920212223242526272829303132class Button: def __init__(self, win, center, width, height, label): w,h = width/2.0, height/2.0 x = center.getX() y = center.getY() self.xmax, self.xmin = x + w, x - w self.ymax, self.ymin = y + h, y - h p1 = Point(self.xmin, self.ymin) p2 = Point(self.xmax, self.ymax) self.rect = Rectangle(p1, p2) self.rect.setFill(&apos;gray&apos;) self.rect.draw(win) self.label = Text(center, label) self.label.draw(win) self.deactivate() def clicked(self, p): return (self.active and self.xmin &lt;= p.getX() &lt;= self.xmax and self.ymin &lt;= p.getY() &lt;= self.ymax) def getLabel(self): return self.label.getText() def activate(self): self.label.setFill(&apos;black&apos;) self.rect.setWidth(2) self.active = True def deactivate(self): self.label.setFill(&quot;gray&quot;) self.rect.setWidth(1) self.active = False 2.2.4 Creating an Input Dialog&ensp;&ensp;Before we actually put a cannonball in flight, we’ll need to get the projectile parameters angle, velocity, and initial height from the user. We could do this using input, just as in the original program. But as long as we’re designing a graphical interface, we may as well handle the input in a more graphical fashion as well. A common way of getting user input in a GUI is to use a dialog box. For example, in Chapter 5 I discussed using pre-built system dialogs that allow users to select file names. Using the graphics library, we can easily create our own simple dialogs to get information from the user. A dialog box is a sort of miniGUI that serves as an independent component of a larger program. Something like Figure 10.5 will do the trick. The user can change the input values and select either “Fire!” to launch the cannonball or “Quit” to exit the program. As you can see, this is just a Graph Win containing a few Text, Entry, and Button objects.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class InputDialog: def __init__(self, angle, vel, height): self.win = GraphWin(&quot;Initial Values&quot;, 200, 300) win = self.win win.setCoords(0, 5.5, 4, .5) Text(Point(1, 1), &quot;Angle&quot;).draw(win) self.angle = Entry(Point(3, 1), 5).draw(win) self.angle.setText(str(angle)) Text(Point(1, 2), &quot;Velocity&quot;).draw(win) self.vel = Entry(Point(3, 2), 5).draw(win) self.vel.setText(str(vel)) Text(Point(1, 3), &quot;Height&quot;).draw(win) self.height = Entry(Point(3, 3), 5).draw(win) self.height.setText(str(height)) Text(Point(1, 4), &quot;MaxHeight&quot;).draw(win) self.maxheight = Entry(Point(3, 4), 5).draw(win) self.fire = Button(win, Point(1, 5), 1.25, .5, &quot;Fire!&quot;) self.fire.activate() self.quit = Button(win, Point(3, 5), 1.25, .5, &quot;Quit&quot;) self.quit.activate() def interact(self): &quot;&quot;&quot; wait for user to click Quit or Fire button Returns a string indicating which button was clicked &quot;&quot;&quot; while True: pt = self.win.getMouse() if self.quit.clicked(pt): return &quot;Quit&quot; if self.fire.clicked(pt): return &quot;Fire!&quot; def getValues(self): a = float(self.angle.getText()) v = float(self.vel.getText()) h = float(self.height.getText()) return a, v, h def close(self): self.win.close() 2.2.5 The Main Event Loop&ensp;&ensp;Now we are ready to finish our program by filling in the main event loop. Here’s the completed main function:123456789101112131415161718192021222324252627282930313233343536def main(): # create animation window win = GraphWin(&quot;Projectile Animation&quot;, 640, 480, autoflush = False) win.setCoords(-10, -10, 210, 155) # draw baseline Line(Point(-10, 0), Point(210, 0)).draw(win) # draw labeled tricks every 50 meters for x in range(0, 210, 50): Text(Point(x, -5), str(x)).draw(win) Line(Point(x, 0), Point(x, 2)).draw(win) angle, vel, height = 45.0, 40.0, 2.0 inputwin = InputDialog(angle, vel, height) while True: # interact with the user choice = inputwin.interact() #inputwin.close() if choice == &quot;Quit&quot;: # loop exit break break angle, vel, height = inputwin.getValues() shot = ShotTracker(win, angle, vel, height) while 0 &lt;= shot.getY() &lt;=155 and -10 &lt; shot.getX() &lt;= 210: shot.update(1 / 50) update(50) inputwin.maxheight.setText(str(shot.getMaxHeight())) #inputwin.close() win.close() The completed program looks like this: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204from math import *import mathfrom turtle import *from graphics import *class Projectile(object): def __init__(self, angle, velocity, height): self.xpos = 0.0 self.ypos = height theta = math.pi * angle / 180 self.xvel = velocity * cos(theta) self.yvel = velocity * sin(theta) self.MaxHeight = self.ypos #保存最大高度 def update(self, time): self.xpos = self.xpos + time * self.xvel yvel1 = self.yvel - 9.8 * time self.ypos = self.ypos + time * (self.yvel + yvel1) / 2.0 self.yvel = yvel1 # 获取最大高度保存到Self.MaxHeight中 if self.ypos &gt; self.MaxHeight: self.MaxHeight = self.ypos def getY(self): return self.ypos def getX(self): return self.xpos def getMaxHeight(self): return self.MaxHeight# def getInputs():# a = float(input(&quot;Enter the launch angle (in degrees): &quot;))# v = float(input(&quot;Enter the initial velocity (in meters/sec): &quot;))# h = float(input(&quot;Enter the initial height (in meters): &quot;))# t = float(input(&quot;Enter the time interval between position calculations: &quot;))## return a, v, h, tclass ShotTracker(object): def __init__(self, win, angle, velocity, height): &quot;&quot;&quot; win is the GraphWin to display the shot. angle, velocity, and height are initial projectile parameters. &quot;&quot;&quot; self.proj = Projectile(angle, velocity, height) self.marker = Circle(Point(0, height), 3) self.marker.setFill(&quot;red&quot;) self.marker.setOutline(&quot;red&quot;) self.marker.draw(win) def update(self, dt): &quot;&quot;&quot; Move the shot dt seconds farther along its flight &quot;&quot;&quot; # update the projectile self.proj.update(dt) # move the circle to the new projectile location center = self.marker.getCenter() dx = self.proj.getX() - center.getX() dy = self.proj.getY() - center.getY() self.marker.move(dx, dy) def getX(self): return self.proj.getX() def getY(self): return self.proj.getY() def getMaxHeight(self): return self.proj.getMaxHeight() def undraw(self): self.marker.undraw()class Button: def __init__(self, win, center, width, height, label): w,h = width/2.0, height/2.0 x = center.getX() y = center.getY() self.xmax, self.xmin = x + w, x - w self.ymax, self.ymin = y + h, y - h p1 = Point(self.xmin, self.ymin) p2 = Point(self.xmax, self.ymax) self.rect = Rectangle(p1, p2) self.rect.setFill(&apos;gray&apos;) self.rect.draw(win) self.label = Text(center, label) self.label.draw(win) self.deactivate() def clicked(self, p): return (self.active and self.xmin &lt;= p.getX() &lt;= self.xmax and self.ymin &lt;= p.getY() &lt;= self.ymax) def getLabel(self): return self.label.getText() def activate(self): self.label.setFill(&apos;black&apos;) self.rect.setWidth(2) self.active = True def deactivate(self): self.label.setFill(&quot;gray&quot;) self.rect.setWidth(1) self.active = Falseclass InputDialog: def __init__(self, angle, vel, height): self.win = GraphWin(&quot;Initial Values&quot;, 200, 300) win = self.win win.setCoords(0, 5.5, 4, .5) Text(Point(1, 1), &quot;Angle&quot;).draw(win) self.angle = Entry(Point(3, 1), 5).draw(win) self.angle.setText(str(angle)) Text(Point(1, 2), &quot;Velocity&quot;).draw(win) self.vel = Entry(Point(3, 2), 5).draw(win) self.vel.setText(str(vel)) Text(Point(1, 3), &quot;Height&quot;).draw(win) self.height = Entry(Point(3, 3), 5).draw(win) self.height.setText(str(height)) Text(Point(1, 4), &quot;MaxHeight&quot;).draw(win) self.maxheight = Entry(Point(3, 4), 5).draw(win) self.fire = Button(win, Point(1, 5), 1.25, .5, &quot;Fire!&quot;) self.fire.activate() self.quit = Button(win, Point(3, 5), 1.25, .5, &quot;Quit&quot;) self.quit.activate() def interact(self): &quot;&quot;&quot; wait for user to click Quit or Fire button Returns a string indicating which button was clicked &quot;&quot;&quot; while True: pt = self.win.getMouse() if self.quit.clicked(pt): return &quot;Quit&quot; if self.fire.clicked(pt): return &quot;Fire!&quot; def getValues(self): a = float(self.angle.getText()) v = float(self.vel.getText()) h = float(self.height.getText()) return a, v, h def close(self): self.win.close()def main(): # create animation window win = GraphWin(&quot;Projectile Animation&quot;, 640, 480, autoflush = False) win.setCoords(-10, -10, 210, 155) # draw baseline Line(Point(-10, 0), Point(210, 0)).draw(win) # draw labeled tricks every 50 meters for x in range(0, 210, 50): Text(Point(x, -5), str(x)).draw(win) Line(Point(x, 0), Point(x, 2)).draw(win) angle, vel, height = 45.0, 40.0, 2.0 inputwin = InputDialog(angle, vel, height) while True: # interact with the user choice = inputwin.interact() #inputwin.close() if choice == &quot;Quit&quot;: # loop exit break break angle, vel, height = inputwin.getValues() shot = ShotTracker(win, angle, vel, height) while 0 &lt;= shot.getY() &lt;=155 and -10 &lt; shot.getX() &lt;= 210: shot.update(1 / 50) update(50) inputwin.maxheight.setText(str(shot.getMaxHeight())) #inputwin.close() win.close()if __name__ == &quot;__main__&quot;: main() Appendix: The graphics library summary: https://blog.csdn.net/winycg/article/details/78066044?locationNum=4&amp;fps=1]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Decision Tree]]></title>
    <url>%2F2018%2F10%2F17%2FDecisionTree%2F</url>
    <content type="text"><![CDATA[1. 什么是决策树/判定树（decision tree) &emsp;&emsp;判定树是一个类似于流程图的树结构：其中，每个内部结点表示在一个属性上的测试，每个分支代表一个属性输出，而每个树叶结点代表类或类分布。树的最顶层是根结点。决策树是分类方法中的一种。 2. 构造决策树的基本算法 2.1 熵（entropy）概念信息和抽象，如何度量&emsp;&emsp;1948年，香农提出了 ”信息熵(entropy)“的概念一条信息的信息量大小和它的不确定性有直接的关系，要搞清楚一件非常非常不确定的事情，或者是我们一无所知的事情，需要了解大量信息==&gt;信息量的度量就等于不确定性的多少 例子：猜世界杯冠军，假如一无所知，猜多少次？每个队夺冠的几率不是相等的 比特(bit)来衡量信息的多少 变量的不确定性越大，熵也就越大 2.2 决策树归纳算法（ID3）1970-1980， J.Ross. Quinlan, ID3算法选择属性判断结点信息获取量(Information Gain)：Gain(A) = Info(D) - Infor_A(D)通过A来作为节点分类获取了多少信息 同理，有：Gain(income) = 0.029, Gain(student) = 0.151, Gain(credit_rating)=0.048 所以，选择age作为第一个根节点 再对每一个表类推。 算法 ： 树以代表训练样本的单个结点开始（步骤1）。 如果样本都在同一个类，则该结点成为树叶，并用该类标号（步骤2 和3）。 否则，算法使用称为信息增益的基于熵的度量作为启发信息，选择能够最好地将样本分类的属性（步骤6）。该属性成为该结点的“测试”或“判定”属性（步骤7）。在算法的该版本中， 所有的属性都是分类的，即离散值。连续属性必须离散化。 对测试属性的每个已知的值，创建一个分枝，并据此划分样本（步骤8-10）。 算法使用同样的过程，递归地形成每个划分上的样本判定树。一旦一个属性出现在一个结点上，就不必该结点的任何后代上考虑它（步骤13）。 递归划分步骤仅当下列条件之一成立停止： (a) 给定结点的所有样本属于同一类（步骤2 和3）。 (b) 没有剩余属性可以用来进一步划分样本（步骤4）。在此情况下，使用多数表决（步骤5）。 这涉及将给定的结点转换成树叶，并用样本中的多数所在的类标记它。替换地，可以存放结 点样本的类分布。 (c) 分枝 test_attribute = a i 没有样本（步骤11）。在这种情况下，以 samples 中的多数类 创建一个树叶（步骤12） 2.3 其他算法： C4.5: Quinlan Classification and Regression Trees (CART): (L. Breiman, J. Friedman, R. Olshen, C. Stone) 共同点：都是贪心算法，自上而下(Top-down approach) 区别：属性选择度量方法不同： C4.5 （gain ratio), CART(gini index), ID3 (Information Gain)3 决策树注意点3.1 如何处理连续性变量的属性？以某个值为界限分割3.2. 树剪枝叶 （避免overfitting) 4.1 先剪枝 4.2 后剪枝 3.3. 决策树的优缺点： 优点：直观，便于理解，小规模数据集有效 缺点： 处理连续变量不好 类别较多时，错误增加的比较快 可规模性一般4.应用4.1 准备 python3.6 scikit-learn库 安装 Graphviz http://www.graphviz.org/ 配置环境变量 4.2 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import numpy as npfrom sklearn.feature_extraction import DictVectorizerimport csvfrom sklearn import treefrom sklearn import preprocessingfrom sklearn.externals.six import StringIO# Read in the csv file and put features into list of dict and list of class labelallElectronicsData = open(r&apos;AllElectronics.csv&apos;, &apos;rt&apos;)reader = csv.reader(allElectronicsData)headers = next(reader) # 存放属性名# 决策树第一步获得featureLIst（每个元素为字典）和labelList（每个元素为字符串），并字典向量化print(headers)featureList = []labelList = []for row in reader: labelList.append(row[len(row)-1]) rowDict = &#123;&#125; for i in range(1, len(row)-1): rowDict[headers[i]] = row[i] featureList.append(rowDict)print(featureList)# Vetorize features# 有多个属性时，对于每个属性是平等的，按照字典序排列，对于每个属性下的值即字典值也是平等的，按照字典排序vec = DictVectorizer()dummyX = vec.fit_transform(featureList) .toarray()print(&quot;dummyX: &quot; + str(dummyX))print(vec.get_feature_names())print(&quot;labelList: &quot; + str(labelList))# vectorize class labelslb = preprocessing.LabelBinarizer()dummyY = lb.fit_transform(labelList)print(&quot;dummyY: &quot; + str(dummyY))# Using decision tree for classification# clf = tree.DecisionTreeClassifier()clf = tree.DecisionTreeClassifier(criterion=&apos;entropy&apos;)clf = clf.fit(dummyX, dummyY)print(&quot;clf: &quot; + str(clf))# Visualize modelwith open(&quot;allElectronicInformationGainOri.dot&quot;, &apos;w&apos;) as f: f = tree.export_graphviz(clf, feature_names=vec.get_feature_names(), out_file=f)oneRowX = dummyX[0, :]print(&quot;oneRowX: &quot; + str(oneRowX))newRowX = oneRowXnewRowX[0] = 1newRowX[2] = 0print(&quot;newRowX: &quot; + str(newRowX))new = np.array(newRowX).reshape(1, -1)predictedY = clf.predict(new)print(&quot;predictedY: &quot; + str(predictedY)) 注意：转化dot文件至pdf可视化决策树：在cmd，对应文件夹中输入dot -Tpdf allElectronicInformationGainOri.dot -o outpu.pdf结果如下：]]></content>
      <categories>
        <category>Machine Leaning</category>
      </categories>
      <tags>
        <tag>Decision Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连续子向量中最大和的四种算法]]></title>
    <url>%2F2018%2F10%2F15%2F%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%90%91%E9%87%8F%E4%B8%AD%E6%9C%80%E5%A4%A7%E5%92%8C%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、问题描述：来自一维的模式识别输入与输出 输入：具有n个浮点数的向量x 输出：输入向量的任何连续子向量中的最大和。假定输出的最大和为非负数。 二、四种算法与分析 暴力法： 基本思路：对所有满足0 ≤ i ≤ j &lt; n的整数对(i,j)进行检查，判断x[i..j]的总和Sum(x[i..j])是否最大？其中Sum(x[i..j]) 该算法时间复制度为O(n^3) 123456789101112131415float alg1()&#123; int i, j, k; float sum, maxsofar = 0; for (i = 0; i &lt; n; i++) for (j = i; j &lt; n; j++) &#123; sum = 0; for (k = i; k &lt;= j; k++) sum += x[k]; if (sum &gt; maxsofar) maxsofar = sum; &#125; return maxsofar;&#125; 暴力法的一些简化基本思路： 对所有满足0 ≤ i ≤ j &lt; n的整数对(i,j)进行检查，判断x[i..j]的总和sum(x[i..j])是否最大？ 如何计算sum(x[i..j])？ sum(x[i..j]) = sum(x[i..j-1])+x[j] sum(x[i..j]) = sum(x[0..j])-sum(x[0..i-1]) 该算法时间复制度为O(n^2)由以上两种计算sum(x[i..j])，可以得到两种算法 12345678910111213141516171819202122232425262728293031323334353637383940414243//第一种float alg2()&#123; int i, j, k; float sum, maxsofar = 0; for (i = 0; i &lt; n; i++) &#123; sum = 0; for (j = i; j &lt; n; j++) &#123; sum += x[j]; if(sum &gt; maxsofar) maxsofar = sum; &#125; &#125; return maxsofar;&#125;//第二种float cumvec[MAXN + 1];float alg2b()&#123; int i, j, k; float *cumarr, sum, maxsofar = 0; cumarr = cumvec + 1; cumarr[-1] = 0; for(i = 0; i &lt; n; i++) cumarr[i] = cumarr[i - 1] = x[i]; for(i = 0; i &lt; n; i++) &#123; for(j = i; j &lt; n; j++) &#123; sum = cumarr[j] - cumarr[i - 1]; if(sum &gt; maxsofar) maxsofar = sum; &#125; &#125; return maxsofar;&#125; 分治法 分治原理：要解决规模为n的问题，可递归地解决两个规模近似为n/2的子问题，然后对它们的答案进行合并以得到整个问题的答案。 初始问题：找出大小为n的向量x中连续子向量中的最大和mx Step1:将向量x划分为两个大小近似相等的子向量a和b Step2:分别递归地找出a、b中连续子向量中的最大和为ma,mb Step3:mx=max(ma,mb,mc)，其中mc=max(sum(x[i..n/2-1])) +max(sum(x[n/2..j])) 该算法时间复制度为O(nlogn)123456789101112131415161718192021222324252627282930313233343536float maxfun(float a, float b)&#123; return a &gt; b ? a : b;&#125;#define max(a, b) maxfun(a, b)float alg3()&#123; return recmax(0, n-1);&#125;float recmax(int l, int u)&#123; int i, m; float lmax, rmax, sum; if (l &gt; u) /* zero elements */ return 0; if (l == u) /* one element */ return max(0, x[l]); m = (l+u) / 2;// find max crossing to left lmax = sum = 0; for(i = m; i &gt;= l; i--)&#123; sum += x[i]; if(sum &gt; lmax) lmax = sum; &#125; rmax = sum = 0; for(i = m+1; i &lt;= u; i++)&#123; sum += x[i]; if(sum &gt; rmax) rmax = sum; &#125; return max(lmax + rmax, max(recmax(l, m),recmax(m+1, u)));&#125; 扫描法 初始问题：找出大小为n的向量x中连续子向量中的最大和mx 利用分治原理 假设现在已解决了大小为(i-1)的向量x[0..i-2]的问题，那么如何计算大小为i的向量x[0..i-1]的问题呢？ 大小为i的向量x[0..i-1]中连续子向量中的最大和mx[0..i-1] =max(mx[0..i-2],maxendinghere[i-1])其中maxendinghere[i-1]表示向量x[0..i-1]中结束位置为(i-1)的连续子向量的最大和，即maxendinghere[i-1]=max(sum(x[0..i-1]), sum(x[1..i-1]), … , sum(x[i-1..i-1]))。假定maxendinghere≥0. 该算法时间复制度为O(n) 12345678910111213141516171819202122232425262728293031323334353637383940// 第一种float alg4()&#123; int i; float maxsofar = 0, maxendinghere = 0; for (i = 0; i &lt; n; i++) &#123; maxendinghere += x[i]; if (maxendinghere &lt; 0) maxendinghere = 0; if (maxsofar &lt; maxendinghere) maxsofar = maxendinghere; &#125; return maxsofar;&#125;//第二种#define maxmac(a, b) ((a) &gt; (b) ? (a) : (b) )float alg4b()&#123; int i; float maxsofar = 0, maxendinghere = 0; for (i = 0; i &lt; n; i++) &#123; maxendinghere += x[i]; maxendinghere = maxmac(maxendinghere, 0); maxsofar = maxmac(maxsofar, maxendinghere);&#125; return maxsofar;&#125;//第三种float maxfun(float a, float b)&#123; return a &gt; b ? a : b;&#125;float alg4c()&#123; int i; float maxsofar = 0, maxendinghere = 0; for (i = 0; i &lt; n; i++) &#123; maxendinghere += x[i]; maxendinghere = maxfun(maxendinghere, 0); maxsofar = maxfun(maxsofar, maxendinghere);&#125; return maxsofar;&#125; 实际运行时间对比 这篇文章是对老师上课内容的一次回顾]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>分治法</tag>
        <tag>扫描法</tag>
        <tag>时间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表基本操作二]]></title>
    <url>%2F2018%2F10%2F14%2F2018%2F2018-10-14-%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[三、链表实现代码与分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct Node &#123; char *SchoolNumber; char *Name; int Age; struct Node *Next;&#125;;typedef struct Node *Link;// 实现字符串信息转换成相应节点信息struct Node Str_Node(char *buffer) &#123; char *p[3]; char *temp; struct Node n; int i = 0; temp = strdup(strtok(buffer, &quot;,&quot;)); //字符串的分割 while(temp) &#123; p[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; n.SchoolNumber = p[0]; n.Name = p[1]; n.Age = atoi(p[2]); n.Next = NULL; return n;&#125;// 打印单个节点void Print(Link &amp;Head, int op_number)&#123; if(op_number == 0)&#123; printf(&quot;Error!\n&quot;); return ; &#125; Link p; p = Head; for(int i = 0; i &lt; op_number; i++)&#123; p = p-&gt;Next; &#125; printf(&quot;%-10d&quot;, op_number); printf(&quot;%-15x&quot;, p); printf(&quot;%-15s&quot;, p-&gt;SchoolNumber); printf(&quot;%-15s&quot;, p-&gt;Name); printf(&quot;%-15d\n&quot;, p-&gt;Age);&#125;//插入节点void InsertNode(Link &amp;Head, Node n, int &amp;NodeCount, int i)&#123; Link p; p = Head; for(int j = 0; j &lt; i-1; j++)&#123; p = p-&gt;Next; &#125; n.Next = p-&gt;Next; p-&gt;Next = &amp;n; NodeCount++;&#125;//删除节点void DeleteNode(Link &amp;Head, int &amp;NodeCount, int i)&#123; Link p, r; p = Head; for(int j = 0; j &lt; i; j++ ) &#123; r = p; p = p-&gt;Next; &#125; r-&gt;Next = p-&gt;Next; free(p); NodeCount--;&#125;// 主函数int main()&#123; FILE *fp; char buffer[100]; char operate[50]; int op_number; Link Head = (Link)malloc(sizeof(struct Node)); Head-&gt;Next = NULL; int NodeCount = 0; Link p = (Link)malloc(sizeof(struct Node)); p = Head; printf(&quot;Number PhysiAddr SchoolNumber Name Age\n&quot;); if((fp = fopen(&quot;Lab1test.DAT&quot;, &quot;rt&quot;)) != NULL) &#123; while(fgets(buffer, 99, fp) != NULL) &#123; Link temp = (Link)malloc(sizeof(struct Node)); *temp = Str_Node(buffer); p-&gt;Next = temp; p = p-&gt;Next; NodeCount++; &#125; fclose(fp); &#125; for(int i = 0; i &lt; NodeCount; i++) Print(Head, i+1); while(1)&#123; printf(&quot;Please enter Pi, Di or Ii(i&lt;%d):\n&quot;,NodeCount); scanf(&quot;%s&quot;,operate); if(operate[0] == &apos;0&apos;) break; if(operate[0] == &apos;P&apos;) &#123; op_number = atoi(operate + 1); Print(Head, op_number); &#125; else if(operate[0] == &apos;I&apos;)&#123; char *t[4]; char *temp; int i = 0; Node n; temp = strdup(strtok(operate, &quot;,&quot;)); while(temp)&#123; t[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; int number = atoi(operate + 1); n.SchoolNumber = t[1]; n.Name = t[2]; n.Age = atoi(t[3]); InsertNode(Head, n, NodeCount, number); for(int i = 0; i &lt; NodeCount; i++)&#123; Print(Head, i+1); &#125; &#125; else if(operate[0] == &apos;D&apos;) &#123; op_number = atoi(operate + 1); DeleteNode(Head, NodeCount, op_number); for(int i = 0; i &lt; NodeCount; i++)&#123; Print(Head, i+1); &#125; &#125; else printf(&quot;Error!\n&quot;); &#125; return 0;&#125; 四、所遇到的“坑” 在布局输出结果时，使用\t并不能解决，需要使用类似于”%-15x”的格式化输出搞定。 在打印节点时，老是从学号后面开始出现乱码，这种情况，要么是转化时出现问题，要么是创建链表时出问题。在103行，进行节点输出，发现没问题，那么就是转化出问题。将这部分进行单拎出来，用char buffer[] = “SA12345678,小明,22”测试，发现乱码，果然是这部分有问题。与顺序表的转化部分对比，发现一个返回结构体，一个返回结构体指针。以下是出错代码：123456789101112131415161718192021Link Str_Node(char *buffer) &#123; char *p[3]; char *temp; Link NewNode = (Link)malloc(sizeof(struct Node)); int i = 0; temp = strdup(strtok(buffer, &quot;,&quot;)); while(temp) &#123; p[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; NewNode-&gt;SchoolNumber = p[0]; NewNode-&gt;Name = p[1]; NewNode-&gt;Age = atoi(p[2]); NewNode-&gt;Next = NULL; return NewNode;&#125; 将其改为返回结构体得以解决。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表的操作一]]></title>
    <url>%2F2018%2F10%2F13%2F2018%2F2018-10-13-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Data Structure – Linear_list一、要求：&emsp;&emsp;首先，逐行读取指定文件中的数据，并进行解析后保存在顺序表中。其中，文件中每行数据格式为“学号,姓名,年龄”，比如“SA10225048,张三,24”。（提示：采用顺序表结构时，顺序表中每个表元素包含三类信息：学号，姓名，和年龄；采用单链表结构时，单链表中每个结点的数据域包含三类信息：学号，姓名，和年龄。）再根据键盘输入进行相关操作（查找，删除和插入）。比如，若键盘输入为“P3”，则表示打印出第3项的信息（注意：采用顺序表结构时，第3项数据对应下标为2的表元素；采用单链表结构时，第3项数据对应链表中第3个结点的信息；）；若键盘输入为“D3”，则表示删除第3个表元素；若键盘输入为“I3,SA10225038,张四,24”，则表示在第3项前插入一个学生的信息（SA10225038,张四,24）。 附件可以把以下数据复制到txt文档，然后改名为studentinfo.data。将这个文件和cpp文件放在同一个目录下。 SA10225048,张三,24SG10225132,李四,22连续子向量中的最大和SG10225027,王五,24SA10225213,赵六,25SA10225197,欧阳奋强,23SG10225059,孙八,24SA10225083,余久,23SA10225112,张唯一,24 二、顺序表实现代码与分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define maxn 100struct Node &#123; char *SchoolNumber; char *Name; int Age;&#125;ArrNode[maxn];// 实现字符串信息转换成相应节点信息struct Node Str_Node(char *buffer) &#123; char *p[3]; char *temp; struct Node n; int i = 0; temp = strdup(strtok(buffer, &quot;,&quot;)); while(temp) &#123; p[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; n.SchoolNumber = p[0]; n.Name = p[1]; n.Age = atoi(p[2]); return n;&#125;// 打印所有节点void Print(int NodeCount)&#123; for(int i = 0; i &lt; NodeCount; i++)&#123; printf(&quot;%-10d&quot;, i+1); printf(&quot;%-15x&quot;, ArrNode + i); printf(&quot;%-15s&quot;, ArrNode[i].SchoolNumber); printf(&quot;%-15s&quot;, ArrNode[i].Name); printf(&quot;%-15d\n&quot;, ArrNode[i].Age); &#125;&#125;// 插入节点void InsertNode(struct Node n, int &amp;NodeCount, int i)&#123; for(int j = NodeCount; j &gt;= i; j--)&#123; ArrNode[j].SchoolNumber = ArrNode[j-1].SchoolNumber; ArrNode[j].Name = ArrNode[j-1].Name; ArrNode[j].Age = ArrNode[j-1].Age; &#125; ArrNode[i-1].SchoolNumber = n.SchoolNumber; ArrNode[i-1].Name = n.Name; ArrNode[i-1].Age = n.Age; NodeCount++;&#125;// 删除节点void DeleteNode(int &amp;NodeCount, int i)&#123; for(int j = i; j &lt; NodeCount; j++)&#123; ArrNode[j - 1].SchoolNumber = ArrNode[j].SchoolNumber; ArrNode[j - 1].Name = ArrNode[j].Name; ArrNode[j - 1].Age = ArrNode[j].Age; &#125; NodeCount--;&#125;int main()&#123; FILE *fp; char buffer[100]; int NodeCount = 0; char operate[30]; int op_number; if((fp = fopen(&quot;studentinfo.data&quot;, &quot;rt&quot;)) != NULL) &#123; while(fgets(buffer, 99, fp) != NULL) &#123; ArrNode[NodeCount++] = Str_Node(buffer); &#125; fclose(fp); &#125; printf(&quot;Number PhysiAddr SchoolNumber Name Age\n&quot;); Print(NodeCount); while(1)&#123; printf(&quot;Please enter Pi, Di or Ii(i&lt;%d):\n&quot;,NodeCount); scanf(&quot;%s&quot;,operate); if(operate[0] == &apos;0&apos;) break; if(operate[0] == &apos;P&apos;) &#123; op_number = atoi(operate + 1); printf(&quot;%-10d&quot;, op_number); printf(&quot;%-15x&quot;, ArrNode + op_number - 1); printf(&quot;%-15s&quot;, ArrNode[op_number - 1].SchoolNumber); printf(&quot;%-15s&quot;, ArrNode[op_number - 1].Name); printf(&quot;%-15d\n&quot;, ArrNode[op_number - 1].Age); &#125; else if(operate[0] == &apos;I&apos;)&#123; char *t[4]; char *temp; int i = 0; struct Node n; temp = strdup(strtok(operate, &quot;,&quot;)); while(temp)&#123; t[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; int number = atoi(operate + 1); n.SchoolNumber = t[1]; n.Name = t[2]; n.Age = atoi(t[3]); InsertNode(n, NodeCount, number); Print(NodeCount); &#125; else if(operate[0] == &apos;D&apos;) &#123; op_number = atoi(operate + 1); DeleteNode(NodeCount, op_number); Print(NodeCount); &#125; else printf(&quot;Error!\n&quot;); &#125; return 0;&#125; 使用的是顺序表结构来实现线性表的基本操作，明天采用链表结构来实现。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习]]></title>
    <url>%2F2018%2F10%2F06%2Fmatplotlib%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Matplotlib是一个Python 2D绘图库，它可以在各种平台上以各种硬拷贝格式和交互式环境生成出具有出版品质的图形。 Matplotlib可用于Python脚本，Python和IPython shell，Jupyter笔记本，Web应用程序服务器和四个图形用户界面工具包.matplotlib简单操作 一、折线图123456789101112131415161718In [1]:import matplotlib as mpl import matplotlib.pyplot as plt import numpy as np import mathIn [2]:x=np.linspace(-4, 4, 100)In [3]:y=np.sin(x) yy=np.cos(x)In [4]:plt.plot(x, y, color = &quot;red&quot;, linestyle=&quot;--&quot;, label=&quot;sin(x)&quot;) #linestyle有四种--,-. plt.plot(x, yy, color=&quot;pink&quot;, label=&quot;cos(x)&quot;) plt.plot() plt.xlabel(&quot;x axis&quot;) plt.ylabel(&quot;y axis&quot;) #plt.xlim(-math.pi, math.pi) #plt.ylim(-2, 2) plt.axis([-math.pi, math.pi, -2, 2]) plt.legend() plt.title(&quot;welcome to ML world!&quot;) plt.show() 二、散点图123In [5]:plt.scatter(x,y,color=&quot;green&quot;)Out[5]:&lt;matplotlib.collections.PathCollection at 0x1c7d2128400&gt; 1234In [6]:plt.scatter(x,y) plt.scatter(x,yy,color=&quot;red&quot;)Out[6]:&lt;matplotlib.collections.PathCollection at 0x1c7d21a0080&gt; 1234In [7]:x = np.random.normal(0, 1, 1000) y = np.random.normal(0, 1, 1000) plt.scatter(x, y, alpha = 0.5, color = &apos;g&apos;) plt.show() 1234In [8]:x = np.arange(-500, 500) y = np.random.normal(0, 1, 1000) plt.scatter(x, y) plt.show() 三、应用123456789101112131415161718192021222324252627282930313233In [9]:import numpy as np import matplotlib.pyplot as plt from sklearn import datasetsIn [10]:iris = datasets.load_iris()In [11]:iris.keys()In [12]:print(iris.DESCR)In [14]:iris.data.shapeOut[14]:(150, 4)In [15]:iris.targetOut[15]:array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])In [16]:iris.target_namesOut[16]:array([&apos;setosa&apos;, &apos;versicolor&apos;, &apos;virginica&apos;], dtype=&apos;&lt;U10&apos;)In [17]:X = iris.data[:, :2]In [18]:X.shapeOut[18]:(150, 2)In [19]:plt.scatter(X[:,0], X[:, 1])Out[19]:&lt;matplotlib.collections.PathCollection at 0x1c7d3d590f0&gt; 12345In [20]:y = iris.targetIn [21]:plt.scatter(X[y==0, 0], X[y==0, 1], color = &apos;g&apos;) plt.scatter(X[y==1, 0], X[y==1, 1], color = &apos;r&apos;) plt.scatter(X[y==2, 0], X[y==2, 1], color = &apos;y&apos;) plt.show() 12345In [22]:X = iris.data[:,2:]In [23]:plt.scatter(X[y==0, 0], X[y==0, 1], color = &apos;g&apos;) plt.scatter(X[y==1, 0], X[y==1, 1], color = &apos;r&apos;, marker = &apos;*&apos;) plt.scatter(X[y==2, 0], X[y==2, 1], color = &apos;y&apos;, marker = &apos;+&apos;) plt.show()]]></content>
      <categories>
        <category>Machine Leaning</category>
      </categories>
      <tags>
        <tag>plot</tag>
        <tag>scatter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy学习二]]></title>
    <url>%2F2018%2F10%2F06%2F2018%2F2018-10-06-numpy%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[八、矩阵运算 1234567891011121314151617181920212223242526272829303132In [103]:A = np.arange(4).reshape(2, 2) B = np.full((2, 2), 10) A, BOut[103]:(array([[0, 1], [2, 3]]), array([[10, 10], [10, 10]]))In [104]:A + BOut[104]:array([[10, 11], [12, 13]])In [105]:A - BOut[105]:array([[-10, -9], [ -8, -7]])In [106]:A * B #对应元素相乘Out[106]:array([[ 0, 10], [20, 30]])In [107]:A.dot(B) #矩阵乘法Out[107]:array([[10, 10], [50, 50]])In [108]:A.T#转置Out[108]:array([[0, 2], [1, 3]]) 九、向量和矩阵运算12345678910111213141516171819202122232425262728In [109]:v=np.array([1,2]) v + A # v向量分别与A矩阵每一行相加，实际上不合法Out[109]:array([[1, 3], [3, 5]])In [110]:np.vstack([v] * A.shape[0]) #将v落成A一样高，即同行数然后在与A相加可 实现上面要求Out[110]:array([[1, 2], [1, 2]])In [111]:np.tile(v, (2,1)) # 将v向量在行上堆叠两次，在列上堆叠一次Out[111]:array([[1, 2], [1, 2]])In [112]:v * A # v与A中每一行各元素对应相乘所得Out[112]:array([[0, 2], [2, 6]])In [113]:v.dot(A)Out[113]:array([4, 7])In [114]:A.dot(v) #由于v没有规定是行还是列向量，所以np会自动判断使其合理的方式运算Out[114]:array([2, 8]) 十、矩阵的逆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768In [115]:A = np.arange(24).reshape(4,6)In [116]:AOut[116]:array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17], [18, 19, 20, 21, 22, 23]])In [117]:B=np.arange(0,24).reshape(6,4)In [118]:z=A.dot(B) zOut[118]:array([[ 220, 235, 250, 265], [ 580, 631, 682, 733], [ 940, 1027, 1114, 1201], [1300, 1423, 1546, 1669]])In [119]:arr1=z%11 arr1Out[119]:array([[0, 4, 8, 1], [8, 4, 0, 7], [5, 4, 3, 2], [2, 4, 6, 8]], dtype=int32)In [120]:inv1=np.linalg.inv(arr1+1) #np.linalg中有逆的运算 inv1Out[120]:array([[ 1.68884986e+15, 1.68884986e+15, -2.25179981e+15, -1.12589991e+15], [-3.37769972e+15, -3.37769972e+15, 4.50359963e+15, 2.25179981e+15], [ 1.68884986e+15, 1.68884986e+15, -2.25179981e+15, -1.12589991e+15], [-1.36363636e-01, -4.54545455e-02, 0.00000000e+00, 1.81818182e-01]])In [121]:pinvx=np.linalg.pinv(A) #当A不是方阵时，A没有逆可以有伪逆In [122]:pinvxOut[122]:array([[-0.12619048, -0.06587302, -0.00555556, 0.0547619 ], [-0.07904762, -0.04063492, -0.00222222, 0.03619048], [-0.03190476, -0.01539683, 0.00111111, 0.01761905], [ 0.0152381 , 0.00984127, 0.00444444, -0.00095238], [ 0.06238095, 0.03507937, 0.00777778, -0.01952381], [ 0.10952381, 0.06031746, 0.01111111, -0.03809524]])In [123]:pinvx.shapeOut[123]:(6, 4)In [124]:A.dot(pinvx)Out[124]:array([[ 0.7, 0.4, 0.1, -0.2], [ 0.4, 0.3, 0.2, 0.1], [ 0.1, 0.2, 0.3, 0.4], [-0.2, 0.1, 0.4, 0.7]])In [125]:pinvx.dot(x)Out[125]:array([[ 0.34920635, 0.20634921, 0.06349206], [ 0.25396825, 0.16825397, 0.08253968], [ 0.15873016, 0.13015873, 0.1015873 ], [ 0.06349206, 0.09206349, 0.12063492], [-0.03174603, 0.05396825, 0.13968254], [-0.12698413, 0.01587302, 0.15873016]])In [126]:np.linalg.pinv? 十一、np中的聚合运算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899In [127]:L = np.random.random(100)In [128]:LOut[128]:array([0.29365293, 0.13349054, 0.72296127, 0.20339775, 0.79085149, 0.72289686, 0.34664717, 0.21922709, 0.2347296 , 0.10934288, 0.93987847, 0.54118002, 0.89582475, 0.88657711, 0.01363686, 0.86886947, 0.30145564, 0.94794894, 0.01607689, 0.97629271, 0.81439886, 0.31815539, 0.29844493, 0.41129176, 0.33999991, 0.95050074, 0.43841296, 0.30775838, 0.69076609, 0.09082456, 0.95063683, 0.83411245, 0.71913127, 0.72244065, 0.11435661, 0.48092918, 0.56755408, 0.30867441, 0.79659891, 0.88179918, 0.70385178, 0.95382592, 0.40178135, 0.52124991, 0.77764132, 0.01151922, 0.56330513, 0.49297281, 0.6472458 , 0.8703968 , 0.59602549, 0.3425843 , 0.32778162, 0.8072212 , 0.90542921, 0.64954137, 0.2699948 , 0.03288953, 0.04912259, 0.46259617, 0.16843821, 0.92318423, 0.56270712, 0.15915484, 0.35922195, 0.04674703, 0.39876266, 0.94110829, 0.76153611, 0.3938261 , 0.78600756, 0.33429112, 0.16921891, 0.67781051, 0.84572637, 0.38719376, 0.17431285, 0.56729794, 0.98401691, 0.52914654, 0.43819623, 0.91374443, 0.73249185, 0.14618544, 0.20060762, 0.42209825, 0.10296695, 0.6020364 , 0.24532492, 0.98187115, 0.08073652, 0.63580472, 0.11326209, 0.25617199, 0.32379328, 0.66696424, 0.81302027, 0.83596411, 0.32551382, 0.8484381 ])In [129]:sum(L)Out[129]:51.443603284608905In [130]:np.sum(L) #与前者时间不一样Out[130]:51.4436032846089In [131]:np.min(L)Out[131]:0.011519220430084354In [132]:np.max(L)Out[132]:0.9840169068335332In [133]:L.min() # 面对对象，还是np型都可以，不过后者包含的函数更全Out[133]:0.011519220430084354In [134]:X = np.arange(16).reshape(4, -1) XOut[134]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])In [135]:np.sum(X) #对应多维矩阵，sum为所有元素之和Out[135]:120In [136]:np.sum(X, axis = 1) #每一列元素相加之和Out[136]:array([ 6, 22, 38, 54])In [137]:np.prod(X + 1) #所有元素之积Out[137]:2004189184In [138]:np.prod(X, axis = 1) #沿着列相乘Out[138]:array([ 0, 840, 7920, 32760])In [139]:np.mean(X) #平均值Out[139]:7.5In [140]:np.median(X) #中位数，中间有两个就这两个数的平均值Out[140]:7.5In [141]:np.percentile(X,q=10) #百分位点，指有10%的数都小于等于1.5，当q=50表示中位数，q=100表示最大值，q = 0表示最小值Out[141]:1.5In [142]:np.percentile(X, q= 100)Out[142]:15.0In [143]:rad = np.random.random(100) for percent in [0, 25, 50, 100]: print(np.percentile(rad, q=percent))0.023267903753504850.26171186382127440.50112193791323390.998188987589012In [144]:np.var(rad) #求方差Out[144]:0.07112525170741578In [145]:np.std(rad) #标准差Out[145]:0.26669317896679656 十二、索引12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364In [146]:np.argmin(rad) #表示最小值所在的索引下标Out[146]:80In [147]:x = np.arange(16) xOut[147]:array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])In [158]:np.random.shuffle(x) #对x使用乱序化,x本身会改变 xOut[158]:array([10, 12, 3, 7, 4, 5, 6, 2, 9, 13, 14, 11, 0, 15, 8, 1])In [159]:np.sort(x) #x并不会改变Out[159]:array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])In [157]:x.sort() #x会改变 xOut[157]:array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])In [161]:X = np.random.randint(0,10,size=(4,4)) #在[0,10)之间随机生成4X4 的二维整型矩阵 XOut[161]:array([[6, 6, 4, 0], [3, 8, 2, 7], [7, 1, 1, 2], [0, 2, 1, 7]])In [163]:np.sort(X) #各行进行排序Out[163]:array([[0, 4, 6, 6], [2, 3, 7, 8], [1, 1, 2, 7], [0, 1, 2, 7]])In [165]:np.sort(X,axis = 0) #沿着行排序Out[165]:array([[0, 1, 1, 0], [3, 2, 1, 2], [6, 6, 2, 7], [7, 8, 4, 7]])In [167]:np.argsort(X) #排序的索引Out[167]:array([[3, 2, 0, 1], [2, 0, 3, 1], [1, 2, 3, 0], [0, 2, 1, 3]], dtype=int64)In [168]:xOut[168]:array([10, 12, 3, 7, 4, 5, 6, 2, 9, 13, 14, 11, 0, 15, 8, 1])In [169]:np.partition(x, 3) #使3前面都比3小，后面都比3大Out[169]:array([ 0, 1, 2, 3, 4, 5, 7, 8, 9, 6, 10, 11, 14, 15, 12, 13])In [170]:np.argpartition(x,3) #返回其索引Out[170]:array([12, 15, 7, 2, 4, 5, 3, 14, 8, 6, 0, 11, 10, 13, 1, 9], dtype=int64) 十三、Fancy Indexing123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111In [171]:x = np.arange(16)In [172]:ind = [3, 5, 8]In [173]:x[ind] #将索引放进数组，然后进行访问Out[173]:array([3, 5, 8])In [174]:ind = np.array([[2, 4, 1], [0, 10, 3]])In [175]:x[ind] # 根据索引来返回相应的值Out[175]:array([[ 2, 4, 1], [ 0, 10, 3]])In [176]:X = x.reshape(4, -1) XOut[176]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])In [177]:row = np.array([0, 1, 2]) col = np.array([1, 2, 3])In [178]:X[row,col] #根据row，col所得交集来访问Out[178]:array([ 1, 6, 11])In [179]:X[:2,col]Out[179]:array([[1, 2, 3], [5, 6, 7]])In [180]:X&lt;5 #返回bool值Out[180]:array([[ True, True, True, True], [ True, False, False, False], [False, False, False, False], [False, False, False, False]])In [184]:3 * X== 4*X-1 #返回满足改条件的值的真假Out[184]:array([[False, True, False, False], [False, False, False, False], [False, False, False, False], [False, False, False, False]])In [186]:xOut[186]:array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])In [187]:np.sum(x &lt;= 3) #返回x中小于等于3的个数Out[187]:4In [188]:np.any(x &lt;=3 ) #返回x中是否有小于等于3的数Out[188]:TrueIn [189]:np.count_nonzero(x &lt;= 3) #表示x&lt;=3这个bool数组中有多少个非零元素（false为0，true为1）Out[189]:4In [190]:np.all(x&gt;=0) #all判断x&gt;=0这个bool数组中是不是都大于0Out[190]:TrueIn [192]:np.all(x)Out[192]:FalseIn [193]:np.sum((x&gt;3) &amp; (x&lt;7)) # &amp;为和不能用and, 因为这两边都是数组，要求的是两个数组中的交集而不是一个值Out[193]:3In [195]:np.sum((x&gt;3) | (x&lt;7))Out[195]:16In [196]:np.sum(~(x==3))Out[196]:15​In [149]:arr4 = np.arange(10).reshape(2,5) arr4Out[149]:array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])In [150]:ind = [True ,False, True, False,True]In [151]:arr4[:,ind]Out[151]:array([[0, 2, 4], [5, 7, 9]])In [152]:np.any(arr4&gt;2)Out[152]:TrueIn [153]:np.all(arr4&lt;=1)Out[153]:FalseIn [154]:np.sum(arr4&gt;3)Out[154]:6In [155]:import numpy as np arr4 = np.arange(0,10).reshape(2,5) np.sum(arr4[:,0])Out[155]:5]]></content>
      <categories>
        <category>Machine Leaning</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy学习一]]></title>
    <url>%2F2018%2F10%2F06%2F2018%2F2018-10-06-numpy%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本期将会涉及到Python模块中的numpy，这是一个处理数组的强大模块，而该模块也是其他数据分析模块（如pandas和scipy）的核心。 一、数组的创建 np.array(list,tuple,array类型) np.arange,一维数组中的range ones,ones_like,zeros,zeros_like,empty,empty_like eye,identity #单位矩阵 full #全为指定数矩阵 linspace(0,20,10)In:1234567arr1 = np.array(range(10)).reshape(2,5)arr2 = np.arange(10).reshape(2,5)arr3 = np.ones((2,5))arr4 = np.zeros_like(arr1)arr5 = np.eye(5)arr6 = np.full((2, 5), 3)np.linspace(0,20,10) #在0 和 20 包括0,20等长的截取10个点 Out:123456789101112131415161718192021222324252627282930313233343536arr1Out[5]:array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])arr2Out[6]:array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])arr3Out[7]:array([[1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.]])arr4Out[8]:array([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]])arr5Out[9]:array([[1., 0., 0., 0., 0.], [0., 1., 0., 0., 0.], [0., 0., 1., 0., 0.], [0., 0., 0., 1., 0.], [0., 0., 0., 0., 1.]])arr6Out[10]:array([[3, 3, 3, 3, 3], [3, 3, 3, 3, 3]])Out[11]:array([ 0. , 2.22222222, 4.44444444, 6.66666667, 8.88888889, 11.11111111, 13.33333333, 15.55555556, 17.77777778, 20. ]) 二、数组的基本操作123456789101112131415161718192021In[25]:arr1Out[25]:array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])In [26]:arr2Out[26]:array([ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19])In [28]:arr3=arr2.reshape(2,5) #reshape 改变类型In [29]:arr3.shape#不该变arr3自身Out[29]:(2, 5)In [30]:arr3.size #元素个数Out[30]:10In [31]:arr3.ndim #元素维度Out[31]:2 三、矩阵元素访问123456789101112131415161718192021222324252627282930313233343536373839In [32]:arr3[:]Out[32]:array([[ 1, 3, 5, 7, 9], [11, 13, 15, 17, 19]])In [33]:arr3[1,3] #arr3[1,3]和arr3[1][3]一样但是推荐使用前者Out[33]:17In [34]:x = np.array(range(12)).reshape(3, 4) xOut[34]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])In [35]:x[::-1,::-1] #步长为-1表示从后往前数Out[35]:array([[11, 10, 9, 8], [ 7, 6, 5, 4], [ 3, 2, 1, 0]])In [36]:subx=x[:2,:3] #切片访问 subx改变值不会改变arr3值 subxOut[36]:array([[0, 1, 2], [4, 5, 6]])In [37]:subx=x[:2,2:] subxOut[37]:array([[2, 3], [6, 7]])In [38]:subx[0,1]=100In [39]:print(arr3)#改变arr3中子矩阵，arr3也会改变，是引用方式Out[39]:[[ 1 3 5 7 9] [11 13 15 17 19]] 四、合并操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061In [40]:x=np.array([1,2,3]) y=np.array([3,1,2])In [41]:np.concatenate([x,y])Out[41]:array([1, 2, 3, 3, 1, 2])In [42]:np.concatenate([x,y],axis=0)Out[42]:array([1, 2, 3, 3, 1, 2])In [43]:A = np.array([[1,2,3], [4,5,6]])In [44]:np.concatenate([A,A]) #默认垂直合并 concatenate只能处理同类型矩阵Out[44]:array([[1, 2, 3], [4, 5, 6], [1, 2, 3], [4, 5, 6]])In [45]:np.concatenate([A,A],axis = 1)Out[45]:array([[1, 2, 3, 1, 2, 3], [4, 5, 6, 4, 5, 6]])In [46]:z = np.array([666,666,666])In [47]:np.concatenate([A, z.reshape(1,-1)]) #针对concatenate只能同类型矩阵，可以用（1，-1）表示一行，列数随机的方法Out[47]:array([[ 1, 2, 3], [ 4, 5, 6], [666, 666, 666]])In [48]:np.vstack([A,z])#垂直堆叠合并Out[48]:array([[ 1, 2, 3], [ 4, 5, 6], [666, 666, 666]])In [49]:B = np.full((2,2),100) BOut[49]:array([[100, 100], [100, 100]])In [50]:arr4 = np.array(range(12)).reshape(3,4)In [51]:print(arr4)Out[51]:[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]]In [52]:np.hstack([arr4,arr4]) #水平堆叠合并Out[52]:array([[ 0, 1, 2, 3, 0, 1, 2, 3], [ 4, 5, 6, 7, 4, 5, 6, 7], [ 8, 9, 10, 11, 8, 9, 10, 11]])In [53]:np.hstack([arr4,arr4])Out[53]:array([[ 0, 1, 2, 3, 0, 1, 2, 3], [ 4, 5, 6, 7, 4, 5, 6, 7], [ 8, 9, 10, 11, 8, 9, 10, 11]]) 五、分割 split12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485In [54]:arr5=np.array(range(10))In [55]:x1,x2,x3=np.split(arr5,[3,7])#arr5 分割矩阵，【3,7】为分割点列表In [56]:print(x1)Out[56]:[0 1 2]In [57]:x2Out[57]:array([3, 4, 5, 6])In [58]:x3Out[58]:array([7, 8, 9])In [59]:x1,x2 = np.split(arr5,[5]) x1,x2Out[59]:(array([0, 1, 2, 3, 4]), array([5, 6, 7, 8, 9]))In [60]:arr6=np.array(range(16)).reshape(4,4) arr6Out[60]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])In [61]:a1,a2 = np.split(arr6, [2]) #当arr6为二维数组时，【2】表示前两行为分割处 a1Out[61]:array([[0, 1, 2, 3], [4, 5, 6, 7]])In [62]:a2Out[62]:array([[ 8, 9, 10, 11], [12, 13, 14, 15]])In [63]:A1,A2 = np.split(arr6, [2], axis = 1) #axis=1 表示列分割 A1,A2Out[63]:(array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]]), array([[ 2, 3], [ 6, 7], [10, 11], [14, 15]]))In [64]:up,down =np.vsplit(arr6,[-1]) #垂直切割，表示分成上下部分In [65]:up,downOut[65]:(array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]), array([[12, 13, 14, 15]]))In [66]:left,right = np.hsplit(arr6,[2]) #水平切割，表示分成左右部分 left,rightOut[66]:(array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]]), array([[ 2, 3], [ 6, 7], [10, 11], [14, 15]]))In [67]:data = np.arange(16).reshape(4,4) dataOut[67]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])In [82]:x,y = np.hsplit(data,[-1]) # data表示数据集，前三个为特征，后一个为标签，这样切割为x，y x,yOut[82]:(array([[ 0, 1, 2], [ 4, 5, 6], [ 8, 9, 10], [12, 13, 14]]), array([[ 3], [ 7], [11], [15]])) 六、矩阵的标量运算12345678910111213141516171819In [83]:%%timeit #计算单元格内运算时间 n = 10 A = [i for i in range(n)] A858 ns ± 7.77 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)In [84]:%%timeit n = 10 B = [] for i in range(n): B.append(i) B1.51 µs ± 85.2 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)In [85]:%%timeit n = 10 A = np.arange(n) A881 ns ± 93.5 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) 七、Universal Function123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687In [87]:A = [i for i in range(10)] AOut[87]:[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]In [88]:arrA = np.array(A).reshape(2, 5)In [89]:arrA * 2Out[89]:array([[ 0, 2, 4, 6, 8], [10, 12, 14, 16, 18]])In [90]:arrA - 1Out[90]:array([[-1, 0, 1, 2, 3], [ 4, 5, 6, 7, 8]])In [91]:arrA/2Out[91]:array([[0. , 0.5, 1. , 1.5, 2. ], [2.5, 3. , 3.5, 4. , 4.5]])In [92]:arrA **2Out[92]:array([[ 0, 1, 4, 9, 16], [25, 36, 49, 64, 81]], dtype=int32)In [93]:arrA //2 #整除Out[93]:array([[0, 0, 1, 1, 2], [2, 3, 3, 4, 4]], dtype=int32)In [94]:np.abs(arrA-4)Out[94]:array([[4, 3, 2, 1, 0], [1, 2, 3, 4, 5]])In [95]:np.sin(arrA)Out[95]:array([[ 0. , 0.84147098, 0.90929743, 0.14112001, -0.7568025 ], [-0.95892427, -0.2794155 , 0.6569866 , 0.98935825, 0.41211849]])In [96]:np.arcsin(arrA)C:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: invalid value encountered in arcsin &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[96]:array([[0. , 1.57079633, nan, nan, nan], [ nan, nan, nan, nan, nan]])In [97]:np.power(arrA,3)Out[97]:array([[ 0, 1, 8, 27, 64], [125, 216, 343, 512, 729]], dtype=int32)In [98]:1/arrAC:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in true_divide &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[98]:array([[ inf, 1. , 0.5 , 0.33333333, 0.25 ], [0.2 , 0.16666667, 0.14285714, 0.125 , 0.11111111]])In [99]:np.exp(arrA)Out[99]:array([[1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01, 5.45981500e+01], [1.48413159e+02, 4.03428793e+02, 1.09663316e+03, 2.98095799e+03, 8.10308393e+03]])In [100]:np.log2(arrA)C:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in log2 &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[100]:array([[ -inf, 0. , 1. , 1.5849625 , 2. ], [2.32192809, 2.5849625 , 2.80735492, 3. , 3.169925 ]])In [101]:np.log10(arrA)C:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in log10 &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[101]:array([[ -inf, 0. , 0.30103 , 0.47712125, 0.60205999], [0.69897 , 0.77815125, 0.84509804, 0.90308999, 0.95424251]])In [102]:np.log(arrA) #log默认为eC:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in log &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[102]:array([[ -inf, 0. , 0.69314718, 1.09861229, 1.38629436], [1.60943791, 1.79175947, 1.94591015, 2.07944154, 2.19722458]])]]></content>
      <categories>
        <category>Machine Leaning</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux1]]></title>
    <url>%2F2018%2F10%2F03%2F2018%2F2018-10-03-linux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux命令格式: command [-options] [parameter1] … 说明：command: 命令名,相应功能的英文单词或单词的缩写 [-options]：选项,可用来对命令进行控制，也可以省略，[]代表可选 parameter1 …：传给命令的参数：可以是零个一个或多个 一、基本技能 在linux终端时：Ctrl Shift + 三个键字体扩大，Ctrl - 字体缩小 自动补全：在敲出命令的前几个字母的同时，按下tab键，系统会自动帮我们补全命令 历史命令：当系统执行过一些命令后，可按上下键翻看以前的命令，history将执行过的命令列举出来 多个命令同时使用用 ; ，不建议使用 Ctrl c 终止命令 几个目录符号含义： ~ 用户目录 / 根目录 . 当前路径 .. 上一路径 -回看 清屏：clear 显示当前路径：pwd（不带参数） 二、文件、磁盘管理 查看文件信息：ls 参数 含义 -a 显示指定目录下所有子目录与文件，包括隐藏文件 -l 以列表方式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 输出重定向命令：&gt;Linux允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。如：ls &gt; test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 ) 注意：&gt;输出重定向会覆盖原来的内容，&gt;&gt;输出重定向则会追加到文件的尾部。 分屏显示：more查看内容时，在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用more命令，每次只显示一页，按下空格键可以显示下一页，按下q键退出显示，按下h键可以获取帮助 管道：|管道：一个命令的输出可以通过管道做为另一个命令的输入。管道我们可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里“ | ”的左右分为两端，左端塞东西(写)，右端取东西(读)。 切换工作目录： cd在使用Unix/Linux的时候，经常需要更换工作目录。cd命令可以帮助用户切换工作目录。Linux所有的目录和文件名大小写敏感cd后面可跟绝对路径，也可以跟相对路径。如果省略目录，则默认切换到当前用户的主目录。例如：cd / 到根目录 目录操作： 创建目录：mkdir通过mkdir命令可以创建一个新的目录。参数-p可递归创建目录。需要注意的是新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写权限。 删除目录：rmdir可使用rmdir命令删除一个目录。必须离开目录，并且目录必须为空目录，不然提示删除失败。 删除文件：rm可通过rm删除文件或目录。使用rm命令要小心，因为文件删除后不能恢复。为了防止文件误删，可以在rm后使用-i参数以逐个确认要删除的文件。 参数 含义 -i 以进行交互式方式执行 -f 强制删除，忽略不存在的文件，无需提示 -r 递归地删除目录下的内容，删除文件夹时必须加此参数 建立链接文件：lnLinux链接文件类似于Windows下的快捷方式。链接文件分为软链接和硬链接。软链接：软链接不占用磁盘空间，源文件删除则软链接失效。硬链接：硬链接只能链接普通文件，不能链接目录。使用格式： ln 源文件 链接文件ln -s 源文件 链接文件 如果没有-s选项代表建立一个硬链接文件，两个文件占用相同大小的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s选项是更常见的形式。 注意：如果软链接文件和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径。 查看或者合并文件内容：cat 文本搜索：grepLinux系统中grep命令是一种强大的文本搜索工具，grep允许对文本文件进行模式查找。如果找到匹配模式， grep打印包含模式的所有行。 grep一般格式为： grep [-选项] ‘搜索内容串’文件名 在grep命令中输入字符串参数时，最好引号或双引号括起来。例如：grep‘a ’1.txt。 常用选项说明： 选项 含义 -v 显示不包含匹配文本的所有行（相当于求反） -n 显示匹配行及行号 -i 忽略大小写 grep搜索内容串可以是正则表达式。 &emsp;&emsp;正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 grep常用正则表达式： 参数 含义 ^a 行首,搜寻以 m 开头的行；grep -n ‘^a’ 1.txt ke$ 行尾,搜寻以 ke 结束的行；grep -n ‘ke$’ 1.txt [Ss]igna[Ll] 匹配 [] 里中一系列字符中的一个；搜寻匹配单词signal、signaL、Signal、SignaL的行；grep -n ‘[Ss]igna[Ll]’ 1.txt . (点)匹配一个非换行符的字符；匹配 e 和 e 之间有任意一个字符，可以匹配 eee，eae，eve，但是不匹配 ee，eaae；grep -n ‘e.e’ 1.txt 查找文件：findfind命令功能非常强大，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。 常用用法： 命令 含义 find ./ -name test.sh 查找当前目录下所有名为test.sh的文件 find ./ -name ‘*.sh’ 查找当前目录下所有后缀为.sh的文件 find ./ -name “[A-Z]*” 查找当前目录下所有以大写字母开头的文件 find /tmp -size 2M 查找在/tmp 目录下等于2M的文件 find /tmp -size +2M 查找在/tmp 目录下大于2M的文件 find /tmp -size -2M 查找在/tmp 目录下小于2M的文件 find ./ -size +4k -size -5M 查找当前目录下大于4k，小于5M的文件 find ./ -perm 777 查找当前目录下权限为 777 的文件或目录 拷贝文件：cpcp命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS下的copy命令。 常用选项说明： 选项 含义 -a 该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。 -f 已经存在的目标文件而不提示 -i 交互式复制，在覆盖目标文件之前将给出提示要求用户确认 -r 若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。 -v 显示拷贝进度 移动文件：mv用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名。 常用选项说明： 选项 含义 -f 禁止交互式操作，如有覆盖也不会给出提示 -i 确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问是否重写，要求用户回答以避免误覆盖文件 -v 显示移动进度 归档管理：tar计算机中的数据经常需要备份，tar是Unix/Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。 tar使用格式 tar [参数] 打包文件名 文件 tar命令很特殊，其参数前面可以使用“-”，也可以不使用。 常用参数： 参数 含义 -c 生成档案文件，创建打包文件 -v 列出归档解档的详细过程，显示进度 -f 指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后 -t 列出档案中包含的文件 -x 解开档案文件 注意：除了f需要放在参数的最后，其它参数的顺序任意。 文件压缩解压：gziptar与gzip命令结合使用实现文件打包、压缩。 tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz。 gzip使用格式如下： gzip [选项] 被压缩文件 常用选项： 选项 含义 -d 解压 -r 压缩所有子目录 tar这个命令并没有压缩的功能，它只是一个打包的命令，但是在tar命令中增加一个选项(-z)可以调用gzip实现了一个压缩的功能，实行一个先打包后压缩的过程。 压缩用法：tar cvzf 压缩包包名 文件1 文件2 ... -z ：指定压缩包的格式为：file.tar.gz 解压用法： tar zxvf 压缩包包名 -z:指定压缩包的格式为：file.tar.gz 解压到指定目录：-C （大写字母“C”） 文件压缩解压：bzip2tar与bzip2命令结合使用实现文件打包、压缩(用法和gzip一样)。 tar只负责打包文件，但不压缩，用bzip2压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz2。 在tar命令中增加一个选项(-j)可以调用bzip2实现了一个压缩的功能，实行一个先打包后压缩的过程。 压缩用法：tar -jcvf 压缩包包名 文件...(tar jcvf bk.tar.bz2 *.c) 解压用法：tar -jxvf 压缩包包名 (tar jxvf bk.tar.bz2) 文件压缩解压：zip、unzip通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。 压缩文件：zip [-r] 目标文件(没有扩展名) 源文件 解压文件：unzip -d 解压后目录文件 压缩文件 查看命令位置：which例如：which ls]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise4]]></title>
    <url>%2F2018%2F10%2F03%2FExercise4%2F</url>
    <content type="text"><![CDATA[python项目之2048小游戏&emsp;&emsp;2048是一个非常简单的小游戏，对于刚学python的萌新来说，用来练练手也是非常不错的选择。下面利用python自带的tkinter来实现2048的界面设计。 一、总体框架设计 首先设计大的窗口，然后是4x4小格子 然后在下面显示分数，上下左右，重置，退出。通过鼠标点击来实现操作12345678910111213141516171819202122232425262728# 大窗口window=tk.Tk()window.title(&apos;2048&apos;)window.geometry(&apos;330x560&apos;) # 绘制初始的界面lab = &#123;&#125;Ox, Oy = 10, 10for i in range(4): for j in range(4): tlx=Ox+j*80 tly=Oy+i*80 num = i * 4 + j key = str(board[i][j]) # height，width值按字符来设置 l = tk.Label(window, text=board[i][j], bg=color[key], font=(&apos;Arial&apos;, 20), height=2, width=4) lab[num] = l l.place(x=tlx,y=tly)# 下面的控制，分数显示窗口，分数用数组中最大值表示tk.Label(window,text=&apos;分数:&apos;,bg=&apos;gray96&apos;,font=(&apos;微软雅黑&apos;,15)).place(x=10,y=330)tk.Label(window, textvariable=va, bg=&apos;gray96&apos;, font=(&apos;微软雅黑&apos;, 15)).place(x=70, y=330)tk.Button(window, text=&apos;上&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=up_op).place(x=130, y=360)tk.Button(window, text=&apos;下&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=down_op).place(x=130, y=465)tk.Button(window, text=&apos;左&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=left_op).place(x=55, y=410)tk.Button(window, text=&apos;右&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=right_op).place(x=205, y=410)tk.Button(window, text=&apos;重置&apos;, bg=&apos;gray86&apos;, font=(&apos;微软雅黑&apos;, 15), width=4, height=1, command=restart_op).place(x=20,y=510)tk.Button(window, text=&apos;退出&apos;, bg=&apos;gray86&apos;, font=(&apos;微软雅黑&apos;, 15), width=4, height=1, command=exit_op).place(x=245,y=510) 二、功能具体实现 初始化操作：随机在数组中找两个位置，然后各随机分配2或4,2概率为75%，initi之前应该将数组清零。 状态机：初始化后游戏进入game状态，然后游戏可能进入win，gameover这两种状态，还可以人为的重置退出。而在win，gameover状态也可以人为的重置退出。那怎样判断win，gameover呢？当分数值为2048时进入win状态，当数组中非零个数为16且没有两个相同数字相邻时进入gameover状态代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243def is_same_neibor(a): for i in range(4): for j in range(4): if i &lt; 3 and j &lt; 3: if a[i][j] == a[i][j+1] or a[i][j] == a[i+1][j]: return True elif i == 3 and j &lt; 3: if a[i][j] == a[i][j+1]: return True elif j == 3 and i &lt; 3: if a[i][j] == a[i+1][j]: return True return False def judge_state(a): # 判定数组此时状态，max_num记录数组中最大值且为当前分值 count = update(a) max_num=np.max(a) va.set(max_num) if max_num == 2048: round_over=True var1 = tk.messagebox.askyesno(title=&apos;闯关成功！&apos;, message=&apos;你想再来一次吗？&apos;) if var1: for i in range(4): for j in range(4): a[i][j]=0 initi(a) round_over=False update(a) else: window.destroy() if count == 16 and is_same_neibor(a) == False: round_over=True var2 = tk.messagebox.askyesno(title=&apos;闯关失败！&apos;, message=&apos; Game Over!\n你想再试一次吗？&apos;) if var2: for i in range(4): for j in range(4): a[i][j]=0 initi(a) round_over=False update(a) else: window.destroy() 六种运算操作： 向左移动且合并 向右移动且合并 向上移动且合并 向下移动且合并 重置 退出以向左移动且合并为例，向右移动且合并可以根据向左操作模仿操作，向上向下可通过转置和向左来实现1234567891011121314151617 def left_move(a): # 将非零数字左移 k = 0 for i in range(4): if a[i] != 0: a[k] = a[i] k += 1 if k &lt; 4: for j in range(k, 4): a[j] = 0def left_add(a): #将非零相同数字左合并 for i in range(3): if a[i] == a[i + 1]: a[i] = a[i] * 2 if i + 1 &lt; 3: for k in range(i + 1, 3): a[k] = a[k + 1] a[3] = 0 重置和退出： 123456789def restart_op(): for i in range(4): for j in range(4): board[i][j] = 0 initi(board) update(board)def exit_op(): window.destroy() game状态随机数产生和产生时机 123456789101112131415 def compare(a,b): # 数组移动前后比较，若不同则产生随机数，否则不产生 n_equal=False for i in range(4): for j in range(4): if a[i][j]!=b[i][j]: n_equal=True break return n_equaldef produce_rand(a): #在随机为零的位置随机产生一个数 p = random.randint(0, 3) q = random.randint(0, 3) while (board[p][q] != 0): p = random.randint(0, 3) q = random.randint(0, 3) board[p][q] = random.choice([2, 2, 2, 4]) 移动后更新： 12345678910def update(a): #更新，统计数组中非零元素个数且返回，用于后面判断数组状态。并更新颜色 count = 0 for i in range(4): for j in range(4): if a[i][j]: count += 1 num = i * 4 + j c_key = str(a[i][j]) lab[num].config(text=a[i][j], bg=color[c_key]) return count 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229from tkinter import messageboximport tkinter as tkimport numpy as npimport randomdef main(): # 初始化，创造一个窗口，显示title，窗口大小 window=tk.Tk() window.title(&apos;2048&apos;) window.geometry(&apos;330x560&apos;) # 不同的分数不同的颜色 round_over=False color = &#123;&apos;0&apos;: &apos;gray86&apos;, &apos;2&apos;: &apos;green1&apos;, &apos;4&apos;: &apos;cyan&apos;, &apos;8&apos;: &apos;blue1&apos;, &apos;16&apos;: &apos;pink4&apos;, &apos;32&apos;: &apos;yellow1&apos;, &apos;64&apos;: &apos;yellow4&apos;, &apos;128&apos;: &apos;pink&apos;,&apos;256&apos;: &apos;green4&apos;, &apos;512&apos;: &apos;yellow4&apos;, &apos;1024&apos;: &apos;orange4&apos;, &apos;2048&apos;: &apos;red&apos;&#125; # 初始化，随机在数组中找两个位置，然后各随机分配2或4,2概率为75%，initi之前应该将数组清零。 def initi(a): m1 = random.randint(0, 3) #从0到3之间产生一个随机整数（包含端点） n1 = random.randint(0, 3) m2 = random.randint(0, 3) n2 = random.randint(0, 3) while ((m1 == m2) and (n1 == n2)): m2 = random.randint(0, 3) n2 = random.randint(0, 3) a[m1][n1] = random.choice([2, 2, 2, 4]) #从列表中随机选中一个数 a[m2][n2] = random.choice([2, 2, 2, 4]) # 创建原始数组 board = np.zeros((4, 4), dtype=np.int16) initi(board) # 绘制初始的界面 lab = &#123;&#125; Ox, Oy = 10, 10 for i in range(4): for j in range(4): tlx=Ox+j*80 tly=Oy+i*80 num = i * 4 + j key = str(board[i][j]) # height，width值按字符来设置 l = tk.Label(window, text=board[i][j], bg=color[key], font=(&apos;Arial&apos;, 20), height=2, width=4) lab[num] = l l.place(x=tlx,y=tly) # 定义各种操作函数 def left_move(a): # 将非零数字左移 k = 0 for i in range(4): if a[i] != 0: a[k] = a[i] k += 1 if k &lt; 4: for j in range(k, 4): a[j] = 0 def right_move(a): k = 3 for i in range(4): if a[3 - i] != 0: a[k] = a[3 - i] k -= 1 if k &gt; 0: for j in range(0, k + 1): a[j] = 0 def left_add(a): #将非零相同数字左合并 for i in range(3): if a[i] == a[i + 1]: a[i] = a[i] * 2 if i + 1 &lt; 3: for k in range(i + 1, 3): a[k] = a[k + 1] a[3] = 0 def right_add(a): for i in range(3): if a[3 - i] == a[2 - i]: a[3 - i] = a[3 - i] * 2 if 2 - i &gt; 0: for k in range(1, 3 - i): a[3 - i - k] = a[2 - i - k] a[0] = 0 def produce_rand(a): #在随机为零的位置随机产生一个数 p = random.randint(0, 3) q = random.randint(0, 3) while (board[p][q] != 0): p = random.randint(0, 3) q = random.randint(0, 3) board[p][q] = random.choice([2, 2, 2, 4]) def update(a): #更新，统计数组中非零元素个数且返回，用于后面判断数组状态。并更新颜色 count = 0 for i in range(4): for j in range(4): if a[i][j]: count += 1 num = i * 4 + j c_key = str(a[i][j]) lab[num].config(text=a[i][j], bg=color[c_key]) return count def is_same_neibor(a): for i in range(4): for j in range(4): if i &lt; 3 and j &lt; 3: if a[i][j] == a[i][j+1] or a[i][j] == a[i+1][j]: return True elif i == 3 and j &lt; 3: if a[i][j] == a[i][j+1]: return True elif j == 3 and i &lt; 3: if a[i][j] == a[i+1][j]: return True return False def judge_state(a): # 判定数组此时状态，max_num记录数组中最大值且为当前分值 count = update(a) max_num=np.max(a) va.set(max_num) if max_num == 2048: round_over=True var1 = tk.messagebox.askyesno(title=&apos;闯关成功！&apos;, message=&apos;你想再来一次吗？&apos;) if var1: for i in range(4): for j in range(4): a[i][j]=0 initi(a) round_over=False update(a) else: window.destroy() if count == 16 and is_same_neibor(a) == False: round_over=True var2 = tk.messagebox.askyesno(title=&apos;闯关失败！&apos;, message=&apos; Game Over!\n你想再试一次吗？&apos;) if var2: for i in range(4): for j in range(4): a[i][j]=0 initi(a) round_over=False update(a) else: window.destroy() def compare(a,b): n_equal=False for i in range(4): for j in range(4): if a[i][j]!=b[i][j]: n_equal=True break return n_equal # 进行运算操作 def up_op(): ob=board.copy() tb = board.T for i in range(4): left_move(tb[i]) left_add(tb[i]) m = tb.T for i in range(4): for j in range(4): board[i][j] = m[i][j] if compare(ob,board): produce_rand(board) judge_state(board) def down_op(): ob = board.copy() tb = board.T for i in range(4): right_move(tb[i]) right_add(tb[i]) m = tb.T for i in range(4): for j in range(4): board[i][j] = m[i][j] if compare(ob, board): produce_rand(board) judge_state(board) def left_op(): ob = board.copy() for i in range(4): left_move(board[i]) left_add(board[i]) if compare(ob, board): produce_rand(board) judge_state(board) def right_op(): ob = board.copy() for i in range(4): right_move(board[i]) right_add(board[i]) if compare(ob, board): produce_rand(board) judge_state(board) def restart_op(): for i in range(4): for j in range(4): board[i][j] = 0 initi(board) update(board) def exit_op(): window.destroy() # 创建按钮和标签 va=tk.StringVar() va.set(0) tk.Label(window,text=&apos;分数:&apos;,bg=&apos;gray96&apos;,font=(&apos;微软雅黑&apos;,15)).place(x=10,y=330) tk.Label(window, textvariable=va, bg=&apos;gray96&apos;, font=(&apos;微软雅黑&apos;, 15)).place(x=70, y=330) tk.Button(window, text=&apos;上&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=up_op).place(x=130, y=360) tk.Button(window, text=&apos;下&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=down_op).place(x=130, y=465) tk.Button(window, text=&apos;左&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=left_op).place(x=55, y=410) tk.Button(window, text=&apos;右&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=right_op).place(x=205, y=410) tk.Button(window, text=&apos;重置&apos;, bg=&apos;gray86&apos;, font=(&apos;微软雅黑&apos;, 15), width=4, height=1, command=restart_op).place(x=20,y=510) tk.Button(window, text=&apos;退出&apos;, bg=&apos;gray86&apos;, font=(&apos;微软雅黑&apos;, 15), width=4, height=1, command=exit_op).place(x=245,y=510) window.mainloop()if __name__==&apos;__main__&apos;: main() 相关链接 http://python.jobbole.com/84971/ https://www.shiyanlou.com/courses/reports/1283118 https://blog.csdn.net/qq_39451109/article/details/78161438 https://blog.csdn.net/yjy_aii/article/details/78071955]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>tkinter</tag>
        <tag>2048</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise_3_飞机大战]]></title>
    <url>%2F2018%2F09%2F26%2F2018%2F2018-09-25-%E7%AC%AC%E4%B8%89%E4%B8%AApython%E9%A1%B9%E7%9B%AE-%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一个小练习，飞机大战，主要有四个类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227import pygamefrom pygame.locals import *import randomimport time&apos;&apos;&apos;说明爆炸效果的原理是:换图片&apos;&apos;&apos;class Hero(object): def __init__(self, screen_temp): self.x = 210 self.y = 590 self.image = pygame.image.load(&quot;./feiji/hero1.png&quot;) self.screen = screen_temp self.bullet_list = []#用来存储子弹对象的引用 &quot;&quot;&quot; #爆炸效果用的如下属性 self.hit = False #表示是否要爆炸 self.bomb_list = [] #用来存储爆炸时需要的 图片 self.__crate_images() #调用这个方法向bomb_list中添加图片 self.image_num = 0#用来记录while True的次数,当次数达到一定值时才显示一张爆炸的图,然后清空,,当这个次数再次达到时,再显示下一个爆炸效果的图片 self.image_index = 0#用来记录当前要显示的爆炸效果的图片的序号 def __crate_images(self): self.bomb_list.append(pygame.image.load(&quot;./feiji/hero_blowup_n1.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/hero_blowup_n2.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/hero_blowup_n3.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/hero_blowup_n4.png&quot;)) &quot;&quot;&quot; def display(self, enemy_temp): &quot;&quot;&quot;显示玩家的飞机&quot;&quot;&quot; #如果被击中,就显示爆炸效果,否则显示普通的飞机效果 &quot;&quot;&quot; if self.hit == True: self.screen.blit(self.bomb_list[self.image_index], (self.x, self.y)) self.image_num+=1 if self.image_num == 7: self.image_num=0 self.image_index+=1 if self.image_index&gt;3: time.sleep(1) exit()#调用exit让游戏退出 #self.image_index = 0 &quot;&quot;&quot; #else: self.screen.blit(self.image,(self.x, self.y)) #不管玩家飞机是否被击中,都要显示发射出去的子弹 for bullet in self.bullet_list: bullet.display() bullet.move(enemy_temp) if bullet.judge():#判断子弹是否越界 self.bullet_list.remove(bullet) def move_left(self): self.x -= 8 def move_right(self): self.x += 8 def fire(self): &quot;&quot;&quot;通过创建一个子弹对象,完成发射子弹&quot;&quot;&quot; print(&quot;-----1----&quot;) bullet = Bullet(self.screen, self.x, self.y)#创建一个子弹对象 self.bullet_list.append(bullet) def bomb(self): self.hit = Trueclass Bullet(object): def __init__(self, screen_temp, x_temp, y_temp): self.x = x_temp+40 self.y = y_temp-20 self.image = pygame.image.load(&quot;./feiji/bullet.png&quot;) self.screen = screen_temp def display(self): self.screen.blit(self.image, (self.x, self.y)) def move(self, enemy_temp): if self.x &gt; enemy_temp.x and self.x &lt; enemy_temp.x + 50 and self.y &lt; 40: enemy_temp.bomb() else: self.y -= 20 def judge(self): if self.y&lt;0: return True else: return Falseclass EnemyPlane(object): def __init__(self, screen_temp): self.x = 0 self.y = 0 self.image = pygame.image.load(&quot;./feiji/enemy0.png&quot;) self.screen = screen_temp self.bullet_list = []#用来存储子弹对象的引用 self.direction = &quot;right&quot;#用来设置这个飞机默认的移动方向 #爆炸效果用的如下属性 self.hit = False #表示是否要爆炸 self.bomb_list = [] #用来存储爆炸时需要的 图片 self.__crate_images() #调用这个方法向bomb_list中添加图片 self.image_num = 0#用来记录while True的次数,当次数达到一定值时才显示一张爆炸的图,然后清空,,当这个次数再次达到时,再显示下一个爆炸效果的图片 self.image_index = 0#用来记录当前要显示的爆炸效果的图片的序号 def __crate_images(self): self.bomb_list.append(pygame.image.load(&quot;./feiji/enemy0_down1.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/enemy0_down2.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/enemy0_down3.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/enemy0_down4.png&quot;)) def display(self): &quot;&quot;&quot;显示敌人的飞机&quot;&quot;&quot; if self.hit == True: self.screen.blit(self.bomb_list[self.image_index], (self.x, self.y)) self.image_num+=1 if self.image_num == 7: self.image_num=0 self.image_index+=1 if self.image_index&gt;3: time.sleep(1) exit()#调用exit让游戏退出 #self.image_index = 0 else: self.screen.blit(self.image,(self.x, self.y)) for bullet in self.bullet_list: bullet.display() bullet.move() if bullet.judge():#判断子弹是否越界 self.bullet_list.remove(bullet) def move(self): if self.direction == &quot;right&quot;: self.x+=5 elif self.direction == &quot;left&quot;: self.x-=5 if self.x&gt;480-50: self.direction=&quot;left&quot; elif self.x&lt;0: self.direction=&quot;right&quot; def fire(self): random_num = random.randint(1,100) if random_num == 8 or random_num == 20: self.bullet_list.append(EnemyBullet(self.screen, self.x, self.y)) def bomb(self): self.hit = Trueclass EnemyBullet(object): def __init__(self, screen_temp, x, y): self.x = x+25 self.y = y+40 self.screen = screen_temp self.image = pygame.image.load(&quot;./feiji/bullet1.png&quot;) def display(self): self.screen.blit(self.image, (self.x, self.y)) def move(self): self.y+=5 def judge(self): if self.y&gt;720: return True else: return Falsedef key_control(hero_temp): #获取事件，比如按键等 for event in pygame.event.get(): #判断是否是点击了退出按钮 if event.type == QUIT: print(&quot;exit&quot;) exit() #判断是否是按下了键 elif event.type == KEYDOWN: #检测按键是否是a或者left if event.key == K_a or event.key == K_LEFT: print(&apos;left&apos;) hero_temp.move_left() #检测按键是否是d或者right elif event.key == K_d or event.key == K_RIGHT: print(&apos;right&apos;) hero_temp.move_right() #检测按键是否是空格键 elif event.key == K_SPACE: print(&apos;space&apos;) hero_temp.fire() #elif event.key == K_b: #print(&apos;b&apos;) #hero_temp.bomb()def main(): screen = pygame.display.set_mode((480,720),0,32) background = pygame.image.load(&quot;./feiji/background.png&quot;) #创建玩家飞机 hero = Hero(screen) #创建敌机 enemy = EnemyPlane(screen) while True: screen.blit(background,(0,0)) hero.display(enemy) enemy.display() enemy.move() enemy.fire() pygame.display.update() key_control(hero) time.sleep(0.01)if __name__ == &quot;__main__&quot;: main()]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>pygame</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快排]]></title>
    <url>%2F2018%2F09%2F22%2F2018%2F2018-09-22-%E5%BF%AB%E6%8E%92%2F</url>
    <content type="text"><![CDATA[快排算法： 1、快速排序的基本思想：&emsp;&emsp;快排主要使用分治思想，基于pivot，通过一趟排序将待排序列分割成两部分，左边都不大于pivot，右边都不小于pivot。之后分别对这两部分继续进行排序，以达到整个序列有序的目的。 2、快速排序的三个步骤：(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot） ，这里将第一个元素作为第一个基准。(2)分割操作：以pivot为基准分割该序列为两部分。(3)递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。 3、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;#define n 10//对[left, right]进行划分，使pivot 左边都小于该值，右边都大于该值int Part(int A[], int left, int right)&#123; int pivot = A[left]; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; pivot &lt; A[right]) right--; A[left] = A[right]; while(left &lt; right &amp;&amp; pivot &gt;= A[left]) left++; A[right] = A[left]; &#125; A[left] = pivot; return left;&#125;//利用上面的part函数，且采用递归的方式实现快速排序void Quicksort(int A[], int left, int right)&#123; if(left &lt; right) &#123; int temp = Part(A, left, right); Quicksort(A, left, temp-1); Quicksort(A, temp+1, right); &#125;&#125;//对快排进行测试int main(int argc, char const *argv[])&#123; int array[n]; for (int i = 0; i &lt; n; ++i) cin&gt;&gt;array[i]; Quicksort(array, 0, n-1); cout&lt;&lt;array[0]; for (int i = 0; i &lt; n; ++i) cout&lt;&lt;&quot; &quot;&lt;&lt;array[i]; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>QuickSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise_2_老王开枪]]></title>
    <url>%2F2018%2F09%2F20%2Fpython%E9%A1%B9%E7%9B%AE%2F%E8%80%81%E7%8E%8B%E5%BC%80%E6%9E%AA%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一个小小项目，主要练习类，对象的使用流程。下面是代码来自网上学习视频，作为练习所用:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189class Person(object): &quot;&quot;&quot;人的类&quot;&quot;&quot; def __init__(self, name): super(Person, self).__init__() self.name = name self.gun = None#用来保存枪对象的引用 self.hp = 100 def anzhuang_zidan(self, dan_jia_temp, zi_dan_temp): &quot;&quot;&quot;把子弹装到弹夹中&quot;&quot;&quot; #弹夹.保存子弹(子弹) dan_jia_temp.baocun_zidan(zi_dan_temp) def anzhuang_danjia(self, gun_temp, dan_jia_temp): &quot;&quot;&quot;把弹夹安装到枪中&quot;&quot;&quot; #枪.保存弹夹(弹夹) gun_temp.baocun_danjia(dan_jia_temp) def naqiang(self, gun_temp): &quot;&quot;&quot;拿起一把枪&quot;&quot;&quot; self.gun = gun_temp def __str__(self): if self.gun: return &quot;%s的血量为:%d, 他有枪 %s&quot;%(self.name, self.hp, self.gun) else: if self.hp&gt;0: return &quot;%s的血量为%d, 他没有枪&quot;%(self.name, self.hp) else: return &quot;%s 已挂....&quot;%self.name def kou_ban_ji(self, diren): &quot;&quot;&quot;让枪发射子弹去打敌人&quot;&quot;&quot; #枪.开火(敌人) self.gun.fire(diren) def xiao_xue(self, sha_shang_li): &quot;&quot;&quot;根据杀伤力，掉相应的血量&quot;&quot;&quot; self.hp -= sha_shang_liclass Gun(object): &quot;&quot;&quot;枪类&quot;&quot;&quot; def __init__(self, name): super(Gun, self).__init__() self.name = name#用来记录枪的类型 self.danjia = None#用来记录弹夹对象的引用 def baocun_danjia(self, dan_jia_temp): &quot;&quot;&quot;用一个属性来保存这个弹夹对象的引用&quot;&quot;&quot; self.danjia = dan_jia_temp def __str__(self): if self.danjia: return &quot;枪的信息为:%s, %s&quot;%(self.name, self.danjia) else: return &quot;枪的信息为:%s,这把枪中没有弹夹&quot;%(self.name) def fire(self, diren): &quot;&quot;&quot;枪从弹夹中获取一发子弹，然后让这发子弹去击中敌人&quot;&quot;&quot; #先从弹夹中取子弹 #弹夹.弹出一发子弹() zidan_temp = self.danjia.tanchu_zidan() #让这个子弹去伤害敌人 if zidan_temp: #子弹.打中敌人(敌人) zidan_temp.dazhong(diren) else: print(&quot;弹夹中没有子弹了。。。。&quot;)class Danjia(object): &quot;&quot;&quot;弹夹类&quot;&quot;&quot; def __init__(self, max_num): super(Danjia, self).__init__() self.max_num = max_num#用来记录弹夹的最大容量 self.zidan_list = []#用来记录所有的子弹的引用 def baocun_zidan(self, zi_dan_temp): &quot;&quot;&quot;将这颗子弹保存&quot;&quot;&quot; self.zidan_list.append(zi_dan_temp) def __str__(self): return &quot;弹夹的信息为:%d/%d&quot;%(len(self.zidan_list), self.max_num) def tanchu_zidan(self): &quot;&quot;&quot;弹出最上面的那颗子弹&quot;&quot;&quot; if self.zidan_list: return self.zidan_list.pop() else: return Noneclass Zidan(object): &quot;&quot;&quot;子弹类&quot;&quot;&quot; def __init__(self, sha_shang_li): super(Zidan, self).__init__() self.sha_shang_li = sha_shang_li#这颗子弹的威力 def dazhong(self, diren): &quot;&quot;&quot;让敌人掉血&quot;&quot;&quot; #敌人.掉血(一颗子弹的威力) diren.xiao_xue(self.sha_shang_li)def main(): &quot;&quot;&quot;用来控制整个程序的流程&quot;&quot;&quot; #1. 创建老王对象 laowang = Person(&quot;老王&quot;) #2. 创建一个枪对象 ak47 = Gun(&quot;AK47&quot;) #3. 创建一个弹夹对象 dan_jia = Danjia(20) #4. 创建一些子弹 for i in range(15): zi_dan = Zidan(10) #5. 老王把子弹安装到弹夹中 #老王.安装子弹到弹夹中(弹夹，子弹) laowang.anzhuang_zidan(dan_jia, zi_dan) #6. 老王把弹夹安装到枪中 #老王.安装弹夹到枪中(枪，弹夹) laowang.anzhuang_danjia(ak47, dan_jia) #test:测试弹夹的信息 #print(dan_jia) #test:测试枪的信息 #print(ak47) #7. 老王拿枪 #老王.拿枪(枪) laowang.naqiang(ak47) #test:测试老王对象 print(laowang) #8. 创建一个敌人 gebi_laosong = Person(&quot;隔壁老宋&quot;) print(gebi_laosong) #9. 老王开枪打敌人 #老王.扣扳机(隔壁老宋) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang)if __name__ == &apos;__main__&apos;: main() 配上下面的图更好理解：]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>类，对象</tag>
        <tag>流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1090 危险品装箱 （25 分）]]></title>
    <url>%2F2018%2F09%2F19%2F2018%2F2018-09-19-1090-%E5%8D%B1%E9%99%A9%E5%93%81%E8%A3%85%E7%AE%B1-%EF%BC%8825-%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1090 危险品装箱 （25 分）集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。 输入格式：输入第一行给出两个正整数：N (≤10$^{4}$) 是成对的不相容物品的对数；M (≤100) 是集装箱货品清单的单数。 随后数据分两大块给出。第一块有 N 行，每行给出一对不相容的物品。第二块有 M 行，每行给出一箱货物的清单，格式如下： K G[1] G[2] … G[K]其中 K (≤1000) 是物品件数，G[i] 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。 输出格式：对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No。 输入样例：123456789106 320001 2000220003 2000420005 2000620003 2000120005 2000420004 200064 00001 20004 00002 200035 98823 20002 20003 20006 100103 12345 67890 23333 输出样例：123NoYesYes 解题思路： map&lt;int, vector &gt; mp字典用来将每个物品与其不相容的物品序列配对 a[10000] = {0}：用来标记物品是否存在 vector g(count): 存放每箱物品清单编号 思路：先配对，然后对每箱物品清单的每个物品判断它的不相容数组中是否有标记，有的话no, 用flag == 1表示。最后为1，即有不相容物品对。若最后还是初始时的0则表示无不相容物品对。12345678910111213141516171819202122232425262728#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main() &#123; int n, m, number1, number2; map&lt;int,vector&lt;int&gt;&gt; mp; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;number1&gt;&gt;number2; mp[number1].push_back(number2); mp[number2].push_back(number1); &#125; while (m--) &#123; int count, flag = 0, a[100000] = &#123;0&#125;; scanf(&quot;%d&quot;, &amp;count); vector&lt;int&gt; g(count); for (int i = 0; i &lt; count; i++) &#123; cin&gt;&gt;g[i]; a[g[i]] = 1; &#125; for (int i = 0; i &lt; g.size(); i++) for (int j = 0; j &lt; mp[g[i]].size(); j++) if (a[mp[g[i]][j]] == 1) flag = 1; printf(&quot;%s\n&quot;,flag ==0 ? &quot;Yes&quot; :&quot;No&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm Practice</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>STL</tag>
        <tag>map</tag>
        <tag>配对问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1089 狼人杀-简单版 （20 分）]]></title>
    <url>%2F2018%2F09%2F19%2F2018%2F2018-09-19-1089-%E7%8B%BC%E4%BA%BA%E6%9D%80-%E7%AE%80%E5%8D%95%E7%89%88-%EF%BC%8820-%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1089 狼人杀-简单版 （20 分）以下文字摘自《灵机一动·好玩的数学》：“狼人杀”游戏分为狼人、好人两大阵营。在一局“狼人杀”游戏中，1 号玩家说：“2 号是狼人”，2 号玩家说：“3 号是好人”，3 号玩家说：“4 号是狼人”，4 号玩家说：“5 号是好人”，5 号玩家说：“4 号是好人”。已知这 5 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。扮演狼人角色的是哪两号玩家？本题是这个问题的升级版：已知 N 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。要求你找出扮演狼人角色的是哪几号玩家？ 输入格式：输入在第一行中给出一个正整数 N（5≤N≤100）。随后 N 行，第 i 行给出第 i 号玩家说的话（1≤i≤N），即一个玩家编号，用正号表示好人，负号表示狼人。 输出格式：如果有解，在一行中按递增顺序输出 2 个狼人的编号，其间以空格分隔，行首尾不得有多余空格。如果解不唯一，则输出最小序列解 —— 即对于两个序列 A=a[1],…,a[M] 和 B=b[1],…,b[M]，若存在 0≤ k&lt; M 使得 a[i]=b[i] （i≤k），且 a[k+1]&lt;b[k+1]，则称序列 A 小于序列 B。若无解则输出 No Solution。输入样例 1：5-2+3-4+5+4输出样例 1：1 4输入样例 2：6+6+3+1-5-2+4输出样例 2（解不唯一）：1 5输入样例 3：5-2-3-4-5-1输出样例 3：No Solution 解题思路： speak[k]数组用来保存k号玩家所说的话 lang_hao[k] 表示k号玩家是狼人还是好人，好人为1，狼人为-1 lie[]存放说谎者的序号 思路：先存speak；然后用两循环令i，j为狼人遍历这n个玩家。当狼人确定后，好人同时确认。接着再用一层循环来判断k号玩家是否说谎，说谎者序号放进lie[]。最后，当lie[]数组大小为2且一个为狼人一个为好人时，输出i，j并结束程序。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; speak(n + 1); for (int i = 1; i &lt;= n; ++i) cin&gt;&gt;speak[i]; for (int i = 1; i &lt;= n; ++i)&#123; for (int j = i + 1; j &lt;= n; ++j) &#123; vector&lt;int&gt; lie, lang_hao(n + 1, 1); lang_hao[i] = lang_hao[j] = -1; for(int k = 1; k&lt;=n; k++)&#123; if(speak[k] * lang_hao[abs(speak[k])] &lt; 0) lie.push_back(k); &#125; if(lie.size() == 2 &amp;&amp; lang_hao[lie[0]] + lang_hao[lie[1]] == 0)&#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j; return 0; &#125; &#125; &#125; cout &lt;&lt; &quot;No Solution&quot;; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm Practice</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>STL</tag>
        <tag>狼人杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1088 三人行 （20 分）]]></title>
    <url>%2F2018%2F09%2F19%2F2018%2F2018-09-19-1088-%E4%B8%89%E4%BA%BA%E8%A1%8C-%EF%BC%8820-%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1088 三人行 （20 分）子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。” 本题给定甲、乙、丙三个人的能力值关系为：甲的能力值确定是 2 位正整数；把甲的能力值的 2 个数字调换位置就是乙的能力值；甲乙两人能力差是丙的能力值的 X 倍；乙的能力值是丙的 Y 倍。请你指出谁比你强应“从之”，谁比你弱应“改之”。输入格式：输入在一行中给出三个数，依次为：M（你自己的能力值）、X 和 Y。三个数字均为不超过 1000 的正整数。 输出格式：在一行中首先输出甲的能力值，随后依次输出甲、乙、丙三人与你的关系：如果其比你强，输出 Cong；平等则输出 Ping；比你弱则输出 Gai。其间以 1 个空格分隔，行首尾不得有多余空格。 注意：如果解不唯一，则以甲的最大解为准进行判断；如果解不存在，则输出 No Solution。 输入样例 1：48 3 7输出样例 1：48 Ping Cong Gai输入样例 2：48 11 6输出样例 2：No Solution 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int i, j; int m, x, y; double a[3] = &#123;0&#125;;//丙可能是小数，所以用double cin&gt;&gt;m&gt;&gt;x&gt;&gt;y; for(i = 99; i &gt;= 10; --i)&#123;//i表示甲，j为乙 j = i%10*10 + i/10; if(j * x == y * abs(j - i))&#123;1089 狼人杀-简单版 （20 分） printf(&quot;%d&quot;,i); a[0] = i; a[1] = j; a[2] = j * 1.0/y; break; &#125; &#125; for(int i = 0; i &lt; 3; i++)&#123; if(a[i] == 0) &#123; printf(&quot;No Solution&quot;); break; &#125; else if(m &gt; a[i]) printf(&quot; Gai&quot;); else if(m == a[i]) printf(&quot; Ping&quot;); else printf(&quot; Cong&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm Practice</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1087 有多少不同的值]]></title>
    <url>%2F2018%2F09%2F19%2F2018%2F2018-09-19-1087-%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[1087 有多少不同的值 （20 分）&emsp;&emsp;当自然数 n 依次取 1、2、3、……、N 时，算式 ⌊n/2⌋+⌊n/3⌋+⌊n/5⌋ 有多少个不同的值？（注：⌊x⌋ 为取整函数，表示不超过 x 的最大自然数，即 x 的整数部分。）输入格式：输入给出一个正整数 N（2 ≤ N ≤ 10$^{4}$)。1088 三人行 （20 分）输出格式：在一行中输出题面中算式取到的不同值的个数。 输入样例：12017 输出样例：11480 有两种解法：第一种：12345678910111213141516171819#include &lt;iostream&gt;using namespace std;const int maxn = 100001;int main() &#123; bool flag[maxn] = &#123;false&#125;;//通过hash表来去重 int n, temp; cin&gt;&gt;n; for (int i = 1; i &lt;= n; i++) &#123; temp = i/2 +i/3 + i/5; flag[temp] = true; &#125; int count = 0; for(int i = 0; i &lt; maxn; i++)&#123; if(flag[i] == true) count++; &#125; cout&lt;&lt;count&lt;&lt;endl; return 0;&#125; 第二种：123456789101112131415#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); set&lt;int&gt; st; //通过集合来去重 for (int i = 1; i &lt;= n; i++) &#123; st.insert(i/2 + i/3 + i/5); &#125; printf(&quot;%d&quot;, st.size()); return 0;&#125; &emsp;&emsp;太简单了没啥好讲的。。。]]></content>
      <categories>
        <category>Algorithm Practice</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1086 就不告诉你 （15 分）]]></title>
    <url>%2F2018%2F09%2F18%2F2018%2F2018-09-18-1086-%E5%B0%B1%E4%B8%8D%E5%91%8A%E8%AF%89%E4%BD%A0-%EF%BC%8815-%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1086 就不告诉你 （15 分）&emsp;&emsp;做作业的时候，邻座的小盆友问你：“五乘以七等于多少？”你应该不失礼貌地围笑着告诉他：“五十三。”本题就要求你，对任何一对给定的正整数，倒着输出它们的乘积。 输入格式：&emsp;&emsp;输入在第一行给出两个不超过 1000 的正整数 A 和 B，其间以空格分隔。 输出格式：&emsp;&emsp;在一行中倒着输出 A 和 B 的乘积。输入样例：15 7 输出样例：153 注意：100的倒序为1。这个很重要，没有得满分的基本都是没注意这点，其他没啥好讲的。 1234567891011121314151617181920#include &lt;cstdio&gt;int main()&#123; int a, b, count = 0, c, ans[10];//基本输入和计算 bool flag = false; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); c = a * b; while(c &gt; 0)&#123;//得到倒序的各元素数组 ans[count++] = c % 10; c /= 10; &#125; for(int i = 0; i &lt; count; i++) &#123;//将前面的0去掉 if(ans[i] != 0) flag = true; if(flag == true) printf(&quot;%d&quot;, ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm Practice</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise_1]]></title>
    <url>%2F2018%2F09%2F16%2Fpython%E9%A1%B9%E7%9B%AE%2Fpython%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[这个系统非常简单，主要目的是练习python的基本操作 下面是主要功能:12345678 名片管理系统 V0.011. 添加一个新名片2. 删除一个名片3. 修改一个名片4. 查询一个名片5. 显示所有名片6. 保存名片7. 退出系统 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127# -*- coding: utf-8 -*-card_infors = []def print_menu(): &quot;&apos;完成打印功能菜单&apos;&quot; print(&quot;=&quot; * 50) print(&quot; 名片管理系统 V0.01&quot;) print(&quot;1. 添加一个新名片&quot;) print(&quot;2. 删除一个名片&quot;) print(&quot;3. 修改一个名片&quot;) print(&quot;4. 查询一个名片&quot;) print(&quot;5. 显示所有名片&quot;) print(&quot;6. 保存名片&quot;) print(&quot;7. 退出系统&quot;) print(&quot;=&quot; * 50)def add_new_card_infor(): &quot;&apos;完成添加一个新名片&apos;&quot; new_name = input(&quot;请输入新的名字:&quot;) new_qq = input(&quot;请输入新的QQ:&quot;) new_weixin = input(&quot;请输入新的微信:&quot;) new_addr = input(&quot;请输入新的住址:&quot;) #定义一个新的字典,用来存储一个新的名片 new_infor = &#123;&#125;5 new_infor[&apos;name&apos;] = new_name new_infor[&apos;qq&apos;] = new_qq new_infor[&apos;weixin&apos;] = new_weixin new_infor[&apos;addr&apos;] = new_addr #将一个字典,添加到列表中 global card_infors card_infors.append(new_infor) #print(card_infors)# for testdef find_card_infor(): &quot;&quot;&quot;用来查询一个名片&quot;&quot;&quot; global card_infors find_name = input(&quot;请输入要查找的姓名:&quot;) find_flag = 0#默认表示没有找到 for temp in card_infors: if find_name == temp[&quot;name&quot;]: print(&quot;%s\t%s\t%s\t%s&quot;%(temp[&apos;name&apos;], temp[&apos;qq&apos;], temp[&apos;weixin&apos;], temp[&apos;addr&apos;])) find_flag=1#表示找到了 break #判断是否找到了 if find_flag == 0: print(&quot;查无此人....&quot;)def show_all_infor(): &quot;&quot;&quot;显示所有的名片信息&quot;&quot;&quot; global card_infors print(&quot;姓名\tQQ\t微信\t住址&quot;) for temp in card_infors: print(&quot;%s\t%s\t%s\t%s&quot;%(temp[&apos;name&apos;], temp[&apos;qq&apos;], temp[&apos;weixin&apos;], temp[&apos;addr&apos;]))def save_2_file(): &quot;&quot;&quot;把已经添加的信息保存到文件中&quot;&quot;&quot; f = open(&quot;backup.data&quot;, &quot;w&quot;) f.write(str(card_infors)) f.close()def load_infor(): global card_infors try: f = open(&quot;backup.data&quot;) card_infors = eval(f.read()) f.close() except Exception: passdef main(): &quot;&quot;&quot;完成对整个程序的控制&quot;&quot;&quot; #恢复(加载)之前的数据到程序中 load_infor()#刚开始启动程序就会加载内容，所以刚开始由于没有back.data文件会报错#但第二次运行时由于前面已经创建了文件不会报错，所以在load_infor()#函数中使用try，Exception #1. 打印功能提示 print_menu() while True: #2. 获取用户的输入 num = int(input(&quot;请输入操作序号:&quot;)) #3. 根据用户的数据执行相应的功能 if num==1: add_new_card_infor() elif num==2: pass elif num==3: pass elif num==4: find_card_infor() elif num==5: show_all_infor() elif num==6: save_2_file() elif num==7: break else: print(&quot;输入有误,请重新输入&quot;) print(&quot;&quot;)if __name__ == &quot;__main__&quot;: //用于测试中，当调用别的模块时，值为别的模块名字符串，调用自己时为&quot;__main__&quot; #调用主函数 main() &emsp;&emsp;该项目是学习过程中，参照学习视频所做的练习题]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 使用指南一]]></title>
    <url>%2F2018%2F09%2F16%2Fmarkdown%E4%BD%BF%E7%94%A8%2Fmarkdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%E4%B8%80%2F</url>
    <content type="text"><![CDATA[markdown 使用指南一 目录: 基本操作 专用操作 Markdow工具 1. 基本语法： 字体常见设置：下划线，加粗，删除线 字体深度设置：字体，字号，颜色，背景色 分级标题 分割线 链接 引用 列表 Todo列表 行首缩进，换行 特殊字符输入 (1) 字体常见设置：斜体，加粗，删除线&emsp;&emsp; 用一对单星号把要处理的文字包起来就会呈现斜体；用一对双星号把要处理的文字包起来就会呈现加粗；用一对双波浪线把要处理的文字包起来就会呈现斜体。1234*感觉萌萌哒***感觉萌萌哒*****感觉萌萌哒***~~ 感觉萌萌哒~~ 效果如下： 感觉萌萌哒感觉萌萌哒感觉萌萌哒感觉萌萌哒 (2) 字体深度设置：字体，字号，颜色，背景色markdown本身不支持修改字体、字号与颜色等功能，但是使用内嵌HTML的方法来实现。123&lt;font face=&quot;微软雅黑&quot;&gt;感觉萌萌哒&lt;/font&gt;&lt;font color=#0000ff size=5 face=&quot;黑体&quot;&gt;感觉萌萌哒&lt;/font&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=yellow&gt;感觉萌萌哒&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果如下： 感觉萌萌哒 感觉萌萌哒 感觉萌萌哒 注意：Size：字体大小，范围是1到7，浏览器默认值是3。 (3) 分级标题12345使用#来实现分级标题，使用&lt;center&gt;&lt;/center&gt;来居中# 感觉萌萌哒## 感觉萌萌哒### 感觉萌萌哒### &lt;center&gt;感觉萌萌哒&lt;/center&gt; 效果如下： 感觉萌萌哒感觉萌萌哒感觉萌萌哒感觉萌萌哒(4) 分割线三个连续星号(*)、减号(-)、底线(_)来实现123***---___ 效果如下： (5) 链接a. 插入图片12格式：![图片描述](图片本地或互联网url)例如：![女神刘亦菲](http://imgup02.iefans.net/iefans/2018-08/15/10/15343018604507_0.jpg) 效果如下： b. 文字加链接12格式：[文字或(本地图片位置)](url)例如：[女神刘亦菲](http://imgup02.iefans.net/iefans/2018-08/15/10/15343018604507_0.jpg) 效果如下：女神刘亦菲 c. 图片加链接12格式：[![图片描述](图片互联网url或这本地相对链接)](url)例如：[![女神刘亦菲](http://imgup02.iefans.net/iefans/2018-08/15/10/15343018604507_0.jpg)](http://imgup02.iefans.net/iefans/2018-08/15/10/15343018604507_0.jpg) 效果如下： (6) 引用 在正文前使用&gt;符号和空格 123&gt; 感觉萌萌哒&gt;&gt; 感觉萌萌哒&gt;&gt;&gt; 感觉萌萌哒 效果如下： 感觉萌萌哒 感觉萌萌哒 感觉萌萌哒 (7) 列表 列表有两种：无序列表和有序列表 a. 无序列表: 使用 *，+，-，再加上一个空格1234我是无序列表：- 萌萌哒一遍- 萌萌哒二遍- 萌萌哒三遍 我是无序列表： 萌萌哒一遍 萌萌哒二遍 萌萌哒三遍 c. 有序列表：使用数字和一个英文句点，再加上一个空格1234我是有序列表：1. 萌萌大2. 萌萌中3. 萌萌小 效果如下： 我是有序列表： 萌萌大 萌萌中 萌萌小 (8) Todo列表 用- [ ]，- [X]表示事件有没有完成(减号空格左中括号空格右中括号，减号空格左中括号x大写或小写右中括号。都这么直接了，应该不会用错了吧) 如图 今天要做的事： 吃饭 看剧 写代码 上课 (9) 行首缩进，换行直接在 Markdown 里用空格和 Tab 键缩进在渲染后会被忽略掉，需要借助 HTML 转义字符在行首添加空格来实现，&ensp; 代表半角空格，&emsp; 代表全角空格。换行：连续两个以上空格+回车或者举个栗子：1&amp;emsp;&amp;emsp;你爱不爱我，我都是萌萌哒。&lt;br&gt;感觉萌萌哒&lt;br/&gt;萌萌哒 示例效果： &emsp;&emsp;你爱不爱我，我都是萌萌哒。感觉萌萌哒萌萌哒 (10) 特殊字符输入a. 前面加反斜线\ 即可显示符号本身。12345678\\\*\.\_\-\#\&#123;\&#125;\! 效果如下：\*._-#{}!b. 特殊的转义字符12345678910111213141516171819符号 说明 对应编码¶ 段落符号 &amp;para;§ 章节符 &amp;sect;± 加减号 &amp;plusmn;ƒ function &amp;fnof;√ 根号 &amp;radic;∞ 无穷大 &amp;infin;° 度 &amp;deg;≠ 不等号 &amp;ne;≡ 恒等于 &amp;equiv;≤ 小于等于 &amp;le;≥ 大于等于 &amp;ge;♠ 黑桃 &amp;spades;♥ 红桃 &amp;hearts;♣ 梅花 &amp;clubs;♦ 方块 &amp;diams;举个栗子：黑桃&amp;spades;大于红桃&amp;hearts;大于梅花&amp;clubs;方块&amp;diams;不管是人民币&amp;yen;、欧元&amp;euro;、英磅&amp;pound;还是美元 &amp;dollar;，我都喜欢。 效果：黑桃&spades;大于红桃&hearts;大于梅花&clubs;方块&diams;不管是人民币&yen;、欧元&euro;、英磅&pound;还是美元 &dollar;，我都喜欢。本特殊符号来源自该博文 &emsp;&emsp;终于写完了第一个博客，作为一个糙老爷们用了这么多萌萌哒，我先吐会儿。。。。 &emsp;&emsp;等我吐完了再来接着写第二篇哈。。。。 本文参考文章： https://blog.csdn.net/jaywon/article/details/77992082 https://www.jianshu.com/p/c0a2897ad4eb https://blog.csdn.net/u010177286/article/details/50358720]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
</search>
