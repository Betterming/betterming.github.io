<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Blockchain3]]></title>
    <url>%2F2018%2F11%2F17%2F2018-11-17-Blockchain3%2F</url>
    <content type="text"><![CDATA[区块链三：区块链考试复习 &emsp;&emsp;感觉老是转载没啥意思，以后区块链不怎么更新了。大家如果对区块链技术感兴趣可以看一下咱们燕姐的知乎。&emsp;&emsp;另外我再推荐几个网站： 人人都懂区块链： http://www.readblocks.com/以太坊：https://ethfans.org/区块链兄弟：http://www.blockchainbrother.com/巨推链: https://www.jutuilian.com/ 区块链复习 燕姐所给复习内容： &emsp;&emsp;区块链技术提供了一种交易记录和执行的新的形式，具有去中心化、不可篡改和抵赖等优秀的性质，在金融和公共事务方面有着巨大的潜力应用。目前为止，区块链最成功的应用仍然是比特币，因此，课程中，我们主要以比特币为例子来讲解区块链。主要介绍了区块链中最基本和最重要的概念：分布式记账、共识机制、区块（Merkle树）、脚本等。在延伸介绍区块链2.0以太坊时，涉及了以太坊上智能合约的编写，以及区块链安全。最后，提及区块链3.0，讨论了PoW、PoS和DPoS的特点和区别。&emsp;&emsp;首先，我们讨论了数字货币的概念，通过回顾人类史上货币的发展历程，讨论货币的特点，它可以不具有实体、本质特征是账本上记录的交易。为了让金融系统公开、公正、不可篡改，需要一个分布式的具有不可篡改的记账系统。&emsp;&emsp;在这样的分布式记账系统的发展过程中，出现了很多优秀的思想，例如CyberPunk曾先后提出的ecash、hashcash和B-money，比特币也是在这些尝试的基础上发展而来。ecash提出了盲签的概念，“这是第一次有人认为数字本身是有价值的，这个想法是你可以通过盲签名方法来获得这些数字，且没人知道你得到的是哪个数字，但他们知道这些是有价值的数字，银行会兑现他们的款项。”HashCash中提出了工作量证明的方法，“使用部分哈希的想法是它们可以被任意地设置为昂贵的计算成本，但是可以对其立即进行验证”。B-money中提出了公共账簿和使用公钥作为身份标识的方法，交易通过网络向所有节点进行广播。&emsp;&emsp;分布式的、不可篡改、而且防止双重支付的公共账本的思想需要有强有力的技术支撑。区块链中依赖于密码学的技术，哈希和非对称加密。&emsp;&emsp;比特币区块链中使用的哈希算法是SHA-256，它有一些很好的特性，如确定性、快速计算、隐藏性、雪崩效应以及抗冲突。哈希在区块链中的应用是工作量证明，在区块链中的节点为了争取到记账的权利，需要进行大量的哈希运算，找到满足条件的随机数，才能形成链上的区块。&emsp;&emsp;比特币区块链中使用的非对称加密的算法是椭圆曲线。当前应用较广的非对称加密算法是RSA。课上我们详细介绍了RSA中公私密钥对生成的方法，以及使用RSA进行身份认证以及加密传输的过程。&emsp;&emsp;接下来我们讨论了比特币中的共识机制PoW。共识机制本质上就是要保证所有节点认可的账本是唯一的。做到这一点，在中心化的系统中很容易，但是在分布式系统中，必须要考虑到参与节点的故障可能以及潜在的恶意攻击者的情况。在区块链上，所有的交易向所有的节点广播，矿工收到的交易的内容和顺序都可能不同；而且出块有奖励的情况下，所有的节点都会尽量出块。那么由哪个节点产生区块以及如何防止恶意节点攻击（如拒绝服务、双重支付等）？PoW通过让参与节点进行算力的竞争，使得在大部分的节点是诚实节点的情况下，DoS攻击以及双重支付攻击不会成功（支付等待6次确认）；即使有节点真正掌握了51%的算力，考虑到控制算力的巨大投入，节点也会主动维持区块链的正常运行。&emsp;&emsp;在产生区块之后，接下来就是要理解区块上记录的内容。区块上的内容主要是一笔笔的交易。由于缺少对全局数据（如余额）的支持，比特币并没有采用基于账户的方式来表示交易，而是以UTXO（Unspent Transaction Output），将之前交易的输出作为新交易的输入。我们详细地察看了交易的具体内容，并介绍了输出位置上的ScriptPubKey以及输入部分的ScriptSig。先前交易的输出需要设置相应的条件，之后的交易必须要满足这个条件才能使用这笔输出中包含的钱。所以如果矿工在接收到交易时，将新交易中的ScriptSig和先前交易中的ScriptPubKey结合起来，能顺利运行结束返回True，那么这个交易便是合法的，可以被打包进区块。同时，因为所有的验证必须由矿工完成，为了防止矿工陷入死循环，比特币能支持的脚本语言是图灵不完备的，仅能够完成有限的操作。举一个简单的例子，如果之前交易中ScriptPubKey中设置的条件是 3 op_add 5 op_equal，那么新交易中的ScriptKey应该是什么呢？&emsp;&emsp;考虑到比特币使用的是基于栈的操作。op_add是一个操作指令，需要有两个操作数，所以scriptSig中一定需要一个数字作为操作数。而后面的指令也很简单，需要和5进行比较操作。所以ScriptSig中需要输入2。&emsp;&emsp;实际中常用的交易类型是P2PKH。使用P2PKH所需要的脚本是这样的。 &emsp;&emsp;除了P2PKH之外，还有其他形式的交易，如P2PK，multiSig、P2SH等。另外介绍了一个例子Time_Lock。&emsp;&emsp;在介绍完交易之后，我们讨论了区块的头部。在区块的头部有一个数据结构，Merkle root。在比特币网络中，Merkle树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹，且提供了一种校验区块是否存在某交易的高效途径。生成一棵完整的Merkle树需要递归地对哈希节点对进行哈希，并将新生成的哈希节点插入到Merkle树中，直到只剩一个哈希节点，该节点就是Merkle树的根。这里我们需要了解Merkle证明和Merkle路径是怎么回事。&emsp;&emsp;在之后我们介绍了SPV和Bloom过滤器。这里要理解Bloom过滤器的工作特点，为什么Bloom过滤器会造成false positive而不会造成false negative？&emsp;&emsp;接下来，结合310比特币挑战，我们重点讨论了比特币钱包，用户应该如何管理比特币。这里我们主要讨论了助记词。助记词是如何生成的呢？&emsp;&emsp;为了生成大量的密钥对，引入了HD钱包的概念。应该理解HD钱包是如何生成大量的密钥的。&emsp;&emsp;以上是比特币的内容。接下来，我们开始介绍以太坊。以太坊提供了远比比特币广的应用场景，主要是因为它大大提高了区块的生成速度，以及提供了图灵完备的脚本语言。为了支持这些特性，相比于比特币，它引入一些新的概念，如Gas。请问Gas的目的是什么？另外，为了支持基于账户的交易的支持，以太坊维护了状态树，因为状态树需要经常更新，所以以太坊使用了MPT。要求能够根据给出的键值对，画出相应的MPT。&emsp;&emsp;接下来重点考虑了区块链的安全问题。我们主要考虑以太坊上的智能合约的安全问题。在介绍智能合约的安全问题时，我们讨论了THE DAO 和 Fomo3d的攻击。要能够理解攻击产生的原因。针对燕姐所给的复习内容我所做的复习总结： 1. 电子货币历史： 主要介绍三种电子货币，分别是eCash、 HashCash和B-money。 盲签：简单地说，盲签是一种特殊类型的数字签名。一般数字签名中，签名者知道所签署的消息内容。而在盲签中，签名者是他人（接收者）发来的信息进行签名，接收者首先对原始信息进行盲化，然后发送给签名者；签名者对盲化后的信息进行签名；接收者可以对这个签名后的数据去盲化，最终得到签名者关于原始信息的正确签名。 2. 哈希： 概念：譬如学校里以学生名字为索引建了一张表，存储学生的信息。同时希望在查找的时候能够高效率地查找到学生。可以怎么实现呢？所以这个时候的一个做法就是，首先在存储时，对名字进行一次哈希，得到一个数字；然后将名字存在相应数字所对应的位置。在进行查找时，再对希望查找的名字进行一次哈希，得到位置。在算法上，哈希的平均复杂度是O(1)。 基本特征：collision冲突。因为理论上，哈希函数可以接收所有的字符串作为输入，从输出的话，一般会限定一个范围，所以，极有可能有两个或多个输入产生同一个输出，这个时候就称为产生了一个冲突。常见的哈希算法如取模运算。加密哈希是哈希函数的一种，它具有某些属性，使其适用于加密。通过加密哈希，它将任意大小的数据映射到固定大小的位串（散列），并被设计为单向函数，即一个不可逆的函数。从理想的加密散列函数输出重新创建输入数据的唯一方法是尝试对可能的输入进行暴力搜索，以查看它们是否产生匹配，或使用匹配哈希的彩虹表。输入数据通常称为消息（Message），输出（散列值或散列）通常称为消息摘要或简称为摘要（Digest）。 理想的加密哈希函数有五个主要属性：(1) 它是确定性的，因此相同的消息总是产生相同的散列（只要计算过程中没有引入随机数/调度，应该都满足）(2)可以快速计算任何给定消息的哈希值（SHA-256算法的主要操作时异或运算，位运算非常快。）(3)除了通过尝试所有可能的消息之外，从其散列值生成消息是不可行的（单向hiding就是知道哈希的结果不能倒推输入。简单来说，譬如 x mod 100这样的哈希函数，如果结果是1，那么x可能是1、101、201等无穷的数。从SHA族算法，从结果完全得不到输入的任何信息。）(4)对消息进行小的更改便能引起哈希值的巨大改变，以使新哈希值看起来与旧哈希值不相关（ 雪崩效应，以使新哈希值看起来与旧哈希值不相关）(5)找到具有相同散列值的两个不同消息是不可行的（即抗冲突）（当两个输入产生同一个输出，就发生了冲突。这里的抗冲突不是说肯定不会冲突，由鸽笼原理很容易看出，只要定义域大于值域，肯定会有冲突的。哈希函数的抗冲突指的是，虽然冲突就在那里，那就是找不到——或者说在可接受的时间内找不到） 三个特点：抗冲突、隐藏（hiding）以及puzzle friendliness，以及它们的应用 抗冲突：注意这里说的冲突是不可能找到，而不是说不存在。 应用：抗冲突的一个主要应用是信息摘要（message digest）。（MD5散列摘要）问题：当我们下载开源的软件使用时，怎么可以保证下载到的软件是官方的而不是经过第三方恶意修改过的呢？可以在第三方下载软件之后，使用同样的算法做一次散列，如果相同，可以放心使用。 Hiding：Hiding的意思是如果有哈希函数的输出y，那么不可能找到x，使得h(x)=y。即单向性。问题：掷骰子，输入值的空间太小，如果想要知道输入是什么，只需要遍历一遍，把所有可能的值计算一下，然后进行比对就行。如果想对head/tail的结果进行隐藏，有什么办法吗？答案就是通过对简单的”head”和”tail”后面跟上一个随机性较强的串r，这样就能实现hiding。譬如，后面跟上长度为256bit的串，这样因为r的随机性足够强，即使head和tail很简单，也有足够的隐藏性。hiding的应用：commitment（承诺）在密码学中，可以这样计算：com := commit(msg, nonce), nonce是一个随机的秘密的数字（譬如256位）；然后公开com；相当于把公布了一个密封的信封；大家都知道做出了承诺，但是具体值是什么还没有公开verify(com,msg,nonce)，如果要检验，则用户提供原始的msg和nonce，通过同样的方法计算，看com是否和commit计算出来的结果相同（考虑一下，为什么需要一个Nonce？增加破解难度，这样不易从com看出原来的msg）这里的commit就可以使用哈希函数来实现。commit就是哈希函数 puzzle friendliness：对于每一个可能的 n位输出 y ，如果 k 是随机性很强的值（譬如长度为256位的随机二进制串），那么找到一个合适的x使得 H(k||x)=y 是不可能显著地低于 2^n的时间复杂度。这个特点强调的是，如果给定特殊的哈希结果 y ，并且输入中有一部分随机性很强 k，那么找到输入的另一个部分 x 使得哈希的结果等于y，那么就只能依靠暴力搜索。应用： search puzzle ；区块链中的工作量证明。 哈希算法SHA-256在区块链中的应用哈希在区块链中的用处包括： 利用puzzle-friendliness的工作量证明，也即，要求生成一个新区块时，哈希值一定要是以一定数量的连续的0开始的； 对每个区块的内容进行哈希，后面的区块相当于一直在对前面的区块进行哈希，所以一般来说，如果一个区块之后如果跟上其他6个区块之后，一般认为该区块的内容已经被公认了，不可更改。 3. RSA算法： (1) 原根：DH算法为什么在DH算法中，要强调使用的是原根？而不是和p 互质的任意数字？因为根据素数的特性，不论是不是原根，下面的等式总是成立的。这里主要涉及的问题是，破解的难度。如果使用的 g 不是 p的原根，那么 g 的所有指数只能生成小于p 的整数的一个子集。那么对于攻击者而言，此时即使是暴力破解，需要计算的也只是小于 p 的整数的子集，而不是小于 p 的整数全部。（因为若不是原根的话，由它的指数生成的是小于p的子集，使破解难度降低） (2) 中间人攻击：Eve在Alice和Bob之间，拦截他们的通信，并且维持通信，就称为中间人攻击。为了防御中间人攻击，就需要一个能够验证通信双方身份的机制来防止这种攻击。数字签名实现 (3) RSA中公私密钥对生成的方法：p,q质数（后面重点讲） (4) RSA进行身份认证（RSA应用）：数字签名 ① 数字签名能保证：当数据从发送方传送到接收方时，数据不会被修改；数据由某一确定的发送方创建；发送方无法否认发送过数据这一事实。 ​ ② 数据签名并不是加密，你无法从一个签名重新构造出数据 ​ ③ 在比特币中，每一笔交易输入都会由创建交易的人签名。在被放入到一个块之前，必须要对每一笔交易进行验证。除了一些其他步骤，验证意味着：检查交易输入有权使用来自之前交易的输出；检查交易签名是正确的 (5) 在区块链中，公钥==身份 ​ 数字签名：两个特点：1. 签名不能伪造，也即只有自己能做出这个签名；2. 签名是针对一份文档的，也即，一个签名只能和一个文档相关联，不能拿到一个签名用于多个文档，类似于不能把一份文件上的签名撕下来贴到另一个文件上。 ​ 具体是怎么实现呢？ 首先生成一对公私钥 （pk, sk）。 pk 是公钥， sk是私钥。 签名sign。sig = sign(sk,message) ，使用私钥对一份消息message进行处理，譬如先对message进行哈希得到摘要，然后使用私钥对摘要进行加密。 验证verify。Verify(pk,message,sig) 。验证方法，获得输入message，签名的结果sig，以及公钥。譬如，可以使用公钥对签名结果进行解密，对message进行同样散列得到的摘要，比较解密的结果和摘要结果，如果两个相同，这验证通过，否则，验证失败。 &emsp;&emsp;也即，如果能够进行verify(pk,msg,sig)==true，那么，就可以认为pk确实说了msg。当然，为了以pk的身份说话，就必须有相应的私钥sk。 &emsp;&emsp;所以，可以认为pk 就是身份identity，在比特币区块链中，使用 pk 的哈希作为身份。在生成一对公私钥之后，拥有 sk 的人可以控制 pk。 4. 比特币中的共识机制PoW：(1) 共识机制本质上就是要保证所有节点认可的账本是唯一的。做到这一点，在中心化的系统中很容易，但是在分布式系统中，必须要考虑到参与节点的故障可能以及潜在的恶意攻击者的情况。PoW通过让参与节点进行算力的竞争，使得在大部分的节点是诚实节点的情况下，DoS攻击以及双重支付攻击不会成功。 (2) 简化的比特币的共识算法过程： ① 向所有的节点广播新的交易。 ② 每个节点将新交易打包进区块。 ③ 每一轮中一个随机的节点广播该区块。 ④ 如果区块中所有的交易都是有效的（比特币没有重花，签名正确等），则其他节点接受这个区块； ⑤ 节点表示接受该区块的方式是在之后新创建的区块中包括这个块的哈希。 (3) 针对这个算法讨论一下在货币网路中可能的攻击方法： ① 偷比特币：区块中Alice试图伪造一个交易“Bob发送10个比特币给Alice。”如果要让这个交易合法，那么Alice必须能够伪造Bob的签名，但是Alice如果没有Bob的私钥，那么Alice就不能伪造签名。 ② 拒绝服务（Dos攻击）：Alice区块忽视有关Bob交易，这个攻击的问题是，Alice并不能控制区块的产生。即使Alice在一个区块中忽略了Bob的交易，其他诚实的节点会在交易中包括Bob的交易。 ③ 双重支付：她先广播了一条交易“Alice付给Bob一些比特币”，Bob认为Alice已经支付了，所以将软件发送给了Alice，Alice后来又把刚才付给Bob的币付给自己。问题是，双重攻击能否成功，完全取决于区块链到底沿着那条链延续。诚实的节点会沿着最长的链创建自己的区块。所以答案就是，没有正确的答案。那么Bob如何应对这个问题呢？只要Bob等足够的时间，确定最终区块链中到底包含了哪一个块。而且，随着区块的增加（确认数的增加），交易变无效的可能性是指数级降低的。因此，可以等待6个区块，也即差不多1个小时的时间，基本上不会再翻盘了。 (4) 也正是因为工作量证明，保证了如果大部分的节点（以算力而不是个数）是诚实的，那么至少有50%的可能，下一个区块来自于诚实的节点。 (5) 51%攻击。 ① 不能偷比特币，要私钥签名 ② 攻击者能不能进行DoS攻击？如果攻击者特别不喜欢Bob，那么确实有可能Bob的交易不会出现在所有的区块中。但是，Bob的交易可以被广播到网络中，所以，即使Bob确实是拒绝服务了，但是至少对于诚实节点而言，能够发现攻击发生了。 ③ 双重支付，在51%的算力控制下，确实有可能，一旦人们发觉到比特币网络被人控制，那么人们会主动放弃比特币，那么比特币的价值会直接崩溃。而攻击者呢，考虑到控制51%算力的代价，出现这种情况就相当于所有的投资都会打水漂。 5. UTXO交易方式：&emsp;&emsp;将之前交易的输出作为新交易的输入。我们详细地察看了交易的具体内容，并介绍了输出位置上的ScriptPubKey以及输入部分的ScriptSig。先前交易的输出需要设置相应的条件，之后的交易必须要满足这个条件才能使用这笔输出中包含的钱。所以如果矿工在接收到交易时，将新交易中的ScriptSig和先前交易中的ScriptPubKey结合起来，能顺利运行结束返回True，那么这个交易便是合法的，可以被打包进区块。如果之前交易中ScriptPubKey中设置的条件是 3 op_add 5 op_equal，那么新交易中的ScriptKey应该是什么呢？ 2 6. P2SH给步骤用钱怎么弄2 of 3：(1) 问题：譬如Alice向Bob购买一件物品，但是Bob的物品不是自己独有的，他需要和其他人一起分享Alice付的币，就例如上面介绍的MULTICHECK，需要3个人中的两人同意才能使用币。把这个任务交给Alice是不合理的，因为Alice只关心自己付了钱能够拿到物品，并不关心Bob拿到钱之后怎么分。这个时候Bob可以创建一个Script，然后Alice可以将币发送到这个Script地址。 (2) 怎样实现呢？P2SH的脚本是一个2-of-3的多签名。 ① 首先Bob需要创建2-of-3 multisig P2SH地址。生成的P2SH地址提供给Alice。同时生成了Redeem Script（组成为：&lt; OP_2 &gt; &lt; A pubkey &gt; &lt; B pubkey &gt; &lt; C pubkey &gt; &lt; OP_3 &gt; &lt; OP_CHECKMULTISIG&gt; ），也即Bob在将Alice支付的钱赎出的时候提供的签名脚本。使用这个redeemScript， ② 又经过两个步骤生成了P2SH地址: 对redeemScript进行两次哈希； Base58check使用前缀0x05对redeemscriptHash进行编码； ③ 使用P2SH地址生成交易：为了形成交易，Alice需要以下的信息：来自标准P2PKH的输出,该 P2PKH的交易id(txid），相对应的私钥，需要发送的币的个数，以及目标P2SH地址（也就是上面刚生成的地址)。 7. 怎样验证交易一定存在证明过程(1) 由于哈希的单向性，可以得出结论，如果两棵Merkle树的merkle root相同，那么这两棵树的结构和每个节点也必然是相同的。另外，只要存储的叶子节点数据有任何的变动，就会逐级向上传递到相应的父节点，最终使得Merkle树的根节点哈希值发生变化。 典型merkle树如下： (2) 譬如用户Bob收到用户Alice发来的一笔支付交易，这时Bob必须要验证这笔交易（1）确实存在，并且（2）不是双重支付。对于SPV用户而言，需要从可信节点获得区块链的完整的头部信息，以及和他想验证的交易的Merkle分支。这样，虽然用户不能自己验证交易，但如果能够从区块链的某处找到符合的交易，就可以知道这笔交易已被网络确认，也可以确认该笔交易得到网络多少笔确认。譬如，SPV节点要验证第300,000号区块中的某个交易，它需要获得300,000区块中交易的Merkle分支（Merkle路径）进行验证，并且等到序号从300,001到300,006的六个区块堆叠在该交易所在的区块上。如果网络中的其他节点都接受了第300,000区块，并通过足够的工作在该块之上又生成了六个区块，就可以证明该交易不是双重支付 (3) 使用Merkle分支进行验证是Merkle树的Tamper proof性质， 使用Merkle树之后，可以很容易验证区块中的交易有没有被篡改。譬如在下图中的例子，如果一个交易 TH 被篡改成了T？ ，那么交易的哈希值会不同，沿着从底层到根节点的路径向上，会导致最终树的merkle root不同，也即保存在区块链头的值不同。相反，如果从叶子节点到Merkle根的路径上，所有的哈希值都验证正确，那么可以证明这个交易确实存在于这个区块中。 (4) 如上图，如果需要证明某个区块上是否存在一笔交易Tx3，那么全节点返回的Merkle路径是Hash2和Hash01。只需要这两个值就可以进行验证过程如下： ① Step1：计算交易Tx3的哈希值，得到Hash3 ② Step2：通过Hash2和Hash3的哈希值，得到父节点的哈希值Hash23 ③ Step3：同上，通过计算Hash23和Hash01哈希值，得到根节点的哈希值。 Step4：将上一步得到的根哈希值对比区块头中MerkleTree的根哈希值，如果相同，则证明该区块中存在交易Tx3，否则说明不存在。 8. Bloom过滤器&emsp;&emsp;这里要理解Bloom过滤器的工作特点，为什么Bloom过滤器会造成false positive而不会造成false negative？（m个哈希函数，n位二进制数组） 这里使用十六位数组（N=16）和三个哈希函数（M=3）来演示Bloom过滤器的应用原理。 &emsp;&emsp;Bloom过滤器数组里的每一个数的初始值为零。关键词被加到Bloom过滤器中之前，会依次通过每一个哈希函数运算一次。该输入经第一个哈希函数运算后得到了一个在1和N之间的数，它在该数组（编号依次为1至N）中所对应的位被置为1，从而把哈希函数的输出记录下来。接着再进行下一个哈希函数的运算，把另外一位置为1；以此类推。当全部M个哈希函数都运算过之后，一共有M个位的值从0变成了1，这个关键词也被“记录”在了Bloom过滤器里。 向上图中的简易Bloom过滤器添加关键词“A”: 会造成False positive是因为这些字节1也有可能是其他关键词运算的重叠结果。简单来说，Bloom过滤器正匹配代表着“可能是”。 一定不会造成false negative，如果我们代入关键词计算后的结果某位为0，说明该关键词并没有被记录在过滤器里。负匹配的结果不是可能，而是一定。也就是说，负匹配代表着“一定不是”。 9. 助记词(1) 第二种类型是确定性钱包（deterministic wallet），其中所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子（seed）。该类型钱包中所有密钥都相互关联，如果有原始种子，则可以再次生成全部密钥。确定性钱包中使用了许多不同的密钥推导方法。最常用的推导方法是使用树状结构，称为分级确定性钱包或HD钱包。确定性钱包由种子衍生创造。为了便于使用，种子被编码为英文单词，也称为助记词。 (2) HD钱包有两个主要的优势。第一，树状结构可以被用来表达额外的组织含义。比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门、子公司、具体功能以及会计类别。第二，用户可以建立一个公钥的序列而不需要访问相对应的私钥 (3) 助记词生成过程：助记词是由钱包使用BIP-39中定义的标准化过程自动生成的。 钱包从熵源开始，增加校验和，然后将熵映射到单词列表： 1) 创建一个128到256位的随机序列（熵）。 2) 提出SHA256哈希前几位（熵长/ 32），就可以创造一个随机序列的校验和。 3) 将校验和添加到随机序列的末尾。 4) 将序列划分为包含11位的不同部分。 5) 将每个包含11位部分的值与一个已经预先定义（2^11）2048个单词的字典做对应。 6) 生成的有顺序的单词组就是助记码。 7) PBKDF2密钥延伸函数的第一个参数是从步骤6生成的助记符。 8) PBKDF2密钥延伸函数的第二个参数是盐。 由字符串常数“助记词”与可选的用户提供的密码字符串连接组成。 9) PBKDF2使用HMAC-SHA512算法，使用2048次哈希来延伸助记符和盐参数，产生一个512位的值作为其最终输出。 这个512位的值就是种子。（将6步生成的助记词与盐一起构成新的字符串，然后用HMAC-sha512 进行2048次哈希产生一个512为种子） 10. 从root seed生成公私钥对的过程就是对root seed进行一次HMAC-SHA512的加密哈希，在生成512的结果之后，将512位结果划分为两个256部分，分别是Master private key（主私钥）和Master Chain Code（主链码）。然后从私钥生成到公钥。 123child_private_key == (parent_private_key + lefthand_hash_output) % Gchild_public_key == point( (parent_private_key + lefthand_hash_output) % G )child_public_key == point(child_private_key) == parent_public_key + point(lefthand_hash_output) 上面的三个等式，第一个是子私钥的生成；第二个是从子私钥生成子公钥；第三个是从父公钥直接生成子公钥。【注1：因为子公钥和父公钥之间的关系依赖于 point(lefthand_hash_output)， 而point(lefthand_hash_output)的值依赖于链码、父公钥和索引，缺少的值仅仅是链码】【注2：因为父公钥已知，链码在同一对父公私钥的情况下的是固定的，如果链码泄露的情况下，还是可以推导出兄弟姐妹公钥；】【注3：因此，扩展公钥，不同于公钥，公钥是理所当然应该公开的；而扩展公钥因为是公钥和链码的连接，为了保护链码，应该保护扩展公钥】因为创建子密钥需要父密钥和链码，所以讲密钥和链码一起称为扩展密钥。扩展私钥和相对应的扩展公钥具有相同的链码。如果攻击者获得了父链码和父公钥，那么就可以获得所有的子链码。有了子链码，如果又获得了底层的某一个私钥（孙子密钥），那么可以根据这个链码生成所有的扩展私钥。更惨的是，攻击者可能通过子密钥逆推回祖先私钥。也即，如果攻击者获得了一个扩展公钥，以及任何它的子孙私钥，那么就能够这个公钥对应的私钥，以及所有的后代密钥。 因此，扩展公钥的链码部分需要好好保存。也因此提出了强化子密钥的概念。 11. gas 有什么用&emsp;&emsp;合约可以利用的每个命令都会有一个相应的费用值，费用使用gas作为单位计数，也即用户付给矿工的佣金。这样如果恶意用户在交易中包括了死循环，那么不论付出多少gas，最终都会消耗完。另外，也正是因为这样的代价问题，虽然以太坊的脚本语言是图灵完备的，也即当前的所有代码都可以在以太坊区块链上运行，但是作为开发者，需要认真考虑代码的效率。两个同样功能的合同，效率高的那个才能生存下来。 12. Hex编码到HP编码 [ 1, 2, 3, 4, 5, …] //扩 展结点，路径长度为奇数，添加01（bit），也即1(nibble)‘11 23 45’ [ 0, 1, 2, 3, 4, 5, …] //扩展结点，路径长度为偶数，添加00，也即0，然后补一个0‘00 01 23 45’ [ 0, f, 1, c, b, 8, 10] //叶子节点，长度为偶数（最后一个10也即16，补充位，需要移除），添加10，也即0，然后补一个0‘20 0f 1c b8’ [ f, 1, c, b, 8, 10] //叶子节点，长度为奇数，添加11，也即3‘3f 1c b8’ 13. 画出MPT树 &lt; 64 6f &gt; : ‘verb’&lt; 64 6f 67 &gt; : ‘puppy’&lt; 64 6f 67 65 &gt; : ‘coin’&lt; 68 6f 72 73 65 &gt; : ‘stallion’ 14 The DAO攻击The DAO攻击：不让别人打包交易，给多gas，优先多的打包，其它的交易延迟 （1） 提供了三种方法实现send功能： .transfer() 当发送失败时会 throw; 回滚状态 只会传递 2300 Gas 供调用，防止重入（reentrancy） .send() 当发送失败时会返回 false 布尔值 只会传递 2300 Gas 供调用，防止重入（reentrancy） .gas().call.value()() 当发送失败时会返回 false 布尔值 传递所有可用 Gas 进行调用（可通过 gas(gas_value) 进行限制），不能有效防止重入（reentrancy） （2）分析以下代码漏洞和防御 1234567891011121314151617181920212223EtherStore.sol：contract EtherStore &#123; uint256 public withdrawalLimit = 1 ether; mapping(address =&gt; uint256) public lastWithdrawTime; mapping(address =&gt; uint256) public balances; function depositFunds() public payable &#123; balances[msg.sender] += msg.value; &#125; function withdrawFunds (uint256 _weiToWithdraw) public &#123; require(balances[msg.sender] &gt;= _weiToWithdraw); // limit the withdrawal require(_weiToWithdraw &lt;= withdrawalLimit); // limit the time allowed to withdraw require(now &gt;= lastWithdrawTime[msg.sender] + 1 weeks); require(msg.sender.call.value(_weiToWithdraw)()); balances[msg.sender] -= _weiToWithdraw; lastWithdrawTime[msg.sender] = now; &#125; &#125; 以上代码就是被攻击代码。它的功能是充当公共账户，类似于银行，接收用户存款（depositFund），提供用户取现功能（withdrawFunds）。 depositFund中，简单增加用户账户的余额，在用户取现的时候，首先做检查，确保用户账户的余额超出所要提取的金额，然后检查取现金额的最大值；接下来再对取现的时间进行限制，确保一周支取一次。然后将钱转给调用者账户，随后修改调用者msg.send的余额，并更新最新的取现时间。 这段合约的漏洞就在于：require(msg.sender.call.value(_weiToWithdraw)()); 当被攻击代码执行到这一句的时候，它会调用msg.send代码中的fallback函数。因为withdraw函数中使用了call.value()，所以会调用攻击者合约中的匿名函数，而在攻击者的匿名函数中，又再次调用withdrawFunds函数，这样，只要攻击者的gas足够多，它会一直将公共账户也即Bank里的钱全部移走。 效果如下： balance 下溢 Reentrance 账户余额 0 ether Attack 账户余额 1 ether (3) 防御： 在将 Ether 发送给外部合约时使用内置的 transfer() 函数 。transfer转账功能只发送 2300 gas 不足以使目的地址/合约调用另一份合约（即重入发送合约）。 确保所有改变状态变量的逻辑发生在 Ether 被发送出合约（或任何外部调用）之前。在这个 EtherStore 例子中，EtherStore.sol 中对账户余额和账户时间的修改应该在发送以太币之前。将任何对未知地址执行外部调用的代码，放置在本地化函数或代码执行中作为最后一个操作，是一种很好的做法。这被称为 检查效果交互（checks-effects-interactions） 模式。 引入互斥锁。也就是说，要添加一个在代码执行过程中锁定合约的状态变量，阻止重入调用；这样在本次发送–修改余额这一整套操作完成之前，不能再次执行发送操作。 15. RSA中公私密钥对生成的方法已知：两质数 $ p = 61, q = 53 $ 和$ e = 17 $，求 $ d $（用Euclid扩展算法求模逆）$ N = p * q = 3233 $ $ (p-1)(q-1)= 60 * 52 = 3120 $ 利用3120 和 17 来分解： $ 3120 = 17 * 183 + 9 $ $ 17 = 9 * 1 + 8 $ $ 9 = 8 * 1 + 1 $ 将余数放在左边: $ 9 = 3120 - 17 * 183 (1) $ $ 8 = 17 - 9 * 1 (2) $ $ 1 = 9 - 8 *1 (3) $ 将（3）中8用（2）替换，（2）中9用（1）替换 $ 1 = 9 - 1 * (17 - 9 * 1) = 2 * 9 - 17 = 2 * (3120 - 17 * 183) - 17 $ $ = 2 * 3120 - (2 * 183 + 1 ) * 17 $ 由此可得 $ - ( 2 * 183 + 1) = -367 $为d, 再转化为正数为 $ 3120 - 367 = 2753 $ 故$ d = 2753 $]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[占坑]]></title>
    <url>%2F2018%2F11%2F17%2F%E5%8D%A0%E5%9D%91%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;此post的目的是防止您点击阅读时出现404。顺带预告下第一次要讲的书是《三体》。]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>三体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blockchain2]]></title>
    <url>%2F2018%2F11%2F17%2FBlockchain2%2F</url>
    <content type="text"><![CDATA[哈希函数–密码学中“瑞士军刀” 区块链二：哈希 1. 哈希函数概念来自维基百科的解释： A hash function is any function that can be used to map data of arbitrary size to data of a fixed size. The values returned by a hash function are called hash values, hash codes, digests, or simply hashes. &emsp;&emsp;通过一个问题来理解一下，譬如学校里以学生名字为索引建了一张表，存储学生的信息。同时希望在查找的时候能够高效率地查找到学生。可以怎么实现呢？&emsp;&emsp;这个时候的一个做法就是，首先在存储时，对名字进行一次哈希，得到一个数字；然后将名字存在相应数字所对应的位置。在进行查找时，再对希望查找的名字进行一次哈希，得到位置。在算法上，哈希的平均复杂度是O(1)。 2. 哈希函数的基本特征&emsp;&emsp;这里重点讨论的是加密哈希（cryptographic hash）。加密哈希是哈希函数的一种，它具有某些属性，使其适用于加密。通过加密哈希，它将任意大小的数据映射到固定大小的位串（散列），并被设计为单向函数，即一个不可逆的函数。从理想的加密散列函数输出重新创建输入数据的唯一方法是尝试对可能的输入进行暴力搜索，以查看它们是否产生匹配，或使用匹配哈希的彩虹表。布鲁斯施奈尔称单向散列函数是“现代密码学的主力”。输入数据通常称为消息（Message），输出（散列值或散列）通常称为消息摘要或简称为摘要（Digest）。 理想的加密哈希函数有五个主要属性： 它是确定性的，因此相同的消息总是产生相同的散列（只要计算过程中没有引入随机数/调度，应该都满足） 可以快速计算任何给定消息的哈希值（SHA-256算法的主要操作时异或运算，位运算非常快。） 除了通过尝试所有可能的消息之外，从其散列值生成消息是不可行的（单向hiding就是知道哈希的结果不能倒推输入。简单来说，譬如 x mod 100这样的哈希函数，如果结果是1，那么x可能是1、101、201等无穷的数。从SHA族算法，从结果完全得不到输入的任何信息。） 对消息进行小的更改便能引起哈希值的巨大改变，以使新哈希值看起来与旧哈希值不相关（ 雪崩效应，以使新哈希值看起来与旧哈希值不相关） 找到具有相同散列值的两个不同消息是不可行的（即抗冲突）（当两个输入产生同一个输出，就发生了冲突。这里的抗冲突不是说肯定不会冲突，由鸽笼原理很容易看出，只要定义域大于值域，肯定会有冲突的。哈希函数的抗冲突指的是，虽然冲突就在那里，那就是找不到——或者说在可接受的时间内找不到） 三个特点：抗冲突、隐藏（hiding）以及puzzle friendliness，以及它们的应用。 抗冲突：注意这里说的冲突是不可能找到，而不是说不存在。 应用：抗冲突的一个主要应用是信息摘要（message digest）。（MD5散列摘要）问题：当我们下载开源的软件使用时，怎么可以保证下载到的软件是官方的而不是经过第三方恶意修改过的呢？可以在第三方下载软件之后，使用同样的算法做一次散列，如果相同，可以放心使用。 Hiding：Hiding的意思是如果有哈希函数的输出y，那么不可能找到x，使得h(x)=y。即单向性。问题：掷骰子，输入值的空间太小，如果想要知道输入是什么，只需要遍历一遍，把所有可能的值计算一下，然后进行比对就行。如果想对head/tail的结果进行隐藏，有什么办法吗？答案就是通过对简单的”head”和”tail”后面跟上一个随机性较强的串r，这样就能实现hiding。譬如，后面跟上长度为256bit的串，这样因为r的随机性足够强，即使head和tail很简单，也有足够的隐藏性。hiding的应用：commitment（承诺）在密码学中，可以这样计算：com := commit(msg, nonce), nonce是一个随机的秘密的数字（譬如256位）；然后公开com；相当于把公布了一个密封的信封；大家都知道做出了承诺，但是具体值是什么还没有公开verify(com,msg,nonce)，如果要检验，则用户提供原始的msg和nonce，通过同样的方法计算，看com是否和commit计算出来的结果相同（考虑一下，为什么需要一个Nonce？增加破解难度，这样不易从com看出原来的msg）这里的commit就可以使用哈希函数来实现。commit就是哈希函数 puzzle friendliness：对于每一个可能的 n位输出 y ，如果 k 是随机性很强的值（譬如长度为256位的随机二进制串），那么找到一个合适的x使得 H(k||x)=y 是不可能显著地低于 2^n的时间复杂度。这个特点强调的是，如果给定特殊的哈希结果 y ，并且输入中有一部分随机性很强 k，那么找到输入的另一个部分 x 使得哈希的结果等于y，那么就只能依靠暴力搜索。应用： search puzzle ；区块链中的工作量证明。 3. 哈希算法SHA-256&emsp;&emsp;SHA-256是SHA-2中的一个算法。SHA-2，也即第二代安全散列算法（Secure Hash Algorithm 2），由美国国家安全局2001年公布的标准哈希算法，是SHA-1的后继。SHA-2下包括六个不同的算法标准：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。这些不同的算法使用不同生成摘要的长度 、循环运行的次数，但算法的基本结构是一致的。现在已知SHA-2容易受到长度扩展攻击，所以推荐使用SHA-3来取代它。对于任意长度的消息，SHA256都产生256bit长的哈希值，也即32字节，或者64位的16进制数，或者8个8位的16机制数 。为什么要强调这个呢？&emsp;&emsp;简单说一下SHA-256的计算过程。 这里A～H共有8个，初始值分别是12345678h0 := 0x6a09e667h1 := 0xbb67ae85h2 := 0x3c6ef372h3 := 0xa54ff53ah4 := 0x510e527fh5 := 0x9b05688ch6 := 0x1f83d9abh7 := 0x5be0cd19 &emsp;&emsp;看一下，分别是8个16进制数，所以总共有256位，这个就叫做初始向量（IV）。这8个数是前8个素数取平方根，前32位小数。最终生成的哈希值也是这么长，所以，每一轮的计算就是如上图所示，更新这8个值。那怎么更新呢？ &emsp;&emsp;每一轮计算64次。在上图中可以看到，除了A～H外，有两个输入，分别是 w_{t} 和 k_{t} 。也即每一轮中有64个 w ，以及64个 k 。每个 w 长度为32bit，也即4个字据诶。64个 w 来自于哈希函数的输入，也即，对于输入，不论长短，长的就分成每512bit一个块（64个字节），短的补足512bit。这64个字节构成了前16个 w ，后面的48个 w 通过前面的16个生成。1234for i from 16 to 63 s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3) s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor (w[i-2] rightshift 10) w[i] := w[i-16] + s0 + w[i-7] + s1 64个 k 是64个常量1234k[0..63] :=0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2 这64个常量来自于自然数中前64个质数{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97…}，取立方根，前32bit而来。然后每一次的计算，12345678h := gg := ff := ee := d + temp1d := cc := bb := aa := temp1 + temp2 temp1和temp2就是经过异或、右移、循环右移等操作生成的。 &emsp;&emsp;关于短的输入如何补足也有一些细节，在输入末尾进行填充，使输入长度在对512取模以后的余数是448。填充的具体过程：先补第一个比特为1，然后都补0，直到长度满足对512取模后余数是448。需要注意的是，信息必须进行填充，也就是说，即使长度已经满足对512取模后余数是448，补位也必须要进行，这时要填充512个比特。因此，填充是至少补一位，最多补512位。为什么余数是448呢?因为，还有需要有64位的数据表示原始输入的长度，加上这64bit的长度信息448+64=512，刚好512位。 在区块链中的应用 哈希在区块链中的用处包括： &emsp;&emsp;利用puzzle-friendliness的工作量证明，也即，要求生成一个新区块时，哈希值一定要是以一定数量的连续的0开始的；&emsp;&emsp;对每个区块的内容进行哈希，后面的区块相当于一直在对前面的区块进行哈希，所以一般来说，如果一个区块之后如果跟上其他6个区块之后，一般认为该区块的内容已经被公认了，不可更改。 本文来自燕姐的授课内容，详情见她的知乎]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[立flag]]></title>
    <url>%2F2018%2F11%2F17%2F%E7%AB%8Bflag%2F</url>
    <content type="text"><![CDATA[立一个大大的Flag: 每两到三天至少发一篇post 所包含内容： 技术类 算法 区块链 python编程 AI 等等 生活类 见闻和感想 生活记录 阅读 其他 转载我感觉比较好的文章]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>flag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blockchain1]]></title>
    <url>%2F2018%2F11%2F16%2FBlockchain1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;区块链这个词现在实在太火了。有人认为它是一项颠覆性的革命性的技术，还有很多人认为它不过是一个庞氏骗局，那我们到底应该怎么样看待区块链和数字货币呢？ 区块链一：区块链、比特币历史 1. 区块链主要事件： 1976年 Bailey W.Diffe、Martin E.Hellman发表《密码学的新方向》 1977年 RSA算法诞生 1980年 Merkle-Tree 被提出 1982年 提出拜占庭将军问题；同年，David Chaum提出密码学网路支付系统ECash 1985年 提出椭圆曲线密码学 1990年 提出Paxos 1991年 使用时间戳确保数位文件安全 1992年 提出椭圆曲线数位签章演算法 1997年 Adam Back发明Hashcash技术 1998年 Wei Dai发表匿名的分散式电子现金系统B-money 1999年-2001年 Napster、EDonkey和BitTorrent先后出现，奠定P2P基础 2001年 NSA发布SHA-2系列算法也是比特币采用的哈希算法 2005年 可重复使用的工作量证明机制（RPOW）出现 2008年 Blockchain 1.0：加密货币发布，11月中本聪发布著名论文《比特币：一种点对点的电子现金系统》 2009年 1月创世区块诞生，潘多拉魔盒打开 2010年 比特币挖矿开端 2011年 第一个版本：0.3.21发布 2014年2月 俄罗斯小伙子V神(Vitalik Buterin)创立以太坊(Ethereum)，当年20岁，绝对的天才 2014年4月 Gavin Wood发布以太坊黄皮书 2015年7月 以太坊发布第一个正式版本Frontier 2016年 The DAO被攻击事件 2017年 Metropols发布，POW最后一个阶段 图片来自众安保险 2.比特币&emsp;&emsp;Dai Wei评价说：“要想开发出比特币，必须得： 对货币有非常深入的思考； 要了解密码学； 认为比特币这样的系统从理论上是可行的； 要有足够的动力去将这个理念开发成实际产品； 编程能力出色，能保证产品安全； 有足够的社交技巧，才能围绕这个产品建立一个成功的社区。 密码学圈子能符合前三个条件的人就已是凤毛麟角。”&emsp;&emsp;中本聪（匿名性做的最好的密码朋克的成员）提出的“该网络通过随机散列（hashing）对全部交易加上时间戳（timestamps），将它们合并入一个不断延伸的基于随机散列的工作量证明（proof-of-work）的链条作为交易记录，除非重新完成全部的工作量证明，形成的交易记录将不可更改。最长的链条不仅将作为被观察到的事件序列（sequence）的证明，而且被看做是来自CPU计算能力最大的池（pool）。只要大多数的CPU计算能力都没有打算合作起来对全网进行攻击，那么诚实的节点将会生成最长的、超过攻击者的链条”。比特币中的交易和B-money中的相似，包含了转账双方的公钥，并且使用Payer的私钥加密；&emsp;&emsp;比特币引入了PoW，工作量证明，来解决分布式系统中的一致性问题，也即，PoW对应着的是算力，相当于是一个CPU一票。想要在投票中作弊，就必须控制占多数的算力。网络运行步骤：1) 新的交易向全网进行广播；2) 每一个节点都将收到的交易信息纳入一个区块中；3) 每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明；4) 当一个节点找到了一个工作量证明，它就向全网进行广播；5) 当且仅当包含在该区块中的所有交易都是有效的且之前未存在过的，其他节点才认同该区块的有效性；6) 其他节点表示他们接受该区块，而表示接受的方法，则是在跟随该区块的末尾，制造新的区块以延长该链条，而将被接受区块的随机散列值视为先于新区快的随机散列值。 &emsp;&emsp;对于类似于B-money中的双重支付问题，如果Alice试图用同一笔钱来支付两个交易，那么两个交易不可能都存在于区块链上，因为每一个交易都会被检查；即使Alice强制性地将两个交易都打包进一个区块，其他用户也不会接受包括了不正确交易的区块。如果有两个矿工分别将两笔交易打包进了自己的区块，并且都成功地完成了工作量证明，那么哪一个交易会真正地成为被大家公认的交易就要看运气了。&emsp;&emsp;如果Bob不相信Alice，那么他可以等待Alice的支付消息被成功地打包进了区块，而且在其后又链接更多区块之后，才完成与Alice的交易。譬如Alice向Bob买一本书，按照10分钟生成一个区块的速度，Bob可以等一个小时，也即Alice的支付消息之后有了另外5个区块之后，才将书交给Alice。比特币网络中 还有其他的一些技术细节，譬如Merkle树等，之后再讨论。&emsp;&emsp;关于比特币的传说还有很多，譬如来自《纽约客》的报道：“When I first looked at the code, I was sure I was going to be able to break it,” Kaminsky said, noting that the programming style was dense and inscrutable. “The way the whole thing was formatted was insane. Only the most paranoid, painstaking coder in the world could avoid making mistakes.”Kaminsky lives in Seattle, but, while visiting family in San Francisco in July, he retreated to the basement of his mother’s house to work on his bitcoin attacks. In a windowless room jammed with computers, Kaminsky paced around talking to himself, trying to build a mental picture of the bitcoin network. He quickly identified nine ways to compromise the system and scoured Nakamoto’s code for an insertion point for his first attack. But when he found the right spot, there was a message waiting for him. “Attack Removed,” it said. The same thing happened over and over, infuriating Kaminsky. “I came up with beautiful bugs,” he said. “But every time I went after the code there was a line that addressed the problem.”He was like a burglar who was certain that he could break into a bank by digging a tunnel, drilling through a wall, or climbing down a vent, and on each attempt he discovered a freshly poured cement barrier with a sign telling him to go home. “I’ve never seen anything like it,” Kaminsky said, still in awe.Kaminsky ticked off the skills Nakamoto would need to pull it off. “He’s a world-class programmer, with a deep understanding of the C++ programming language,” he said. “He understands economics, cryptography, and peer-to-peer networking.”“Either there’s a team of people who worked on this,” Kaminsky said, “or this guy is a genius.” 本部分来自燕姐的授课内容，详情见她的知乎 3. 以太坊黄皮书 参考文献： https://en.wikipedia.org/wiki/Blockchain https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system https://zhuanlan.zhihu.com/p/44449024 https://en.wikipedia.org/wiki/Vitalik_Buterin]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise6]]></title>
    <url>%2F2018%2F11%2F02%2FExercise6%2F</url>
    <content type="text"><![CDATA[Case Study: Dice Poker1. Program Specification&ensp;&ensp;Our goal is to write a game program that allows a user to play video poker using dice. The program will display a hand consisting of five dice. The basic set of rules is as follows: The player starts with $100. Each round costs $10 to play. This amount is subtracted from the player’s money at the start of the round. The player initially rolls a completely random hand (i.e., all five dice are rolled). The player gets two chances to enhance the hand by rerolling some or all of the dice. At the end of the hand, the player’s money is updated according to the following payout schedule: hand pay Two Pairs $5 Three of a Kind $8 Full House (A Pair and a Three of a Kind) $12 Four of a Kind $15 Straight (1-5 or 2-6) $20 Five of a Kind $30 &ensp;&ensp;Ultimately, we want this program to present a nice graphical interface. Our interaction will be through mouse clicks. The interface should have the following characteristics: The current score (amount of money) is constantly displayed. The program automatically terminates if the player goes broke. The player may choose to quit at appropriate points during play. The interface will present visual cues to indicate what is going on at any given moment and what the valid user responses are. The interface looks like: 2. Identifying Candidate ObjectsCandidate Objects including: the Dice class constuctor rollAll roll values score A PokerApp object run playRound doRolls A PokerInterface object setMoney setDice wantToPlay showResult chooseDice 3.Implementing the Model3.1 Implementing Dice&ensp;&ensp;The Dice class implements a collection of dice, which are just changing numbers. The obvious representation is to use a list of five ints. 12345678910111213141516171819202122232425262728293031323334353637383940from random import *class Dice: def __init__(self): self.dice = [0]*5 self.rollAll() def roll(self, which): for pos in which: self.dice[pos] = randrange(1, 7) def rollAll(self): self.roll(range(5)) def values(self): return self.dice[:] def score(self): # Create the counts list # Counts[i] will be the number of times that the value i occurs in dice. # if the dice are: [3,2,5,2,3] then the counts list would be [0,0,2,2,0,1,0] counts = [0]*7 for value in self.dice: counts[value] = counts[value] + 1 # score the hand if 5 in counts: return &quot;Five of a Kind&quot; , 30 elif 4 in counts: return &quot;Four of a Kind&quot; , 15 elif (3 in counts) and (2 in counts) : return &quot;Full House&quot;, 12 elif 3 in counts: return &quot;Three of a Kind&quot;, 8 elif not (2 in counts) and (counts[1] == 0 or counts[6] == 0): return &quot;Straight&quot;, 20 elif counts.count(2) == 2: return &quot;Two Pairs&quot;, 5 else: return &quot;Garb age&quot;, 0 &ensp;&ensp;At this point, we could try out the Dice class to make sure that it is working correctly. Here is a short interaction showing some of what the class can do: 1234from dice import Diced = Dice()print(d.values())print(d.score()) 3.2 Implementing PokerApp&ensp;&ensp;Now we are ready to turn our attention to the task of actually implementing the poker game. We can use top-down design to flesh out the details and also suggest what methods will have to be implemented in the Poker Interface class. 1234567891011121314151617181920212223242526272829303132from dice import Diceclass PokerApp: def __init__(self, interface): self.dice = Dice() self.money = 100 self.interface = interface def run(self): while self.money &gt;= 10 and self.interface.wantToPlay(): self.playRound() self.interface.close() def playRound(self): self.money = self.money - 10 self.interface.setMoney(self.money) self.doRolls() result, score = self.dice.score() self. interface. showResult (result, score) self.money = self.money + score self.interface.setMoney(self.money) def doRolls(self): self.dice.rollAll() roll = 1 self.interface.setDice(self.dice.values()) toRoll = self.interface.chooseDice() while roll &lt; 3 and toRoll != []: self.dice.roll(toRoll) roll = roll + 1 self.interface.setDice(self.dice.values()) if roll &lt; 3: toRoll = self.interface.chooseDice() 3.3 A Text-Based Ul&ensp;&ensp;In designing PokerApp, we have also developed a specification for a generic Pokerinterface class. Our interface must support the methods for displaying information: setMoney, setDice, and showResul t. It must also have methods that allow for input from the user: wantToPlay and chooseDice. These methods can be implemented in many different ways, producing programs that look quite different even though the underlying model, PokerApp, remains the same. 12345678910111213141516171819202122class TextInterface: def __init__(self): print(&quot;Welcome to video poker.&quot;) def setMoney(self, amt): print(&quot;You currently have $&#123;0&#125;.&quot;.format(amt)) def setDice(self, values): print(&quot;Dice:&quot;, values) def wantToPlay(self): ans = input(&quot;Do you wish to try your luck? &quot;) return ans[0] in &quot;yY&quot; def close(self): print(&quot;\nThanks for playing!&quot;) def showResult(self, msg, score): print(&quot;&#123;0&#125;. You win $&#123;1&#125;.&quot;.format(msg, score)) def chooseDice(self): return eval(input(&quot;Enter list of which to change ([] to stop) &quot;)) &ensp;&ensp;Using this interface, we can test out our PokerApp program to see whether we have implemented a correct model. Here is a complete program making use of the modules that we have developed: 123456from pokerapp import PokerAppfrom textpoker import TextInterfaceinter = TextInterface()app = PokerApp(inter)app.run() &ensp;&ensp;Basically, all this program does is create a text -based interface and then build a PokerApp using this interface and start it running. Instead of creating a separate module for this, we could also just add the necessary launching code at the end of our textpoker module. When running this program, we get a rough but usable interaction: 1234567891011121314151617181920212223242526272829Welcome to video poker.Do you wish to try your luck? yYou currently have $90 .Dice: [6 , 4, 4, 2, 4]Enter list of which to change ([] to stop) [0 ,4]Dice: [1, 4, 4, 2, 2]Enter list of which to change ([] to stop) [0]Dice: [2 , 4, 4, 2, 2]Full House. You win $12.You currently have $102 .Do you wish to try your luck? yYou currently have $92 .Dice: [5 , 6, 4, 4, 5]Enter list of which to change ( [] to stop) [1]Dice: [5&apos; 5&apos; 4&apos; 4&apos; 5]Enter list of which to change ( [] to stop) []Full House. You win $12.You currently have $104 .Do you wish to try your luck? yYou currently have $94 .Dice: [3&apos; 2, 1, 1, 1]Enter list of which to change ( [] to stop) [0&apos; 1]Dice: [5&apos; 6&apos; 1, 1, 1]Enter list of which to change ( [] to stop) [0&apos; 1]Dice: [1&apos; 5&apos; 1, 1, 1]Four of a Kind. You win $15.You currently have $109 .Do you wish to try your luck? nThanks for playing! &ensp;&ensp;You can see how this interface provides just enough so that we can test out the model. In fact, we’ve got a game that’s already quite a bit of fun to play! 4. Developing a GUI&ensp;&ensp;Now that we have a working program, let’s turn our attention to a graphical interface. Our first step must be to decide exactly how we want our interface to look and function. The interface will have to support the various methods found in the text-based version and will also probably have some additional helper methods. 4.1 Designing the Interaction&ensp;&ensp;Let’s start with the basic methods that must be supported and decide exactly how interaction with the user will occur. Clearly, in a graphical interface, the faces of the dice and the current score should be continuously displayed. The setDice and setMoney methods will be used to change those displays. That leaves one output method, showResult, that we need to accommodate. One common way to handle this sort of transient information is with a message at the bottom of the window. This is sometimes called a status bar.&ensp;&ensp;To get information from the user, we will make use of buttons. In wantToPlay, the user will have to decide between either rolling the dice or quitting. We could include “Roll Dice” and “Quit” buttons for this choice. That leaves us with figuring out how the user should choose dice.&ensp;&ensp;To implement chooseDice, we could provide a button for each die and have the user click the buttons for the dice they want to roll. When the user is done choosing the dice, they could click the “Roll Dice” button again to roll the selected dice. Elaborating on this idea, it would be nice if we allowed the user to change his or her mind while selecting the dice. Perhaps clicking the button of a currently selected die would cause it to become deselected. The clicking of the button will serve as a sort of toggle that selects/unselects a particular die. The user commits to a certain selection by clicking on “Roll Dice.”&ensp;&ensp;Our vision for chooseDice suggests a couple of tweaks for the interface. First, we should have some way of showing the user which dice are currently selected. There are lots of ways we could do this. One simple approach would be to change the color of the dice. Let’s “gray out” the pips on the dice selected for rolling. Second, we need a good way for the user to indicate that they wish to stop rolling. That is, they would like the dice scored just as they stand. We could handle this by having them click the “Roll Dice” button when no dice are selected, hence asking the program to roll no dice. Another approach would be to provide a separate button to click that causes the dice to be scored. The latter approach seems a bit more intuitive/informative. Let’s add a “Score” button to the interface.&ensp;&ensp;Now we have a basic idea of how the interface will function. We still need to figure out how it will look. What is the exact layout of the widgets? The figure above is a sample of how the interface might look. I’m sure those of you with a more artistic eye can come up with a more pleasing interface, but we’ll use this one as our working design. 4.2 Managing the Widgets&ensp;&ensp;The graphical interface that we are developing makes use of buttons and dice. Our intent is to reuse the Button and DieView classes. Button This class needs the graphics class that we developed in previous exercise. 1234567891011121314151617181920212223242526272829303132333435363738394041from graphics import *class Button: &quot;&quot;&quot; A button is a labeled rectangle in a window. It is activated or deactivated with the activate() and deactivate() methods.The clicked(p) method returns true if the button is active and pi s inside it. &quot;&quot;&quot; def __init__(self, win, center, width, height, label): w,h = width/2.0, height/2.0 x = center.getX() y = center.getY() self.xmax, self.xmin = x + w, x - w self.ymax, self.ymin = y + h, y - h p1 = Point(self.xmin, self.ymin) p2 = Point(self.xmax, self.ymax) self.rect = Rectangle(p1, p2) self.rect.setFill(&apos;gray&apos;) self.rect.draw(win) self.label = Text(center, label) self.label.draw(win) self.deactivate() def clicked(self, p): return (self.active and self.xmin &lt;= p.getX() &lt;= self.xmax and self.ymin &lt;= p.getY() &lt;= self.ymax) def getLabel(self): return self.label.getText() def activate(self): self.label.setFill(&apos;black&apos;) self.rect.setWidth(2) self.active = True def deactivate(self): self.label.setFill(&quot;gray&quot;) self.rect.setWidth(1) self.active = False DieView the class constructor draws a square and seven circles to represent the positions where the pips of various values will appear. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from graphics import *class DieView: &quot;&quot;&quot; DieView is a widget that displays a graphical representation of a standard six-sided die. &quot;&quot;&quot; def __init__(self, win, center, size): &quot;&quot;&quot;Create a view of a die, e.g. : d1 = GDie(myWin, Point (40,50) , 20) creates a die centered at (40,50) having sides of length 20.&quot;&quot;&quot; # first define some standard values self.win = win self.background = &quot;white&quot; # color of die face self.foreground = &quot;black&quot; # color of the pips self.psize = 0.1 * size #radius of each pip hsize = size/2.0 # half of size offset = 0.6 * hsize # distance from center to outer pips # create a square for the face cx, cy = center.getX(), center.getY() p1 = Point(cx - hsize, cy - hsize) p2 = Point(cx + hsize, cy + hsize) rect = Rectangle(p1, p2) rect.draw(win) rect.setFill(self.background) # Create 7 circles for standard pip locations self.pips = [self.__makePip(cx - offset, cy - offset), self.__makePip(cx - offset, cy), self.__makePip(cx - offset, cy + offset), self.__makePip(cx, cy), self.__makePip(cx + offset, cy - offset), self.__makePip(cx + offset, cy), self.__makePip(cx + offset, cy + offset)] # Create a table for which pips are on for each value self.onTable = [[], [3], [2, 4], [2, 3, 4], [0, 2, 4, 6],[0,2,3,4,6],[0, 1, 2, 4, 5, 6]] self.setValue(1) def __makePip(self, x, y): &quot;&quot;&quot;Internal helper method to draw a pip at(x, y)&quot;&quot;&quot; pip = Circle(Point(x, y), self.psize) pip.setFill(self.background) pip.setOutline(self.background) pip.draw(self.win) return pip def setValue(self, value): &quot;&quot;&quot; Set this die to display value.&quot;&quot;&quot; # Turn all the pips off for pip in self.pips: pip.setFill(self.background) # Turn the appropriate pips back on for i in self.onTable[value]: self.pips[i].setFill(self.foreground)class ColorDieView(DieView): def setValue(self, value): self.value = value DieView.setValue(self, value) def setColor(self, color): self.foreground = color self.setValue(self.value) 4.3 Creating the Interface&ensp;&ensp;Now that we have our widgets under control, we are ready to actually implement our GUI poker interface. The constructor will create all of our widgets, setting up the interface for later interactions: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122from button import Buttonfrom graphics import *from dieview2 import DieView, ColorDieViewfrom dice import Diceclass Graphicsinterface: def __init__(self): self.win = GraphWin(&quot;Dice Poker&quot;, 600, 400) self.win.setBackground(&quot;green3&quot;) banner = Text(Point(300, 30), &quot;Python Poker Parlor&quot;) banner.setSize(24) banner.setFill(&quot;yellow2&quot;) banner.setStyle(&quot;bold&quot;) banner.draw(self.win) self.msg = Text(Point(300, 380), &quot;Welcome to the Dice Table&quot;) self.msg.setSize(18) self.msg.draw(self.win) self.createDice(Point(300, 100), 75) self.buttons = [] self.addDiceButtons(Point(300, 170), 75, 30) b = Button(self.win, Point(300, 230), 400, 40, &quot;Roll Dice&quot;) self.buttons.append(b) b = Button(self.win, Point(300, 280), 150, 40, &quot;Score&quot;) self.buttons.append(b) b = Button(self.win, Point(570, 375), 40, 30, &quot;Quit&quot;) self.buttons.append(b) self.money = Text(Point(300, 325), &quot;$100&quot;) self.money.setSize(18) self.money.draw(self.win) def choose(self, choices): buttons = self.buttons # activate choice buttons, deactivate others for b in buttons: if b.getLabel() in choices: b.activate() else: b.deactivate() # get mouse clicks unt il an active button is clicked while True: p = self.win.getMouse() for b in buttons: if b.clicked(p): return b.getLabel() # function ex it here. def setValue(self, value): # Turn all the pips off for pip in self.pips: pip.setFill(self.background) # Turn the appropriate pips back on for i in self.onTable[value]: self.pips[i].setFill(self.foreground) def createDice(self, center, size): center.move(-3 * size, 0) self.dice = [] for i in range(5): view = ColorDieView(self.win, center, size) self.dice.append(view) center.move(1.5 * size, 0) def setColor(self, color): self.foreground = color self.setValue(self.value) def addDiceButtons(self, center, width, height): center.move(-3 * width, 0) for i in range(1, 6): label = &quot;Die &#123;0&#125;&quot;.format(i) b = Button(self.win, center, width, height, label) self.buttons.append(b) center.move(1.5 * width, 0) def setMoney(self, amt): self.money.setText(&quot;$&#123;0&#125;&quot;.format(amt)) def showResult(self, msg, score): if score &gt; 0: text = &quot;&#123;0&#125; ! You win $&#123;1&#125;&quot;.format(msg, score) else: text = &quot;You rolled &#123;0&#125;&quot;.format(msg) self.msg.setText(text) def setDice(self, values): for i in range(5): self.dice[i].setValue(values[i]) def wantToPlay(self): ans = self.choose([&quot;Roll Dice&quot;, &quot;Quit&quot;]) self.msg.setText(&quot;&quot;) return ans == &quot;Roll Dice&quot; def chooseDice(self): # choices is a list of the indexes of the selected dice choices = [] # No dice chosen yet while True: # wait for user to click a valid button b = self.choose([&quot;Die 1&quot;, &quot;Die 2&quot;, &quot;Die 3&quot;, &quot;Die 4&quot;, &quot;Die 5&quot;, &quot;Roll Dice&quot;, &quot;Score&quot;]) if b[0] == &quot;D&quot;: i = int(b[4]) - 1 if i in choices: choices.remove(i) self.dice[i].setColor(&quot;black&quot;) else: choices.append(i) self.dice[i].setColor(&quot;gray&quot;) else: for d in self.dice: d.setColor(&quot;black&quot;) if b == &quot;Score&quot;: return [] elif choices != []: return choices def close(self): self.win.close() &ensp;&ensp;Finally, we need a few lines to actually get our graphical poker-playing program started. This code is exactly like the start code for the textual version, except that we use a Graphicsinterface in place of the Textinterface: 123456from graphicspoker import Graphicsinterfacefrom pokerapp import PokerAppinter = Graphicsinterface()app = PokerApp(inter)app.run() 5. The Completed Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290from graphics import *from random import randrangefrom random import *class Dice: def __init__(self): self.dice = [0]*5 self.rollAll() def roll(self, which): for pos in which: self.dice[pos] = randrange(1, 7) def rollAll(self): self.roll(range(5)) def values(self): return self.dice[:] def score(self): # Create the counts list # Counts[i] will be the number of times that the value i occurs in dice. # if the dice are: [3,2,5,2,3] then the counts list would be [0,0,2,2,0,1,0] counts = [0]*7 for value in self.dice: counts[value] = counts[value] + 1 # score the hand if 5 in counts: return &quot;Five of a Kind&quot; , 30 elif 4 in counts: return &quot;Four of a Kind&quot; , 15 elif (3 in counts) and (2 in counts) : return &quot;Full House&quot;, 12 elif 3 in counts: return &quot;Three of a Kind&quot;, 8 elif not (2 in counts) and (counts[1] == 0 or counts[6] == 0): return &quot;Straight&quot;, 20 elif counts.count(2) == 2: return &quot;Two Pairs&quot;, 5 else: return &quot;Garbage&quot;, 0class PokerApp: def __init__(self, interface): self.dice = Dice() self.money = 100 self.interface = interface def run(self): while self.money &gt;= 10 and self.interface.wantToPlay(): self.playRound() self.interface.close() def playRound(self): self.money = self.money - 10 self.interface.setMoney(self.money) self.doRolls() result, score = self.dice.score() self. interface. showResult (result, score) self.money = self.money + score self.interface.setMoney(self.money) def doRolls(self): self.dice.rollAll() roll = 1 self.interface.setDice(self.dice.values()) toRoll = self.interface.chooseDice() while roll &lt; 3 and toRoll != []: self.dice.roll(toRoll) roll = roll + 1 self.interface.setDice(self.dice.values()) if roll &lt; 3: toRoll = self.interface.chooseDice()class Button: def __init__(self, win, center, width, height, label): w,h = width/2.0, height/2.0 x = center.getX() y = center.getY() self.xmax, self.xmin = x + w, x - w self.ymax, self.ymin = y + h, y - h p1 = Point(self.xmin, self.ymin) p2 = Point(self.xmax, self.ymax) self.rect = Rectangle(p1, p2) self.rect.setFill(&apos;gray&apos;) self.rect.draw(win) self.label = Text(center, label) self.label.draw(win) self.deactivate() def clicked(self, p): return (self.active and self.xmin &lt;= p.getX() &lt;= self.xmax and self.ymin &lt;= p.getY() &lt;= self.ymax) def getLabel(self): return self.label.getText() def activate(self): self.label.setFill(&apos;black&apos;) self.rect.setWidth(2) self.active = True def deactivate(self): self.label.setFill(&quot;gray&quot;) self.rect.setWidth(1) self.active = Falseclass DieView: &quot;&quot;&quot; DieView is a widget that displays a graphical representation of a standard six-sided die.&quot;&quot;&quot; def __init__(self, win, center, size): &quot;&quot;&quot;Create a view of a die, e.g. : d1 = GDie(myWin, Point (40,50) , 20) creates a die centered at (40,50) having sides of length 20.&quot;&quot;&quot; # first define some standard values self.win = win self.background = &quot;white&quot; # color of die face self.foreground = &quot;black&quot; # color of the pips self.psize = 0.1 * size #radius of each pip hsize = size/2.0 # half of size offset = 0.6 * hsize # distance from center to outer pips # create a square for the face cx, cy = center.getX(), center.getY() p1 = Point(cx - hsize, cy - hsize) p2 = Point(cx + hsize, cy + hsize) rect = Rectangle(p1, p2) rect.draw(win) rect.setFill(self.background) # Create 7 circles for standard pip locations self.pips = [self.__makePip(cx - offset, cy - offset), self.__makePip(cx - offset, cy), self.__makePip(cx - offset, cy + offset), self.__makePip(cx, cy), self.__makePip(cx + offset, cy - offset), self.__makePip(cx + offset, cy), self.__makePip(cx + offset, cy + offset)] # Create a table for which pips are on for each value self.onTable = [[], [3], [2, 4], [2, 3, 4], [0, 2, 4, 6],[0,2,3,4,6],[0, 1, 2, 4, 5, 6]] self.setValue(1) def __makePip(self, x, y): &quot;&quot;&quot;Internal helper method to draw a pip at(x, y)&quot;&quot;&quot; pip = Circle(Point(x, y), self.psize) pip.setFill(self.background) pip.setOutline(self.background) pip.draw(self.win) return pip def setValue(self, value): &quot;&quot;&quot; Set this die to display value.&quot;&quot;&quot; # Turn all the pips off for pip in self.pips: pip.setFill(self.background) # Turn the appropriate pips back on for i in self.onTable[value]: self.pips[i].setFill(self.foreground)class ColorDieView(DieView): def setValue(self, value): self.value = value DieView.setValue(self, value) def setColor(self, color): self.foreground = color self. setValue(self.value)class Graphicsinterface: def __init__(self): self.win = GraphWin(&quot;Dice Poker&quot;, 600, 400) self.win.setBackground(&quot;green3&quot;) banner = Text(Point(300, 30), &quot;Python Poker Parlor&quot;) banner.setSize(24) banner.setFill(&quot;yellow2&quot;) banner.setStyle(&quot;bold&quot;) banner.draw(self.win) self.msg = Text(Point(300, 380), &quot;Welcome to the Dice Table&quot;) self.msg.setSize(18) self.msg.draw(self.win) self.createDice(Point(300, 100), 75) self.buttons = [] self.addDiceButtons(Point(300, 170), 75, 30) b = Button(self.win, Point(300, 230), 400, 40, &quot;Roll Dice&quot;) self.buttons.append(b) b = Button(self.win, Point(300, 280), 150, 40, &quot;Score&quot;) self.buttons.append(b) b = Button(self.win, Point(570, 375), 40, 30, &quot;Quit&quot;) self.buttons.append(b) self.money = Text(Point(300, 325), &quot;$100&quot;) self.money.setSize(18) self.money.draw(self.win) def choose(self, choices): buttons = self.buttons # activate choice buttons, deactivate others for b in buttons: if b.getLabel() in choices: b.activate() else: b.deactivate() # get mouse clicks unt il an active button is clicked while True: p = self.win.getMouse() for b in buttons: if b.clicked(p): return b.getLabel() # function ex it here. def setValue(self, value): # Turn all the pips off for pip in self.pips: pip.setFill(self.background) # Turn the appropriate pips back on for i in self.onTable[value]: self.pips[i].setFill(self.foreground) def createDice(self, center, size): center.move(-3 * size, 0) self.dice = [] for i in range(5): view = ColorDieView(self.win, center, size) self.dice.append(view) center.move(1.5 * size, 0) def setColor(self, color): self.foreground = color self.setValue(self.value) def addDiceButtons(self, center, width, height): center.move(-3 * width, 0) for i in range(1, 6): label = &quot;Die &#123;0&#125;&quot;.format(i) b = Button(self.win, center, width, height, label) self.buttons.append(b) center.move(1.5 * width, 0) def setMoney(self, amt): self.money.setText(&quot;$&#123;0&#125;&quot;.format(amt)) def showResult(self, msg, score): if score &gt; 0: text = &quot;&#123;0&#125; ! You win $&#123;1&#125;&quot;.format(msg, score) else: text = &quot;You rolled &#123;0&#125;&quot;.format(msg) self.msg.setText(text) def setDice(self, values): for i in range(5): self.dice[i].setValue(values[i]) def wantToPlay(self): ans = self.choose([&quot;Roll Dice&quot;, &quot;Quit&quot;]) self.msg.setText(&quot;&quot;) return ans == &quot;Roll Dice&quot; def chooseDice(self): # choices is a list of the indexes of the selected dice choices = [] # No dice chosen yet while True: # wait for user to click a valid button b = self.choose([&quot;Die 1&quot;, &quot;Die 2&quot;, &quot;Die 3&quot;, &quot;Die 4&quot;, &quot;Die 5&quot;, &quot;Roll Dice&quot;, &quot;Score&quot;]) if b[0] == &quot;D&quot;: i = int(b[4]) - 1 if i in choices: choices.remove(i) self.dice[i].setColor(&quot;black&quot;) else: choices.append(i) self.dice[i].setColor(&quot;gray&quot;) else: for d in self.dice: d.setColor(&quot;black&quot;) if b == &quot;Score&quot;: return [] elif choices != []: return choices def close(self): self.win.close()def main(): inter = Graphicsinterface() app = PokerApp(inter) app.run()if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BST Summary]]></title>
    <url>%2F2018%2F10%2F29%2F2018%2F2018-10-29-bst-summary%2F</url>
    <content type="text"><![CDATA[Data Structure – BST1. 定义：BST(Binary Search Tree)或者是一棵空树，或者是具有下列性质的二叉树： 若左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若右子树不空，则右子树上所有结点的值均大于它的根结点的值； 左、右子树也分别为二叉排序树； 没有键值相等的节点。 2.基本操作主要包括：查找、插入、建立、删除1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798struct node &#123; int data; node *lchild; node *rchild;&#125;;// 新建节点，返回一个节点指针node* newNode(int v)&#123; node* Node = new node; Node-&gt;data = v; Node-&gt;lchild = Node-&gt;rchild = NULL; return Node;&#125;// search x 只需搜索一边子树即可,O(h) h表示树高void search(node* root, int x)&#123; if(root == NULL) &#123; printf(&quot;search failed!\n&quot;); return; &#125; if(x == root-&gt;data) printf(&quot;%d\n&quot;, root-&gt;data); else if(x &lt; root-&gt;data) search(root-&gt;lchild, int x); else search(root-&gt;rchild, int x);&#125;// insert x 当root==NULL时，即为插入之处 O(h)void insert(node* &amp;root, int x)&#123; if(root == NULL)&#123; root = newNode(x); return; &#125; if(x == root-&gt;data) return; else if(x &lt; root-&gt;data) insert(root-&gt;lchild, x); else insert(root-&gt;rchild, x);&#125;// BST的建立(注意：同一组数据，如果插入的顺序不同最后形成的BST可能也不同)// 复杂度O(h)*n = O(nlog2n)node *Create(int data[], int n)&#123; node* root = NULL; for (int i = 0; i &lt; n; ++i) &#123; insert(root, data[i]); &#125; return root;&#125;//BST的节点删除，删除根节点//删除根节点后，用直接后继或者直接前驱来替换//直接前驱：左子树一直向右直到某一节点的右子树为NULL的节点//直接后继：右子树一直向左直到某一节点的左子树为NULL的节点//FindMin()函数用于寻找树root的最小权值节点node* FindMin(node* root)&#123; while(root-&gt;lchild != NULL) root = root-&gt;lchild; return root;&#125;//FindMax()函数用于寻找树root的最大权值节点node* FindMax(node* root)&#123; while(root-&gt;rchild != NULL) root = root-&gt;rchild; return root;&#125;/*BST删除节点步骤:1. 当前节点root空，直接返回2. 当前节点root的data值等于x，进入删除操作 a)当前节点root为叶子节点，直接删除。 b)当前节点root存在左子树，找到前驱pre，覆盖root，删除pre c)当前节点root存在右子树，找到后继next，覆盖root，删除next3. 若当前节点root权值大于x，则root = root-&gt;lchild 递归删除4. 若当前节点root权值小于x，则root = root-&gt;rchild 递归删除*/void deleteNode(node* &amp;root, int x)&#123; if(root == NULL) return; if(root-&gt;data == x) &#123; if(root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) root = NULL; else if(root-&gt;lchild != NULL) &#123; node *pre = FindMax(root-&gt;lchild); root-&gt;data = pre-&gt;data; deleteNode(root-&gt;lchild, pre-&gt;data); //删除pre节点 &#125; else &#123; node* next = FindMin(root-&gt;rchild); root-&gt;data = next-&gt;data; deleteNode(root-&gt;rchild, next-&gt;data); //删除next 节点 &#125; &#125; else if(root-&gt;data &gt; x) deleteNode(root-&gt;lchild, x); else deleteNode(root-&gt;rchild, x);&#125; 3. 应用利用PAT1043_Is It a Binary Search Tree 来练习一下BST。 1043 Is It a Binary Search Tree （25 分）A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. If we swap the left and right subtrees of every node, then the resulting tree is called the Mirror Image of a BST.Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST. Input Specification: Each input file contains one test case. For each case, the first line contains a positive integer N (≤1000). Then N integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification: For each test case, first print in a line YES if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or NO if not. Then if the answer is YES, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1:1278 6 5 7 10 8 11 Sample Output 1:12YES5 7 6 8 11 10 8 Sample Input 2:1278 10 11 8 6 7 5 Sample Output 2:12YES11 8 10 7 5 6 8 Sample Input 3:1278 6 8 5 10 9 11 Sample Output 3:1NO Code and Analysis:(1) 题意：判断给定序列是不是BST或者BST的镜像的先序遍历序列。是，输出YES和后序遍历序列；否，输出NO结束。(2) 思路步骤： 对给定的序列建立BST 对BST先序遍历，后序遍历，BST镜像先序遍历，BST镜像后序遍历 将给定序列与BST先序遍历，BST镜像先序遍历比较，相等，输出YES和对应后序序列，不相等，输出NO。 (3) 数据结构：用vector存储给定序列origin, BST先序序列pre, BST后序序列post, BST镜像先序序列preM, BST镜像后序序列postM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;struct node&#123; int data; node* lchild; node* rchild;&#125;;void insert(node* &amp;root, int x)&#123; if(root == NULL) &#123; root = new node; root-&gt;data = x; root-&gt;lchild = root-&gt;rchild = NULL; return; &#125; else if(root-&gt;data &gt; x) insert(root-&gt;lchild, x); else insert(root-&gt;rchild, x);&#125;// 先序遍历：中左右 --- 镜像先序遍历：中右左// 后序遍历：左右中 --- 镜像后序遍历：右左中// 中序遍历：左中右 --- 镜像中序遍历：右中左void preOrder(node* root, vector&lt;int&gt;&amp;vi)&#123; if(root == NULL) return; vi.push_back(root-&gt;data); preOrder(root-&gt;lchild, vi); preOrder(root-&gt;rchild, vi);&#125;void preMirror(node* root, vector&lt;int&gt;&amp;vi)&#123; if(root == NULL) return; vi.push_back(root-&gt;data); preMirror(root-&gt;rchild, vi); preMirror(root-&gt;lchild, vi);&#125;void postOrder(node* root, vector&lt;int&gt;&amp;vi)&#123; if(root == NULL) return; postOrder(root-&gt;lchild, vi); postOrder(root-&gt;rchild, vi); vi.push_back(root-&gt;data);&#125;void postMirror(node* root, vector&lt;int&gt;&amp;vi)&#123; if(root == NULL) return; postMirror(root-&gt;rchild, vi); postMirror(root-&gt;lchild, vi); vi.push_back(root-&gt;data);&#125;vector&lt;int&gt; origin, pre, post, preM, postM;int main(int argc, char const *argv[])&#123; int n, data; node* root = new node; root = NULL; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, &amp;data); origin.push_back(data); insert(root, data); &#125; preOrder(root, pre); preMirror(root, preM); postOrder(root, post); postMirror(root, postM); if(origin == pre)&#123; printf(&quot;YES\n&quot;); for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d&quot;,post[i]); if(i &lt; n-1) printf(&quot; &quot;); &#125; &#125; else if(origin == preM)&#123; printf(&quot;YES\n&quot;); for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d&quot;, postM[i]); if(i &lt; n-1) printf(&quot; &quot;); &#125; &#125; else printf(&quot;NO\n&quot;); return 0;&#125;/*78 6 5 7 10 8 11 */]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>PAT</tag>
        <tag>Traversal</tag>
        <tag>Order</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise5]]></title>
    <url>%2F2018%2F10%2F28%2FExercise5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这是我们老师布置的作业，以下是我的一些总结。 1. Programming Exercise Modify the cannonball simulation from the chapter so that it also calculates the maximum height achieved by the cannonball. Program Specification Suppose we want to write a program that simulates the flight of a cannonball (or any other projectile such as a bullet, baseball, or shot put). We are particularly interested in finding out how far the cannonball will travel when fired at various launch angles and initial velocities. The input to the program will be the launch angle (in degrees), the initial velocity (in meters per second), and the initial height (in meters) of the cannonball. The output will be the distance that the projectile travels before striking the ground (in meters). In addition, the program also can calculate the maximum height. 2. Code and Analysis2.1 The First Version&ensp;&ensp;Let’s start by designing an algorithm. Given the problem statement, it’s clear that we need to consider the flight of the cannonball in two dimensions: height, so we know when it hits the ground; and distance, to keep track of how far it goes. We can think of the position of the cannonball as a point ( x, y) in a 2D graph where the value of y gives the height above the ground and the value of x gives the distance from the starting point. &ensp;&ensp;The Projectile class must have an init method that uses these values to initialize the instance variables of cball. But what should the instance variables be? Of course, they will be the four pieces of information that characterize the flight of the cannonball: xpos, ypos, xvel, yvel and MaxHeight. &ensp;&ensp; Notice how we have created five instance variables inside the object using the self dot notation. The value of theta is not needed after ini t terminates, so it is just a normal (local) function variable. The methods for accessing the position of our projectiles are straightforward; the current position is given by the instance variables xpos, ypos and MaxHeight. We just need a couple of methods that return these values. &ensp;&ensp;Finally, we come to the update method. This method takes a single normal parameter that represents an interval of time. We need to update the state of the projectile to account for the passage of that much time. Here’s the code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from math import sin, cos, radiansclass Projectile: def __init__(self, angle, velocity, height): self.xpos = 0.0 self.ypos = height theta = radians(angle) self.xvel = velocity * cos(theta) self.yvel = velocity * sin(theta) self.MaxHeight = self.ypos def update(self, time): self.xpos = self.xpos + time * self.xvel yvel1 = self.yvel - 9.8 * time self.ypos = self.ypos + time * (self.yvel + yvel1) / 2.0 self.yvel = yvel1 if self.ypos &gt; self.MaxHeight: self.MaxHeight = self.ypos def getY(self): return self.ypos def getX(self): return self.xpos def getMaxHeight(self): return self.MaxHeightdef getInputs(): a = float(input(&quot;Enter the launch angle (in degrees): &quot;)) v = float(input(&quot;Enter the initial velocity (in meters/sec): &quot;)) h = float(input(&quot;Enter the initial height (in meters): &quot;)) t = float(input(&quot;Enter the time interval between position calculations: &quot;)) return a, v, h, tdef main(): angle, vel, h0, time = getInputs() cball = Projectile(angle, vel, h0) cball.update(time) while cball.getY() &gt;= 0: cball.update(time) print(&quot;\nDistance traveled: &#123;0:0.1f&#125; meters.&quot;. format(cball.getX())) print(cball.xvel) print(cball.getMaxHeight())if __name__ == &quot;__main__&quot;: main() 2.2 The Second Version&ensp;&ensp;Based on the first version, let’s use our new object ideas to add a nicer interface to the cannonball example that started the chapter. Instead of having a boring text -based interface, the program would be more fun to use if it had a graphical interface. It would be nice to actually “see” where the canonball ends up and how it gets there. Figure 10.4 shows what I have in mind. Here you can see a cannonball currently in flight as well as where two previous shots ended. 2.2.1 Creating a Graphics Window&ensp;&ensp;The first step in the program is to create a graphics window and draw the appropriate scale line across the bottom. Using our graphics library; this is straightforward. Here’s the start of the program:123456789101112def main(): # create animation window win = GraphWin(&quot;Projectile Animation&quot;, 640, 480, autoflush = False) win.setCoords(-10, -10, 210, 155) # draw baseline Line(Point(-10, 0), Point(210, 0)).draw(win) # draw labeled tricks every 50 meters for x in range(0, 210, 50): Text(Point(x, -5), str(x)).draw(win) Line(Point(x, 0), Point(x, 2)).draw(win) 2.2.2 ShotTracker Class&ensp;&ensp;The next thing we need is a graphical object that acts like a cannonball. We can use our existing Projectile class to model the flight of a cannonball, but a Projectile is not a graphics object; we can’t draw it in the window. On the other hand, a Circle is a good candidate for the graphical representation of the cannonball, but it does not know how to model projectile flight. What we really want is something that has elements of both. We can create this new hybrid circle-projectile by defining a suitable class for it. Let’s call it a ShotTracker. &ensp;&ensp;Our Shot Tracker will contain both a Projectile and a Circle. Its job is to make sure that these instance variables stay in sync with each other. &ensp;&ensp;Notice how the parameters provide all of the information needed to create both a Projectile and a Circle, which are stored in the instance variables proj and marker, respectively. I used the name marker because the circle is graphically marking the projectile’s current location. I chose the radius 3 because it shows up nicely in the animation. Realistically, a 3-meter radius would be way too large for an actual cannonball. Now that we have a suitable projectile and circle, we just need to ensure that whenever an update occurs, both the projectile and the position of the circle are modified appropriately. We can do that by giving our ShotTracker an update method that handles both pieces. Updating the Projectile object is a simple matter of calling its own update method with the appropriate time interval. For the circle, we calculate the distance it must move in the x and y directions to put the center of the circle where the updated projectile is located. 12345678910111213141516171819202122232425262728293031323334353637class ShotTracker(object): def __init__(self, win, angle, velocity, height): &quot;&quot;&quot; win is the GraphWin to display the shot. angle, velocity, and height are initial projectile parameters. &quot;&quot;&quot; self.proj = Projectile(angle, velocity, height) self.marker = Circle(Point(0, height), 3) self.marker.setFill(&quot;red&quot;) self.marker.setOutline(&quot;red&quot;) self.marker.draw(win) def update(self, dt): &quot;&quot;&quot; Move the shot dt seconds farther along its flight &quot;&quot;&quot; # update the projectile self.proj.update(dt) # move the circle to the new projectile location center = self.marker.getCenter() dx = self.proj.getX() - center.getX() dy = self.proj.getY() - center.getY() self.marker.move(dx, dy) def getX(self): return self.proj.getX() def getY(self): return self.proj.getY() def getMaxHeight(self): return self.proj.getMaxHeight() def undraw(self): self.marker.undraw() 2.2.3 Creating a Button Class&ensp;&ensp;Our buttons will support the following methods: constructor Creates a button in a window. We will have to specify the window in which the button will be displayed, the location/size of the button, and the label that will be on the button. activate Sets the state of the button to active. deactivate Sets the state of the button to inactive. clicked Indicates whether the button was clicked. If the button is active, this method will determine if the point clicked is inside the button region. The point will have to be sent as a parameter to the method. getLabel Returns the label string of the button. This is provided so that we can identify a particular button.Here’s the code:1234567891011121314151617181920212223242526272829303132class Button: def __init__(self, win, center, width, height, label): w,h = width/2.0, height/2.0 x = center.getX() y = center.getY() self.xmax, self.xmin = x + w, x - w self.ymax, self.ymin = y + h, y - h p1 = Point(self.xmin, self.ymin) p2 = Point(self.xmax, self.ymax) self.rect = Rectangle(p1, p2) self.rect.setFill(&apos;gray&apos;) self.rect.draw(win) self.label = Text(center, label) self.label.draw(win) self.deactivate() def clicked(self, p): return (self.active and self.xmin &lt;= p.getX() &lt;= self.xmax and self.ymin &lt;= p.getY() &lt;= self.ymax) def getLabel(self): return self.label.getText() def activate(self): self.label.setFill(&apos;black&apos;) self.rect.setWidth(2) self.active = True def deactivate(self): self.label.setFill(&quot;gray&quot;) self.rect.setWidth(1) self.active = False 2.2.4 Creating an Input Dialog&ensp;&ensp;Before we actually put a cannonball in flight, we’ll need to get the projectile parameters angle, velocity, and initial height from the user. We could do this using input, just as in the original program. But as long as we’re designing a graphical interface, we may as well handle the input in a more graphical fashion as well. A common way of getting user input in a GUI is to use a dialog box. For example, in Chapter 5 I discussed using pre-built system dialogs that allow users to select file names. Using the graphics library, we can easily create our own simple dialogs to get information from the user. A dialog box is a sort of miniGUI that serves as an independent component of a larger program. Something like Figure 10.5 will do the trick. The user can change the input values and select either “Fire!” to launch the cannonball or “Quit” to exit the program. As you can see, this is just a Graph Win containing a few Text, Entry, and Button objects.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class InputDialog: def __init__(self, angle, vel, height): self.win = GraphWin(&quot;Initial Values&quot;, 200, 300) win = self.win win.setCoords(0, 5.5, 4, .5) Text(Point(1, 1), &quot;Angle&quot;).draw(win) self.angle = Entry(Point(3, 1), 5).draw(win) self.angle.setText(str(angle)) Text(Point(1, 2), &quot;Velocity&quot;).draw(win) self.vel = Entry(Point(3, 2), 5).draw(win) self.vel.setText(str(vel)) Text(Point(1, 3), &quot;Height&quot;).draw(win) self.height = Entry(Point(3, 3), 5).draw(win) self.height.setText(str(height)) Text(Point(1, 4), &quot;MaxHeight&quot;).draw(win) self.maxheight = Entry(Point(3, 4), 5).draw(win) self.fire = Button(win, Point(1, 5), 1.25, .5, &quot;Fire!&quot;) self.fire.activate() self.quit = Button(win, Point(3, 5), 1.25, .5, &quot;Quit&quot;) self.quit.activate() def interact(self): &quot;&quot;&quot; wait for user to click Quit or Fire button Returns a string indicating which button was clicked &quot;&quot;&quot; while True: pt = self.win.getMouse() if self.quit.clicked(pt): return &quot;Quit&quot; if self.fire.clicked(pt): return &quot;Fire!&quot; def getValues(self): a = float(self.angle.getText()) v = float(self.vel.getText()) h = float(self.height.getText()) return a, v, h def close(self): self.win.close() 2.2.5 The Main Event Loop&ensp;&ensp;Now we are ready to finish our program by filling in the main event loop. Here’s the completed main function:123456789101112131415161718192021222324252627282930313233343536def main(): # create animation window win = GraphWin(&quot;Projectile Animation&quot;, 640, 480, autoflush = False) win.setCoords(-10, -10, 210, 155) # draw baseline Line(Point(-10, 0), Point(210, 0)).draw(win) # draw labeled tricks every 50 meters for x in range(0, 210, 50): Text(Point(x, -5), str(x)).draw(win) Line(Point(x, 0), Point(x, 2)).draw(win) angle, vel, height = 45.0, 40.0, 2.0 inputwin = InputDialog(angle, vel, height) while True: # interact with the user choice = inputwin.interact() #inputwin.close() if choice == &quot;Quit&quot;: # loop exit break break angle, vel, height = inputwin.getValues() shot = ShotTracker(win, angle, vel, height) while 0 &lt;= shot.getY() &lt;=155 and -10 &lt; shot.getX() &lt;= 210: shot.update(1 / 50) update(50) inputwin.maxheight.setText(str(shot.getMaxHeight())) #inputwin.close() win.close() The completed program looks like this: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204from math import *import mathfrom turtle import *from graphics import *class Projectile(object): def __init__(self, angle, velocity, height): self.xpos = 0.0 self.ypos = height theta = math.pi * angle / 180 self.xvel = velocity * cos(theta) self.yvel = velocity * sin(theta) self.MaxHeight = self.ypos #保存最大高度 def update(self, time): self.xpos = self.xpos + time * self.xvel yvel1 = self.yvel - 9.8 * time self.ypos = self.ypos + time * (self.yvel + yvel1) / 2.0 self.yvel = yvel1 # 获取最大高度保存到Self.MaxHeight中 if self.ypos &gt; self.MaxHeight: self.MaxHeight = self.ypos def getY(self): return self.ypos def getX(self): return self.xpos def getMaxHeight(self): return self.MaxHeight# def getInputs():# a = float(input(&quot;Enter the launch angle (in degrees): &quot;))# v = float(input(&quot;Enter the initial velocity (in meters/sec): &quot;))# h = float(input(&quot;Enter the initial height (in meters): &quot;))# t = float(input(&quot;Enter the time interval between position calculations: &quot;))## return a, v, h, tclass ShotTracker(object): def __init__(self, win, angle, velocity, height): &quot;&quot;&quot; win is the GraphWin to display the shot. angle, velocity, and height are initial projectile parameters. &quot;&quot;&quot; self.proj = Projectile(angle, velocity, height) self.marker = Circle(Point(0, height), 3) self.marker.setFill(&quot;red&quot;) self.marker.setOutline(&quot;red&quot;) self.marker.draw(win) def update(self, dt): &quot;&quot;&quot; Move the shot dt seconds farther along its flight &quot;&quot;&quot; # update the projectile self.proj.update(dt) # move the circle to the new projectile location center = self.marker.getCenter() dx = self.proj.getX() - center.getX() dy = self.proj.getY() - center.getY() self.marker.move(dx, dy) def getX(self): return self.proj.getX() def getY(self): return self.proj.getY() def getMaxHeight(self): return self.proj.getMaxHeight() def undraw(self): self.marker.undraw()class Button: def __init__(self, win, center, width, height, label): w,h = width/2.0, height/2.0 x = center.getX() y = center.getY() self.xmax, self.xmin = x + w, x - w self.ymax, self.ymin = y + h, y - h p1 = Point(self.xmin, self.ymin) p2 = Point(self.xmax, self.ymax) self.rect = Rectangle(p1, p2) self.rect.setFill(&apos;gray&apos;) self.rect.draw(win) self.label = Text(center, label) self.label.draw(win) self.deactivate() def clicked(self, p): return (self.active and self.xmin &lt;= p.getX() &lt;= self.xmax and self.ymin &lt;= p.getY() &lt;= self.ymax) def getLabel(self): return self.label.getText() def activate(self): self.label.setFill(&apos;black&apos;) self.rect.setWidth(2) self.active = True def deactivate(self): self.label.setFill(&quot;gray&quot;) self.rect.setWidth(1) self.active = Falseclass InputDialog: def __init__(self, angle, vel, height): self.win = GraphWin(&quot;Initial Values&quot;, 200, 300) win = self.win win.setCoords(0, 5.5, 4, .5) Text(Point(1, 1), &quot;Angle&quot;).draw(win) self.angle = Entry(Point(3, 1), 5).draw(win) self.angle.setText(str(angle)) Text(Point(1, 2), &quot;Velocity&quot;).draw(win) self.vel = Entry(Point(3, 2), 5).draw(win) self.vel.setText(str(vel)) Text(Point(1, 3), &quot;Height&quot;).draw(win) self.height = Entry(Point(3, 3), 5).draw(win) self.height.setText(str(height)) Text(Point(1, 4), &quot;MaxHeight&quot;).draw(win) self.maxheight = Entry(Point(3, 4), 5).draw(win) self.fire = Button(win, Point(1, 5), 1.25, .5, &quot;Fire!&quot;) self.fire.activate() self.quit = Button(win, Point(3, 5), 1.25, .5, &quot;Quit&quot;) self.quit.activate() def interact(self): &quot;&quot;&quot; wait for user to click Quit or Fire button Returns a string indicating which button was clicked &quot;&quot;&quot; while True: pt = self.win.getMouse() if self.quit.clicked(pt): return &quot;Quit&quot; if self.fire.clicked(pt): return &quot;Fire!&quot; def getValues(self): a = float(self.angle.getText()) v = float(self.vel.getText()) h = float(self.height.getText()) return a, v, h def close(self): self.win.close()def main(): # create animation window win = GraphWin(&quot;Projectile Animation&quot;, 640, 480, autoflush = False) win.setCoords(-10, -10, 210, 155) # draw baseline Line(Point(-10, 0), Point(210, 0)).draw(win) # draw labeled tricks every 50 meters for x in range(0, 210, 50): Text(Point(x, -5), str(x)).draw(win) Line(Point(x, 0), Point(x, 2)).draw(win) angle, vel, height = 45.0, 40.0, 2.0 inputwin = InputDialog(angle, vel, height) while True: # interact with the user choice = inputwin.interact() #inputwin.close() if choice == &quot;Quit&quot;: # loop exit break break angle, vel, height = inputwin.getValues() shot = ShotTracker(win, angle, vel, height) while 0 &lt;= shot.getY() &lt;=155 and -10 &lt; shot.getX() &lt;= 210: shot.update(1 / 50) update(50) inputwin.maxheight.setText(str(shot.getMaxHeight())) #inputwin.close() win.close()if __name__ == &quot;__main__&quot;: main() Appendix: The graphics library summary: https://blog.csdn.net/winycg/article/details/78066044?locationNum=4&amp;fps=1]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Decision Tree]]></title>
    <url>%2F2018%2F10%2F17%2FDecisionTree%2F</url>
    <content type="text"><![CDATA[1. 什么是决策树/判定树（decision tree) &emsp;&emsp;判定树是一个类似于流程图的树结构：其中，每个内部结点表示在一个属性上的测试，每个分支代表一个属性输出，而每个树叶结点代表类或类分布。树的最顶层是根结点。决策树是分类方法中的一种。 2. 构造决策树的基本算法 2.1 熵（entropy）概念信息和抽象，如何度量&emsp;&emsp;1948年，香农提出了 ”信息熵(entropy)“的概念一条信息的信息量大小和它的不确定性有直接的关系，要搞清楚一件非常非常不确定的事情，或者是我们一无所知的事情，需要了解大量信息==&gt;信息量的度量就等于不确定性的多少 例子：猜世界杯冠军，假如一无所知，猜多少次？每个队夺冠的几率不是相等的 比特(bit)来衡量信息的多少 变量的不确定性越大，熵也就越大 2.2 决策树归纳算法（ID3）1970-1980， J.Ross. Quinlan, ID3算法选择属性判断结点信息获取量(Information Gain)：Gain(A) = Info(D) - Infor_A(D)通过A来作为节点分类获取了多少信息 同理，有：Gain(income) = 0.029, Gain(student) = 0.151, Gain(credit_rating)=0.048 所以，选择age作为第一个根节点 再对每一个表类推。 算法 ： 树以代表训练样本的单个结点开始（步骤1）。 如果样本都在同一个类，则该结点成为树叶，并用该类标号（步骤2 和3）。 否则，算法使用称为信息增益的基于熵的度量作为启发信息，选择能够最好地将样本分类的属性（步骤6）。该属性成为该结点的“测试”或“判定”属性（步骤7）。在算法的该版本中， 所有的属性都是分类的，即离散值。连续属性必须离散化。 对测试属性的每个已知的值，创建一个分枝，并据此划分样本（步骤8-10）。 算法使用同样的过程，递归地形成每个划分上的样本判定树。一旦一个属性出现在一个结点上，就不必该结点的任何后代上考虑它（步骤13）。 递归划分步骤仅当下列条件之一成立停止： (a) 给定结点的所有样本属于同一类（步骤2 和3）。 (b) 没有剩余属性可以用来进一步划分样本（步骤4）。在此情况下，使用多数表决（步骤5）。 这涉及将给定的结点转换成树叶，并用样本中的多数所在的类标记它。替换地，可以存放结 点样本的类分布。 (c) 分枝 test_attribute = a i 没有样本（步骤11）。在这种情况下，以 samples 中的多数类 创建一个树叶（步骤12） 2.3 其他算法： C4.5: Quinlan Classification and Regression Trees (CART): (L. Breiman, J. Friedman, R. Olshen, C. Stone) 共同点：都是贪心算法，自上而下(Top-down approach) 区别：属性选择度量方法不同： C4.5 （gain ratio), CART(gini index), ID3 (Information Gain)3 决策树注意点3.1 如何处理连续性变量的属性？以某个值为界限分割3.2. 树剪枝叶 （避免overfitting) 4.1 先剪枝 4.2 后剪枝 3.3. 决策树的优缺点： 优点：直观，便于理解，小规模数据集有效 缺点： 处理连续变量不好 类别较多时，错误增加的比较快 可规模性一般4.应用4.1 准备 python3.6 scikit-learn库 安装 Graphviz http://www.graphviz.org/ 配置环境变量 4.2 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import numpy as npfrom sklearn.feature_extraction import DictVectorizerimport csvfrom sklearn import treefrom sklearn import preprocessingfrom sklearn.externals.six import StringIO# Read in the csv file and put features into list of dict and list of class labelallElectronicsData = open(r&apos;AllElectronics.csv&apos;, &apos;rt&apos;)reader = csv.reader(allElectronicsData)headers = next(reader) # 存放属性名# 决策树第一步获得featureLIst（每个元素为字典）和labelList（每个元素为字符串），并字典向量化print(headers)featureList = []labelList = []for row in reader: labelList.append(row[len(row)-1]) rowDict = &#123;&#125; for i in range(1, len(row)-1): rowDict[headers[i]] = row[i] featureList.append(rowDict)print(featureList)# Vetorize features# 有多个属性时，对于每个属性是平等的，按照字典序排列，对于每个属性下的值即字典值也是平等的，按照字典排序vec = DictVectorizer()dummyX = vec.fit_transform(featureList) .toarray()print(&quot;dummyX: &quot; + str(dummyX))print(vec.get_feature_names())print(&quot;labelList: &quot; + str(labelList))# vectorize class labelslb = preprocessing.LabelBinarizer()dummyY = lb.fit_transform(labelList)print(&quot;dummyY: &quot; + str(dummyY))# Using decision tree for classification# clf = tree.DecisionTreeClassifier()clf = tree.DecisionTreeClassifier(criterion=&apos;entropy&apos;)clf = clf.fit(dummyX, dummyY)print(&quot;clf: &quot; + str(clf))# Visualize modelwith open(&quot;allElectronicInformationGainOri.dot&quot;, &apos;w&apos;) as f: f = tree.export_graphviz(clf, feature_names=vec.get_feature_names(), out_file=f)oneRowX = dummyX[0, :]print(&quot;oneRowX: &quot; + str(oneRowX))newRowX = oneRowXnewRowX[0] = 1newRowX[2] = 0print(&quot;newRowX: &quot; + str(newRowX))new = np.array(newRowX).reshape(1, -1)predictedY = clf.predict(new)print(&quot;predictedY: &quot; + str(predictedY)) 注意：转化dot文件至pdf可视化决策树：在cmd，对应文件夹中输入dot -Tpdf allElectronicInformationGainOri.dot -o outpu.pdf结果如下：]]></content>
      <categories>
        <category>Machine Leaning</category>
      </categories>
      <tags>
        <tag>Decision Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连续子向量中最大和的四种算法]]></title>
    <url>%2F2018%2F10%2F15%2F%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%90%91%E9%87%8F%E4%B8%AD%E6%9C%80%E5%A4%A7%E5%92%8C%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、问题描述：来自一维的模式识别输入与输出 输入：具有n个浮点数的向量x 输出：输入向量的任何连续子向量中的最大和。假定输出的最大和为非负数。 二、四种算法与分析 暴力法： 基本思路：对所有满足0 ≤ i ≤ j &lt; n的整数对(i,j)进行检查，判断x[i..j]的总和Sum(x[i..j])是否最大？其中Sum(x[i..j]) 该算法时间复制度为O(n^3) 123456789101112131415float alg1()&#123; int i, j, k; float sum, maxsofar = 0; for (i = 0; i &lt; n; i++) for (j = i; j &lt; n; j++) &#123; sum = 0; for (k = i; k &lt;= j; k++) sum += x[k]; if (sum &gt; maxsofar) maxsofar = sum; &#125; return maxsofar;&#125; 暴力法的一些简化基本思路： 对所有满足0 ≤ i ≤ j &lt; n的整数对(i,j)进行检查，判断x[i..j]的总和sum(x[i..j])是否最大？ 如何计算sum(x[i..j])？ sum(x[i..j]) = sum(x[i..j-1])+x[j] sum(x[i..j]) = sum(x[0..j])-sum(x[0..i-1]) 该算法时间复制度为O(n^2)由以上两种计算sum(x[i..j])，可以得到两种算法 12345678910111213141516171819202122232425262728293031323334353637383940414243//第一种float alg2()&#123; int i, j, k; float sum, maxsofar = 0; for (i = 0; i &lt; n; i++) &#123; sum = 0; for (j = i; j &lt; n; j++) &#123; sum += x[j]; if(sum &gt; maxsofar) maxsofar = sum; &#125; &#125; return maxsofar;&#125;//第二种float cumvec[MAXN + 1];float alg2b()&#123; int i, j, k; float *cumarr, sum, maxsofar = 0; cumarr = cumvec + 1; cumarr[-1] = 0; for(i = 0; i &lt; n; i++) cumarr[i] = cumarr[i - 1] = x[i]; for(i = 0; i &lt; n; i++) &#123; for(j = i; j &lt; n; j++) &#123; sum = cumarr[j] - cumarr[i - 1]; if(sum &gt; maxsofar) maxsofar = sum; &#125; &#125; return maxsofar;&#125; 分治法 分治原理：要解决规模为n的问题，可递归地解决两个规模近似为n/2的子问题，然后对它们的答案进行合并以得到整个问题的答案。 初始问题：找出大小为n的向量x中连续子向量中的最大和mx Step1:将向量x划分为两个大小近似相等的子向量a和b Step2:分别递归地找出a、b中连续子向量中的最大和为ma,mb Step3:mx=max(ma,mb,mc)，其中mc=max(sum(x[i..n/2-1])) +max(sum(x[n/2..j])) 该算法时间复制度为O(nlogn)123456789101112131415161718192021222324252627282930313233343536float maxfun(float a, float b)&#123; return a &gt; b ? a : b;&#125;#define max(a, b) maxfun(a, b)float alg3()&#123; return recmax(0, n-1);&#125;float recmax(int l, int u)&#123; int i, m; float lmax, rmax, sum; if (l &gt; u) /* zero elements */ return 0; if (l == u) /* one element */ return max(0, x[l]); m = (l+u) / 2;// find max crossing to left lmax = sum = 0; for(i = m; i &gt;= l; i--)&#123; sum += x[i]; if(sum &gt; lmax) lmax = sum; &#125; rmax = sum = 0; for(i = m+1; i &lt;= u; i++)&#123; sum += x[i]; if(sum &gt; rmax) rmax = sum; &#125; return max(lmax + rmax, max(recmax(l, m),recmax(m+1, u)));&#125; 扫描法 初始问题：找出大小为n的向量x中连续子向量中的最大和mx 利用分治原理 假设现在已解决了大小为(i-1)的向量x[0..i-2]的问题，那么如何计算大小为i的向量x[0..i-1]的问题呢？ 大小为i的向量x[0..i-1]中连续子向量中的最大和mx[0..i-1] =max(mx[0..i-2],maxendinghere[i-1])其中maxendinghere[i-1]表示向量x[0..i-1]中结束位置为(i-1)的连续子向量的最大和，即maxendinghere[i-1]=max(sum(x[0..i-1]), sum(x[1..i-1]), … , sum(x[i-1..i-1]))。假定maxendinghere≥0. 该算法时间复制度为O(n) 12345678910111213141516171819202122232425262728293031323334353637383940// 第一种float alg4()&#123; int i; float maxsofar = 0, maxendinghere = 0; for (i = 0; i &lt; n; i++) &#123; maxendinghere += x[i]; if (maxendinghere &lt; 0) maxendinghere = 0; if (maxsofar &lt; maxendinghere) maxsofar = maxendinghere; &#125; return maxsofar;&#125;//第二种#define maxmac(a, b) ((a) &gt; (b) ? (a) : (b) )float alg4b()&#123; int i; float maxsofar = 0, maxendinghere = 0; for (i = 0; i &lt; n; i++) &#123; maxendinghere += x[i]; maxendinghere = maxmac(maxendinghere, 0); maxsofar = maxmac(maxsofar, maxendinghere);&#125; return maxsofar;&#125;//第三种float maxfun(float a, float b)&#123; return a &gt; b ? a : b;&#125;float alg4c()&#123; int i; float maxsofar = 0, maxendinghere = 0; for (i = 0; i &lt; n; i++) &#123; maxendinghere += x[i]; maxendinghere = maxfun(maxendinghere, 0); maxsofar = maxfun(maxsofar, maxendinghere);&#125; return maxsofar;&#125; 实际运行时间对比 这篇文章是对老师上课内容的一次回顾]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>分治法</tag>
        <tag>扫描法</tag>
        <tag>时间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表基本操作二]]></title>
    <url>%2F2018%2F10%2F14%2F2018%2F2018-10-14-%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[三、链表实现代码与分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct Node &#123; char *SchoolNumber; char *Name; int Age; struct Node *Next;&#125;;typedef struct Node *Link;// 实现字符串信息转换成相应节点信息struct Node Str_Node(char *buffer) &#123; char *p[3]; char *temp; struct Node n; int i = 0; temp = strdup(strtok(buffer, &quot;,&quot;)); //字符串的分割 while(temp) &#123; p[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; n.SchoolNumber = p[0]; n.Name = p[1]; n.Age = atoi(p[2]); n.Next = NULL; return n;&#125;// 打印单个节点void Print(Link &amp;Head, int op_number)&#123; if(op_number == 0)&#123; printf(&quot;Error!\n&quot;); return ; &#125; Link p; p = Head; for(int i = 0; i &lt; op_number; i++)&#123; p = p-&gt;Next; &#125; printf(&quot;%-10d&quot;, op_number); printf(&quot;%-15x&quot;, p); printf(&quot;%-15s&quot;, p-&gt;SchoolNumber); printf(&quot;%-15s&quot;, p-&gt;Name); printf(&quot;%-15d\n&quot;, p-&gt;Age);&#125;//插入节点void InsertNode(Link &amp;Head, Node n, int &amp;NodeCount, int i)&#123; Link p; p = Head; for(int j = 0; j &lt; i-1; j++)&#123; p = p-&gt;Next; &#125; n.Next = p-&gt;Next; p-&gt;Next = &amp;n; NodeCount++;&#125;//删除节点void DeleteNode(Link &amp;Head, int &amp;NodeCount, int i)&#123; Link p, r; p = Head; for(int j = 0; j &lt; i; j++ ) &#123; r = p; p = p-&gt;Next; &#125; r-&gt;Next = p-&gt;Next; free(p); NodeCount--;&#125;// 主函数int main()&#123; FILE *fp; char buffer[100]; char operate[50]; int op_number; Link Head = (Link)malloc(sizeof(struct Node)); Head-&gt;Next = NULL; int NodeCount = 0; Link p = (Link)malloc(sizeof(struct Node)); p = Head; printf(&quot;Number PhysiAddr SchoolNumber Name Age\n&quot;); if((fp = fopen(&quot;Lab1test.DAT&quot;, &quot;rt&quot;)) != NULL) &#123; while(fgets(buffer, 99, fp) != NULL) &#123; Link temp = (Link)malloc(sizeof(struct Node)); *temp = Str_Node(buffer); p-&gt;Next = temp; p = p-&gt;Next; NodeCount++; &#125; fclose(fp); &#125; for(int i = 0; i &lt; NodeCount; i++) Print(Head, i+1); while(1)&#123; printf(&quot;Please enter Pi, Di or Ii(i&lt;%d):\n&quot;,NodeCount); scanf(&quot;%s&quot;,operate); if(operate[0] == &apos;0&apos;) break; if(operate[0] == &apos;P&apos;) &#123; op_number = atoi(operate + 1); Print(Head, op_number); &#125; else if(operate[0] == &apos;I&apos;)&#123; char *t[4]; char *temp; int i = 0; Node n; temp = strdup(strtok(operate, &quot;,&quot;)); while(temp)&#123; t[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; int number = atoi(operate + 1); n.SchoolNumber = t[1]; n.Name = t[2]; n.Age = atoi(t[3]); InsertNode(Head, n, NodeCount, number); for(int i = 0; i &lt; NodeCount; i++)&#123; Print(Head, i+1); &#125; &#125; else if(operate[0] == &apos;D&apos;) &#123; op_number = atoi(operate + 1); DeleteNode(Head, NodeCount, op_number); for(int i = 0; i &lt; NodeCount; i++)&#123; Print(Head, i+1); &#125; &#125; else printf(&quot;Error!\n&quot;); &#125; return 0;&#125; 四、所遇到的“坑” 在布局输出结果时，使用\t并不能解决，需要使用类似于”%-15x”的格式化输出搞定。 在打印节点时，老是从学号后面开始出现乱码，这种情况，要么是转化时出现问题，要么是创建链表时出问题。在103行，进行节点输出，发现没问题，那么就是转化出问题。将这部分进行单拎出来，用char buffer[] = “SA12345678,小明,22”测试，发现乱码，果然是这部分有问题。与顺序表的转化部分对比，发现一个返回结构体，一个返回结构体指针。以下是出错代码：123456789101112131415161718192021Link Str_Node(char *buffer) &#123; char *p[3]; char *temp; Link NewNode = (Link)malloc(sizeof(struct Node)); int i = 0; temp = strdup(strtok(buffer, &quot;,&quot;)); while(temp) &#123; p[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; NewNode-&gt;SchoolNumber = p[0]; NewNode-&gt;Name = p[1]; NewNode-&gt;Age = atoi(p[2]); NewNode-&gt;Next = NULL; return NewNode;&#125; 将其改为返回结构体得以解决。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表的操作一]]></title>
    <url>%2F2018%2F10%2F13%2F2018%2F2018-10-13-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Data Structure – Linear_list一、要求：&emsp;&emsp;首先，逐行读取指定文件中的数据，并进行解析后保存在顺序表中。其中，文件中每行数据格式为“学号,姓名,年龄”，比如“SA10225048,张三,24”。（提示：采用顺序表结构时，顺序表中每个表元素包含三类信息：学号，姓名，和年龄；采用单链表结构时，单链表中每个结点的数据域包含三类信息：学号，姓名，和年龄。）再根据键盘输入进行相关操作（查找，删除和插入）。比如，若键盘输入为“P3”，则表示打印出第3项的信息（注意：采用顺序表结构时，第3项数据对应下标为2的表元素；采用单链表结构时，第3项数据对应链表中第3个结点的信息；）；若键盘输入为“D3”，则表示删除第3个表元素；若键盘输入为“I3,SA10225038,张四,24”，则表示在第3项前插入一个学生的信息（SA10225038,张四,24）。 附件可以把以下数据复制到txt文档，然后改名为studentinfo.data。将这个文件和cpp文件放在同一个目录下。 SA10225048,张三,24SG10225132,李四,22连续子向量中的最大和SG10225027,王五,24SA10225213,赵六,25SA10225197,欧阳奋强,23SG10225059,孙八,24SA10225083,余久,23SA10225112,张唯一,24 二、顺序表实现代码与分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define maxn 100struct Node &#123; char *SchoolNumber; char *Name; int Age;&#125;ArrNode[maxn];// 实现字符串信息转换成相应节点信息struct Node Str_Node(char *buffer) &#123; char *p[3]; char *temp; struct Node n; int i = 0; temp = strdup(strtok(buffer, &quot;,&quot;)); while(temp) &#123; p[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; n.SchoolNumber = p[0]; n.Name = p[1]; n.Age = atoi(p[2]); return n;&#125;// 打印所有节点void Print(int NodeCount)&#123; for(int i = 0; i &lt; NodeCount; i++)&#123; printf(&quot;%-10d&quot;, i+1); printf(&quot;%-15x&quot;, ArrNode + i); printf(&quot;%-15s&quot;, ArrNode[i].SchoolNumber); printf(&quot;%-15s&quot;, ArrNode[i].Name); printf(&quot;%-15d\n&quot;, ArrNode[i].Age); &#125;&#125;// 插入节点void InsertNode(struct Node n, int &amp;NodeCount, int i)&#123; for(int j = NodeCount; j &gt;= i; j--)&#123; ArrNode[j].SchoolNumber = ArrNode[j-1].SchoolNumber; ArrNode[j].Name = ArrNode[j-1].Name; ArrNode[j].Age = ArrNode[j-1].Age; &#125; ArrNode[i-1].SchoolNumber = n.SchoolNumber; ArrNode[i-1].Name = n.Name; ArrNode[i-1].Age = n.Age; NodeCount++;&#125;// 删除节点void DeleteNode(int &amp;NodeCount, int i)&#123; for(int j = i; j &lt; NodeCount; j++)&#123; ArrNode[j - 1].SchoolNumber = ArrNode[j].SchoolNumber; ArrNode[j - 1].Name = ArrNode[j].Name; ArrNode[j - 1].Age = ArrNode[j].Age; &#125; NodeCount--;&#125;int main()&#123; FILE *fp; char buffer[100]; int NodeCount = 0; char operate[30]; int op_number; if((fp = fopen(&quot;studentinfo.data&quot;, &quot;rt&quot;)) != NULL) &#123; while(fgets(buffer, 99, fp) != NULL) &#123; ArrNode[NodeCount++] = Str_Node(buffer); &#125; fclose(fp); &#125; printf(&quot;Number PhysiAddr SchoolNumber Name Age\n&quot;); Print(NodeCount); while(1)&#123; printf(&quot;Please enter Pi, Di or Ii(i&lt;%d):\n&quot;,NodeCount); scanf(&quot;%s&quot;,operate); if(operate[0] == &apos;0&apos;) break; if(operate[0] == &apos;P&apos;) &#123; op_number = atoi(operate + 1); printf(&quot;%-10d&quot;, op_number); printf(&quot;%-15x&quot;, ArrNode + op_number - 1); printf(&quot;%-15s&quot;, ArrNode[op_number - 1].SchoolNumber); printf(&quot;%-15s&quot;, ArrNode[op_number - 1].Name); printf(&quot;%-15d\n&quot;, ArrNode[op_number - 1].Age); &#125; else if(operate[0] == &apos;I&apos;)&#123; char *t[4]; char *temp; int i = 0; struct Node n; temp = strdup(strtok(operate, &quot;,&quot;)); while(temp)&#123; t[i] = temp; temp = strdup(strtok(NULL, &quot;,&quot;)); i++; &#125; int number = atoi(operate + 1); n.SchoolNumber = t[1]; n.Name = t[2]; n.Age = atoi(t[3]); InsertNode(n, NodeCount, number); Print(NodeCount); &#125; else if(operate[0] == &apos;D&apos;) &#123; op_number = atoi(operate + 1); DeleteNode(NodeCount, op_number); Print(NodeCount); &#125; else printf(&quot;Error!\n&quot;); &#125; return 0;&#125; 使用的是顺序表结构来实现线性表的基本操作，明天采用链表结构来实现。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib学习]]></title>
    <url>%2F2018%2F10%2F06%2Fmatplotlib%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Matplotlib是一个Python 2D绘图库，它可以在各种平台上以各种硬拷贝格式和交互式环境生成出具有出版品质的图形。 Matplotlib可用于Python脚本，Python和IPython shell，Jupyter笔记本，Web应用程序服务器和四个图形用户界面工具包.matplotlib简单操作 一、折线图123456789101112131415161718In [1]:import matplotlib as mpl import matplotlib.pyplot as plt import numpy as np import mathIn [2]:x=np.linspace(-4, 4, 100)In [3]:y=np.sin(x) yy=np.cos(x)In [4]:plt.plot(x, y, color = &quot;red&quot;, linestyle=&quot;--&quot;, label=&quot;sin(x)&quot;) #linestyle有四种--,-. plt.plot(x, yy, color=&quot;pink&quot;, label=&quot;cos(x)&quot;) plt.plot() plt.xlabel(&quot;x axis&quot;) plt.ylabel(&quot;y axis&quot;) #plt.xlim(-math.pi, math.pi) #plt.ylim(-2, 2) plt.axis([-math.pi, math.pi, -2, 2]) plt.legend() plt.title(&quot;welcome to ML world!&quot;) plt.show() 二、散点图123In [5]:plt.scatter(x,y,color=&quot;green&quot;)Out[5]:&lt;matplotlib.collections.PathCollection at 0x1c7d2128400&gt; 1234In [6]:plt.scatter(x,y) plt.scatter(x,yy,color=&quot;red&quot;)Out[6]:&lt;matplotlib.collections.PathCollection at 0x1c7d21a0080&gt; 1234In [7]:x = np.random.normal(0, 1, 1000) y = np.random.normal(0, 1, 1000) plt.scatter(x, y, alpha = 0.5, color = &apos;g&apos;) plt.show() 1234In [8]:x = np.arange(-500, 500) y = np.random.normal(0, 1, 1000) plt.scatter(x, y) plt.show() 三、应用123456789101112131415161718192021222324252627282930313233In [9]:import numpy as np import matplotlib.pyplot as plt from sklearn import datasetsIn [10]:iris = datasets.load_iris()In [11]:iris.keys()In [12]:print(iris.DESCR)In [14]:iris.data.shapeOut[14]:(150, 4)In [15]:iris.targetOut[15]:array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])In [16]:iris.target_namesOut[16]:array([&apos;setosa&apos;, &apos;versicolor&apos;, &apos;virginica&apos;], dtype=&apos;&lt;U10&apos;)In [17]:X = iris.data[:, :2]In [18]:X.shapeOut[18]:(150, 2)In [19]:plt.scatter(X[:,0], X[:, 1])Out[19]:&lt;matplotlib.collections.PathCollection at 0x1c7d3d590f0&gt; 12345In [20]:y = iris.targetIn [21]:plt.scatter(X[y==0, 0], X[y==0, 1], color = &apos;g&apos;) plt.scatter(X[y==1, 0], X[y==1, 1], color = &apos;r&apos;) plt.scatter(X[y==2, 0], X[y==2, 1], color = &apos;y&apos;) plt.show() 12345In [22]:X = iris.data[:,2:]In [23]:plt.scatter(X[y==0, 0], X[y==0, 1], color = &apos;g&apos;) plt.scatter(X[y==1, 0], X[y==1, 1], color = &apos;r&apos;, marker = &apos;*&apos;) plt.scatter(X[y==2, 0], X[y==2, 1], color = &apos;y&apos;, marker = &apos;+&apos;) plt.show()]]></content>
      <categories>
        <category>Machine Leaning</category>
      </categories>
      <tags>
        <tag>plot</tag>
        <tag>scatter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy学习二]]></title>
    <url>%2F2018%2F10%2F06%2F2018%2F2018-10-06-numpy%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[八、矩阵运算 1234567891011121314151617181920212223242526272829303132In [103]:A = np.arange(4).reshape(2, 2) B = np.full((2, 2), 10) A, BOut[103]:(array([[0, 1], [2, 3]]), array([[10, 10], [10, 10]]))In [104]:A + BOut[104]:array([[10, 11], [12, 13]])In [105]:A - BOut[105]:array([[-10, -9], [ -8, -7]])In [106]:A * B #对应元素相乘Out[106]:array([[ 0, 10], [20, 30]])In [107]:A.dot(B) #矩阵乘法Out[107]:array([[10, 10], [50, 50]])In [108]:A.T#转置Out[108]:array([[0, 2], [1, 3]]) 九、向量和矩阵运算12345678910111213141516171819202122232425262728In [109]:v=np.array([1,2]) v + A # v向量分别与A矩阵每一行相加，实际上不合法Out[109]:array([[1, 3], [3, 5]])In [110]:np.vstack([v] * A.shape[0]) #将v落成A一样高，即同行数然后在与A相加可 实现上面要求Out[110]:array([[1, 2], [1, 2]])In [111]:np.tile(v, (2,1)) # 将v向量在行上堆叠两次，在列上堆叠一次Out[111]:array([[1, 2], [1, 2]])In [112]:v * A # v与A中每一行各元素对应相乘所得Out[112]:array([[0, 2], [2, 6]])In [113]:v.dot(A)Out[113]:array([4, 7])In [114]:A.dot(v) #由于v没有规定是行还是列向量，所以np会自动判断使其合理的方式运算Out[114]:array([2, 8]) 十、矩阵的逆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768In [115]:A = np.arange(24).reshape(4,6)In [116]:AOut[116]:array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17], [18, 19, 20, 21, 22, 23]])In [117]:B=np.arange(0,24).reshape(6,4)In [118]:z=A.dot(B) zOut[118]:array([[ 220, 235, 250, 265], [ 580, 631, 682, 733], [ 940, 1027, 1114, 1201], [1300, 1423, 1546, 1669]])In [119]:arr1=z%11 arr1Out[119]:array([[0, 4, 8, 1], [8, 4, 0, 7], [5, 4, 3, 2], [2, 4, 6, 8]], dtype=int32)In [120]:inv1=np.linalg.inv(arr1+1) #np.linalg中有逆的运算 inv1Out[120]:array([[ 1.68884986e+15, 1.68884986e+15, -2.25179981e+15, -1.12589991e+15], [-3.37769972e+15, -3.37769972e+15, 4.50359963e+15, 2.25179981e+15], [ 1.68884986e+15, 1.68884986e+15, -2.25179981e+15, -1.12589991e+15], [-1.36363636e-01, -4.54545455e-02, 0.00000000e+00, 1.81818182e-01]])In [121]:pinvx=np.linalg.pinv(A) #当A不是方阵时，A没有逆可以有伪逆In [122]:pinvxOut[122]:array([[-0.12619048, -0.06587302, -0.00555556, 0.0547619 ], [-0.07904762, -0.04063492, -0.00222222, 0.03619048], [-0.03190476, -0.01539683, 0.00111111, 0.01761905], [ 0.0152381 , 0.00984127, 0.00444444, -0.00095238], [ 0.06238095, 0.03507937, 0.00777778, -0.01952381], [ 0.10952381, 0.06031746, 0.01111111, -0.03809524]])In [123]:pinvx.shapeOut[123]:(6, 4)In [124]:A.dot(pinvx)Out[124]:array([[ 0.7, 0.4, 0.1, -0.2], [ 0.4, 0.3, 0.2, 0.1], [ 0.1, 0.2, 0.3, 0.4], [-0.2, 0.1, 0.4, 0.7]])In [125]:pinvx.dot(x)Out[125]:array([[ 0.34920635, 0.20634921, 0.06349206], [ 0.25396825, 0.16825397, 0.08253968], [ 0.15873016, 0.13015873, 0.1015873 ], [ 0.06349206, 0.09206349, 0.12063492], [-0.03174603, 0.05396825, 0.13968254], [-0.12698413, 0.01587302, 0.15873016]])In [126]:np.linalg.pinv? 十一、np中的聚合运算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899In [127]:L = np.random.random(100)In [128]:LOut[128]:array([0.29365293, 0.13349054, 0.72296127, 0.20339775, 0.79085149, 0.72289686, 0.34664717, 0.21922709, 0.2347296 , 0.10934288, 0.93987847, 0.54118002, 0.89582475, 0.88657711, 0.01363686, 0.86886947, 0.30145564, 0.94794894, 0.01607689, 0.97629271, 0.81439886, 0.31815539, 0.29844493, 0.41129176, 0.33999991, 0.95050074, 0.43841296, 0.30775838, 0.69076609, 0.09082456, 0.95063683, 0.83411245, 0.71913127, 0.72244065, 0.11435661, 0.48092918, 0.56755408, 0.30867441, 0.79659891, 0.88179918, 0.70385178, 0.95382592, 0.40178135, 0.52124991, 0.77764132, 0.01151922, 0.56330513, 0.49297281, 0.6472458 , 0.8703968 , 0.59602549, 0.3425843 , 0.32778162, 0.8072212 , 0.90542921, 0.64954137, 0.2699948 , 0.03288953, 0.04912259, 0.46259617, 0.16843821, 0.92318423, 0.56270712, 0.15915484, 0.35922195, 0.04674703, 0.39876266, 0.94110829, 0.76153611, 0.3938261 , 0.78600756, 0.33429112, 0.16921891, 0.67781051, 0.84572637, 0.38719376, 0.17431285, 0.56729794, 0.98401691, 0.52914654, 0.43819623, 0.91374443, 0.73249185, 0.14618544, 0.20060762, 0.42209825, 0.10296695, 0.6020364 , 0.24532492, 0.98187115, 0.08073652, 0.63580472, 0.11326209, 0.25617199, 0.32379328, 0.66696424, 0.81302027, 0.83596411, 0.32551382, 0.8484381 ])In [129]:sum(L)Out[129]:51.443603284608905In [130]:np.sum(L) #与前者时间不一样Out[130]:51.4436032846089In [131]:np.min(L)Out[131]:0.011519220430084354In [132]:np.max(L)Out[132]:0.9840169068335332In [133]:L.min() # 面对对象，还是np型都可以，不过后者包含的函数更全Out[133]:0.011519220430084354In [134]:X = np.arange(16).reshape(4, -1) XOut[134]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])In [135]:np.sum(X) #对应多维矩阵，sum为所有元素之和Out[135]:120In [136]:np.sum(X, axis = 1) #每一列元素相加之和Out[136]:array([ 6, 22, 38, 54])In [137]:np.prod(X + 1) #所有元素之积Out[137]:2004189184In [138]:np.prod(X, axis = 1) #沿着列相乘Out[138]:array([ 0, 840, 7920, 32760])In [139]:np.mean(X) #平均值Out[139]:7.5In [140]:np.median(X) #中位数，中间有两个就这两个数的平均值Out[140]:7.5In [141]:np.percentile(X,q=10) #百分位点，指有10%的数都小于等于1.5，当q=50表示中位数，q=100表示最大值，q = 0表示最小值Out[141]:1.5In [142]:np.percentile(X, q= 100)Out[142]:15.0In [143]:rad = np.random.random(100) for percent in [0, 25, 50, 100]: print(np.percentile(rad, q=percent))0.023267903753504850.26171186382127440.50112193791323390.998188987589012In [144]:np.var(rad) #求方差Out[144]:0.07112525170741578In [145]:np.std(rad) #标准差Out[145]:0.26669317896679656 十二、索引12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364In [146]:np.argmin(rad) #表示最小值所在的索引下标Out[146]:80In [147]:x = np.arange(16) xOut[147]:array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])In [158]:np.random.shuffle(x) #对x使用乱序化,x本身会改变 xOut[158]:array([10, 12, 3, 7, 4, 5, 6, 2, 9, 13, 14, 11, 0, 15, 8, 1])In [159]:np.sort(x) #x并不会改变Out[159]:array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])In [157]:x.sort() #x会改变 xOut[157]:array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])In [161]:X = np.random.randint(0,10,size=(4,4)) #在[0,10)之间随机生成4X4 的二维整型矩阵 XOut[161]:array([[6, 6, 4, 0], [3, 8, 2, 7], [7, 1, 1, 2], [0, 2, 1, 7]])In [163]:np.sort(X) #各行进行排序Out[163]:array([[0, 4, 6, 6], [2, 3, 7, 8], [1, 1, 2, 7], [0, 1, 2, 7]])In [165]:np.sort(X,axis = 0) #沿着行排序Out[165]:array([[0, 1, 1, 0], [3, 2, 1, 2], [6, 6, 2, 7], [7, 8, 4, 7]])In [167]:np.argsort(X) #排序的索引Out[167]:array([[3, 2, 0, 1], [2, 0, 3, 1], [1, 2, 3, 0], [0, 2, 1, 3]], dtype=int64)In [168]:xOut[168]:array([10, 12, 3, 7, 4, 5, 6, 2, 9, 13, 14, 11, 0, 15, 8, 1])In [169]:np.partition(x, 3) #使3前面都比3小，后面都比3大Out[169]:array([ 0, 1, 2, 3, 4, 5, 7, 8, 9, 6, 10, 11, 14, 15, 12, 13])In [170]:np.argpartition(x,3) #返回其索引Out[170]:array([12, 15, 7, 2, 4, 5, 3, 14, 8, 6, 0, 11, 10, 13, 1, 9], dtype=int64) 十三、Fancy Indexing123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111In [171]:x = np.arange(16)In [172]:ind = [3, 5, 8]In [173]:x[ind] #将索引放进数组，然后进行访问Out[173]:array([3, 5, 8])In [174]:ind = np.array([[2, 4, 1], [0, 10, 3]])In [175]:x[ind] # 根据索引来返回相应的值Out[175]:array([[ 2, 4, 1], [ 0, 10, 3]])In [176]:X = x.reshape(4, -1) XOut[176]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])In [177]:row = np.array([0, 1, 2]) col = np.array([1, 2, 3])In [178]:X[row,col] #根据row，col所得交集来访问Out[178]:array([ 1, 6, 11])In [179]:X[:2,col]Out[179]:array([[1, 2, 3], [5, 6, 7]])In [180]:X&lt;5 #返回bool值Out[180]:array([[ True, True, True, True], [ True, False, False, False], [False, False, False, False], [False, False, False, False]])In [184]:3 * X== 4*X-1 #返回满足改条件的值的真假Out[184]:array([[False, True, False, False], [False, False, False, False], [False, False, False, False], [False, False, False, False]])In [186]:xOut[186]:array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])In [187]:np.sum(x &lt;= 3) #返回x中小于等于3的个数Out[187]:4In [188]:np.any(x &lt;=3 ) #返回x中是否有小于等于3的数Out[188]:TrueIn [189]:np.count_nonzero(x &lt;= 3) #表示x&lt;=3这个bool数组中有多少个非零元素（false为0，true为1）Out[189]:4In [190]:np.all(x&gt;=0) #all判断x&gt;=0这个bool数组中是不是都大于0Out[190]:TrueIn [192]:np.all(x)Out[192]:FalseIn [193]:np.sum((x&gt;3) &amp; (x&lt;7)) # &amp;为和不能用and, 因为这两边都是数组，要求的是两个数组中的交集而不是一个值Out[193]:3In [195]:np.sum((x&gt;3) | (x&lt;7))Out[195]:16In [196]:np.sum(~(x==3))Out[196]:15​In [149]:arr4 = np.arange(10).reshape(2,5) arr4Out[149]:array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])In [150]:ind = [True ,False, True, False,True]In [151]:arr4[:,ind]Out[151]:array([[0, 2, 4], [5, 7, 9]])In [152]:np.any(arr4&gt;2)Out[152]:TrueIn [153]:np.all(arr4&lt;=1)Out[153]:FalseIn [154]:np.sum(arr4&gt;3)Out[154]:6In [155]:import numpy as np arr4 = np.arange(0,10).reshape(2,5) np.sum(arr4[:,0])Out[155]:5]]></content>
      <categories>
        <category>Machine Leaning</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy学习一]]></title>
    <url>%2F2018%2F10%2F06%2F2018%2F2018-10-06-numpy%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本期将会涉及到Python模块中的numpy，这是一个处理数组的强大模块，而该模块也是其他数据分析模块（如pandas和scipy）的核心。 一、数组的创建 np.array(list,tuple,array类型) np.arange,一维数组中的range ones,ones_like,zeros,zeros_like,empty,empty_like eye,identity #单位矩阵 full #全为指定数矩阵 linspace(0,20,10)In:1234567arr1 = np.array(range(10)).reshape(2,5)arr2 = np.arange(10).reshape(2,5)arr3 = np.ones((2,5))arr4 = np.zeros_like(arr1)arr5 = np.eye(5)arr6 = np.full((2, 5), 3)np.linspace(0,20,10) #在0 和 20 包括0,20等长的截取10个点 Out:123456789101112131415161718192021222324252627282930313233343536arr1Out[5]:array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])arr2Out[6]:array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])arr3Out[7]:array([[1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.]])arr4Out[8]:array([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]])arr5Out[9]:array([[1., 0., 0., 0., 0.], [0., 1., 0., 0., 0.], [0., 0., 1., 0., 0.], [0., 0., 0., 1., 0.], [0., 0., 0., 0., 1.]])arr6Out[10]:array([[3, 3, 3, 3, 3], [3, 3, 3, 3, 3]])Out[11]:array([ 0. , 2.22222222, 4.44444444, 6.66666667, 8.88888889, 11.11111111, 13.33333333, 15.55555556, 17.77777778, 20. ]) 二、数组的基本操作123456789101112131415161718192021In[25]:arr1Out[25]:array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])In [26]:arr2Out[26]:array([ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19])In [28]:arr3=arr2.reshape(2,5) #reshape 改变类型In [29]:arr3.shape#不该变arr3自身Out[29]:(2, 5)In [30]:arr3.size #元素个数Out[30]:10In [31]:arr3.ndim #元素维度Out[31]:2 三、矩阵元素访问123456789101112131415161718192021222324252627282930313233343536373839In [32]:arr3[:]Out[32]:array([[ 1, 3, 5, 7, 9], [11, 13, 15, 17, 19]])In [33]:arr3[1,3] #arr3[1,3]和arr3[1][3]一样但是推荐使用前者Out[33]:17In [34]:x = np.array(range(12)).reshape(3, 4) xOut[34]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])In [35]:x[::-1,::-1] #步长为-1表示从后往前数Out[35]:array([[11, 10, 9, 8], [ 7, 6, 5, 4], [ 3, 2, 1, 0]])In [36]:subx=x[:2,:3] #切片访问 subx改变值不会改变arr3值 subxOut[36]:array([[0, 1, 2], [4, 5, 6]])In [37]:subx=x[:2,2:] subxOut[37]:array([[2, 3], [6, 7]])In [38]:subx[0,1]=100In [39]:print(arr3)#改变arr3中子矩阵，arr3也会改变，是引用方式Out[39]:[[ 1 3 5 7 9] [11 13 15 17 19]] 四、合并操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061In [40]:x=np.array([1,2,3]) y=np.array([3,1,2])In [41]:np.concatenate([x,y])Out[41]:array([1, 2, 3, 3, 1, 2])In [42]:np.concatenate([x,y],axis=0)Out[42]:array([1, 2, 3, 3, 1, 2])In [43]:A = np.array([[1,2,3], [4,5,6]])In [44]:np.concatenate([A,A]) #默认垂直合并 concatenate只能处理同类型矩阵Out[44]:array([[1, 2, 3], [4, 5, 6], [1, 2, 3], [4, 5, 6]])In [45]:np.concatenate([A,A],axis = 1)Out[45]:array([[1, 2, 3, 1, 2, 3], [4, 5, 6, 4, 5, 6]])In [46]:z = np.array([666,666,666])In [47]:np.concatenate([A, z.reshape(1,-1)]) #针对concatenate只能同类型矩阵，可以用（1，-1）表示一行，列数随机的方法Out[47]:array([[ 1, 2, 3], [ 4, 5, 6], [666, 666, 666]])In [48]:np.vstack([A,z])#垂直堆叠合并Out[48]:array([[ 1, 2, 3], [ 4, 5, 6], [666, 666, 666]])In [49]:B = np.full((2,2),100) BOut[49]:array([[100, 100], [100, 100]])In [50]:arr4 = np.array(range(12)).reshape(3,4)In [51]:print(arr4)Out[51]:[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]]In [52]:np.hstack([arr4,arr4]) #水平堆叠合并Out[52]:array([[ 0, 1, 2, 3, 0, 1, 2, 3], [ 4, 5, 6, 7, 4, 5, 6, 7], [ 8, 9, 10, 11, 8, 9, 10, 11]])In [53]:np.hstack([arr4,arr4])Out[53]:array([[ 0, 1, 2, 3, 0, 1, 2, 3], [ 4, 5, 6, 7, 4, 5, 6, 7], [ 8, 9, 10, 11, 8, 9, 10, 11]]) 五、分割 split12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485In [54]:arr5=np.array(range(10))In [55]:x1,x2,x3=np.split(arr5,[3,7])#arr5 分割矩阵，【3,7】为分割点列表In [56]:print(x1)Out[56]:[0 1 2]In [57]:x2Out[57]:array([3, 4, 5, 6])In [58]:x3Out[58]:array([7, 8, 9])In [59]:x1,x2 = np.split(arr5,[5]) x1,x2Out[59]:(array([0, 1, 2, 3, 4]), array([5, 6, 7, 8, 9]))In [60]:arr6=np.array(range(16)).reshape(4,4) arr6Out[60]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])In [61]:a1,a2 = np.split(arr6, [2]) #当arr6为二维数组时，【2】表示前两行为分割处 a1Out[61]:array([[0, 1, 2, 3], [4, 5, 6, 7]])In [62]:a2Out[62]:array([[ 8, 9, 10, 11], [12, 13, 14, 15]])In [63]:A1,A2 = np.split(arr6, [2], axis = 1) #axis=1 表示列分割 A1,A2Out[63]:(array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]]), array([[ 2, 3], [ 6, 7], [10, 11], [14, 15]]))In [64]:up,down =np.vsplit(arr6,[-1]) #垂直切割，表示分成上下部分In [65]:up,downOut[65]:(array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]), array([[12, 13, 14, 15]]))In [66]:left,right = np.hsplit(arr6,[2]) #水平切割，表示分成左右部分 left,rightOut[66]:(array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]]), array([[ 2, 3], [ 6, 7], [10, 11], [14, 15]]))In [67]:data = np.arange(16).reshape(4,4) dataOut[67]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])In [82]:x,y = np.hsplit(data,[-1]) # data表示数据集，前三个为特征，后一个为标签，这样切割为x，y x,yOut[82]:(array([[ 0, 1, 2], [ 4, 5, 6], [ 8, 9, 10], [12, 13, 14]]), array([[ 3], [ 7], [11], [15]])) 六、矩阵的标量运算12345678910111213141516171819In [83]:%%timeit #计算单元格内运算时间 n = 10 A = [i for i in range(n)] A858 ns ± 7.77 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)In [84]:%%timeit n = 10 B = [] for i in range(n): B.append(i) B1.51 µs ± 85.2 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)In [85]:%%timeit n = 10 A = np.arange(n) A881 ns ± 93.5 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) 七、Universal Function123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687In [87]:A = [i for i in range(10)] AOut[87]:[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]In [88]:arrA = np.array(A).reshape(2, 5)In [89]:arrA * 2Out[89]:array([[ 0, 2, 4, 6, 8], [10, 12, 14, 16, 18]])In [90]:arrA - 1Out[90]:array([[-1, 0, 1, 2, 3], [ 4, 5, 6, 7, 8]])In [91]:arrA/2Out[91]:array([[0. , 0.5, 1. , 1.5, 2. ], [2.5, 3. , 3.5, 4. , 4.5]])In [92]:arrA **2Out[92]:array([[ 0, 1, 4, 9, 16], [25, 36, 49, 64, 81]], dtype=int32)In [93]:arrA //2 #整除Out[93]:array([[0, 0, 1, 1, 2], [2, 3, 3, 4, 4]], dtype=int32)In [94]:np.abs(arrA-4)Out[94]:array([[4, 3, 2, 1, 0], [1, 2, 3, 4, 5]])In [95]:np.sin(arrA)Out[95]:array([[ 0. , 0.84147098, 0.90929743, 0.14112001, -0.7568025 ], [-0.95892427, -0.2794155 , 0.6569866 , 0.98935825, 0.41211849]])In [96]:np.arcsin(arrA)C:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: invalid value encountered in arcsin &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[96]:array([[0. , 1.57079633, nan, nan, nan], [ nan, nan, nan, nan, nan]])In [97]:np.power(arrA,3)Out[97]:array([[ 0, 1, 8, 27, 64], [125, 216, 343, 512, 729]], dtype=int32)In [98]:1/arrAC:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in true_divide &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[98]:array([[ inf, 1. , 0.5 , 0.33333333, 0.25 ], [0.2 , 0.16666667, 0.14285714, 0.125 , 0.11111111]])In [99]:np.exp(arrA)Out[99]:array([[1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01, 5.45981500e+01], [1.48413159e+02, 4.03428793e+02, 1.09663316e+03, 2.98095799e+03, 8.10308393e+03]])In [100]:np.log2(arrA)C:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in log2 &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[100]:array([[ -inf, 0. , 1. , 1.5849625 , 2. ], [2.32192809, 2.5849625 , 2.80735492, 3. , 3.169925 ]])In [101]:np.log10(arrA)C:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in log10 &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[101]:array([[ -inf, 0. , 0.30103 , 0.47712125, 0.60205999], [0.69897 , 0.77815125, 0.84509804, 0.90308999, 0.95424251]])In [102]:np.log(arrA) #log默认为eC:\program123\Anaconda\lib\site-packages\ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in log &quot;&quot;&quot;Entry point for launching an IPython kernel.Out[102]:array([[ -inf, 0. , 0.69314718, 1.09861229, 1.38629436], [1.60943791, 1.79175947, 1.94591015, 2.07944154, 2.19722458]])]]></content>
      <categories>
        <category>Machine Leaning</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令一]]></title>
    <url>%2F2018%2F10%2F03%2F2018%2F2018-10-03-linux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux命令格式: command [-options] [parameter1] … 说明：command: 命令名,相应功能的英文单词或单词的缩写 [-options]：选项,可用来对命令进行控制，也可以省略，[]代表可选 parameter1 …：传给命令的参数：可以是零个一个或多个 一、基本技能 在linux终端时：Ctrl Shift + 三个键字体扩大，Ctrl - 字体缩小 自动补全：在敲出命令的前几个字母的同时，按下tab键，系统会自动帮我们补全命令 历史命令：当系统执行过一些命令后，可按上下键翻看以前的命令，history将执行过的命令列举出来 多个命令同时使用用 ; ，不建议使用 Ctrl c 终止命令 几个目录符号含义： ~ 用户目录 / 根目录 . 当前路径 .. 上一路径 -回看 清屏：clear 显示当前路径：pwd（不带参数） 二、文件、磁盘管理 查看文件信息：ls 参数 含义 -a 显示指定目录下所有子目录与文件，包括隐藏文件 -l 以列表方式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 输出重定向命令：&gt;Linux允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。如：ls &gt; test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 ) 注意：&gt;输出重定向会覆盖原来的内容，&gt;&gt;输出重定向则会追加到文件的尾部。 分屏显示：more查看内容时，在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用more命令，每次只显示一页，按下空格键可以显示下一页，按下q键退出显示，按下h键可以获取帮助 管道：|管道：一个命令的输出可以通过管道做为另一个命令的输入。管道我们可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里“ | ”的左右分为两端，左端塞东西(写)，右端取东西(读)。 切换工作目录： cd在使用Unix/Linux的时候，经常需要更换工作目录。cd命令可以帮助用户切换工作目录。Linux所有的目录和文件名大小写敏感cd后面可跟绝对路径，也可以跟相对路径。如果省略目录，则默认切换到当前用户的主目录。例如：cd / 到根目录 目录操作： 创建目录：mkdir通过mkdir命令可以创建一个新的目录。参数-p可递归创建目录。需要注意的是新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写权限。 删除目录：rmdir可使用rmdir命令删除一个目录。必须离开目录，并且目录必须为空目录，不然提示删除失败。 删除文件：rm可通过rm删除文件或目录。使用rm命令要小心，因为文件删除后不能恢复。为了防止文件误删，可以在rm后使用-i参数以逐个确认要删除的文件。 参数 含义 -i 以进行交互式方式执行 -f 强制删除，忽略不存在的文件，无需提示 -r 递归地删除目录下的内容，删除文件夹时必须加此参数 建立链接文件：lnLinux链接文件类似于Windows下的快捷方式。链接文件分为软链接和硬链接。软链接：软链接不占用磁盘空间，源文件删除则软链接失效。硬链接：硬链接只能链接普通文件，不能链接目录。使用格式： ln 源文件 链接文件ln -s 源文件 链接文件 如果没有-s选项代表建立一个硬链接文件，两个文件占用相同大小的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s选项是更常见的形式。 注意：如果软链接文件和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径。 查看或者合并文件内容：cat 文本搜索：grepLinux系统中grep命令是一种强大的文本搜索工具，grep允许对文本文件进行模式查找。如果找到匹配模式， grep打印包含模式的所有行。 grep一般格式为： grep [-选项] ‘搜索内容串’文件名 在grep命令中输入字符串参数时，最好引号或双引号括起来。例如：grep‘a ’1.txt。 常用选项说明： 选项 含义 -v 显示不包含匹配文本的所有行（相当于求反） -n 显示匹配行及行号 -i 忽略大小写 grep搜索内容串可以是正则表达式。 &emsp;&emsp;正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 grep常用正则表达式： 参数 含义 ^a 行首,搜寻以 m 开头的行；grep -n ‘^a’ 1.txt ke$ 行尾,搜寻以 ke 结束的行；grep -n ‘ke$’ 1.txt [Ss]igna[Ll] 匹配 [] 里中一系列字符中的一个；搜寻匹配单词signal、signaL、Signal、SignaL的行；grep -n ‘[Ss]igna[Ll]’ 1.txt . (点)匹配一个非换行符的字符；匹配 e 和 e 之间有任意一个字符，可以匹配 eee，eae，eve，但是不匹配 ee，eaae；grep -n ‘e.e’ 1.txt 查找文件：findfind命令功能非常强大，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。 常用用法： 命令 含义 find ./ -name test.sh 查找当前目录下所有名为test.sh的文件 find ./ -name ‘*.sh’ 查找当前目录下所有后缀为.sh的文件 find ./ -name “[A-Z]*” 查找当前目录下所有以大写字母开头的文件 find /tmp -size 2M 查找在/tmp 目录下等于2M的文件 find /tmp -size +2M 查找在/tmp 目录下大于2M的文件 find /tmp -size -2M 查找在/tmp 目录下小于2M的文件 find ./ -size +4k -size -5M 查找当前目录下大于4k，小于5M的文件 find ./ -perm 777 查找当前目录下权限为 777 的文件或目录 拷贝文件：cpcp命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS下的copy命令。 常用选项说明： 选项 含义 -a 该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。 -f 已经存在的目标文件而不提示 -i 交互式复制，在覆盖目标文件之前将给出提示要求用户确认 -r 若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。 -v 显示拷贝进度 移动文件：mv用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名。 常用选项说明： 选项 含义 -f 禁止交互式操作，如有覆盖也不会给出提示 -i 确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问是否重写，要求用户回答以避免误覆盖文件 -v 显示移动进度 归档管理：tar计算机中的数据经常需要备份，tar是Unix/Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。 tar使用格式 tar [参数] 打包文件名 文件 tar命令很特殊，其参数前面可以使用“-”，也可以不使用。 常用参数： 参数 含义 -c 生成档案文件，创建打包文件 -v 列出归档解档的详细过程，显示进度 -f 指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后 -t 列出档案中包含的文件 -x 解开档案文件 注意：除了f需要放在参数的最后，其它参数的顺序任意。 文件压缩解压：gziptar与gzip命令结合使用实现文件打包、压缩。 tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz。 gzip使用格式如下： gzip [选项] 被压缩文件 常用选项： 选项 含义 -d 解压 -r 压缩所有子目录 tar这个命令并没有压缩的功能，它只是一个打包的命令，但是在tar命令中增加一个选项(-z)可以调用gzip实现了一个压缩的功能，实行一个先打包后压缩的过程。 压缩用法：tar cvzf 压缩包包名 文件1 文件2 ... -z ：指定压缩包的格式为：file.tar.gz 解压用法： tar zxvf 压缩包包名 -z:指定压缩包的格式为：file.tar.gz 解压到指定目录：-C （大写字母“C”） 文件压缩解压：bzip2tar与bzip2命令结合使用实现文件打包、压缩(用法和gzip一样)。 tar只负责打包文件，但不压缩，用bzip2压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz2。 在tar命令中增加一个选项(-j)可以调用bzip2实现了一个压缩的功能，实行一个先打包后压缩的过程。 压缩用法：tar -jcvf 压缩包包名 文件...(tar jcvf bk.tar.bz2 *.c) 解压用法：tar -jxvf 压缩包包名 (tar jxvf bk.tar.bz2) 文件压缩解压：zip、unzip通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。 压缩文件：zip [-r] 目标文件(没有扩展名) 源文件 解压文件：unzip -d 解压后目录文件 压缩文件 查看命令位置：which例如：which ls]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise4]]></title>
    <url>%2F2018%2F10%2F03%2FExercise4%2F</url>
    <content type="text"><![CDATA[python项目之2048小游戏&emsp;&emsp;2048是一个非常简单的小游戏，对于刚学python的萌新来说，用来练练手也是非常不错的选择。下面利用python自带的tkinter来实现2048的界面设计。 一、总体框架设计 首先设计大的窗口，然后是4x4小格子 然后在下面显示分数，上下左右，重置，退出。通过鼠标点击来实现操作12345678910111213141516171819202122232425262728# 大窗口window=tk.Tk()window.title(&apos;2048&apos;)window.geometry(&apos;330x560&apos;) # 绘制初始的界面lab = &#123;&#125;Ox, Oy = 10, 10for i in range(4): for j in range(4): tlx=Ox+j*80 tly=Oy+i*80 num = i * 4 + j key = str(board[i][j]) # height，width值按字符来设置 l = tk.Label(window, text=board[i][j], bg=color[key], font=(&apos;Arial&apos;, 20), height=2, width=4) lab[num] = l l.place(x=tlx,y=tly)# 下面的控制，分数显示窗口，分数用数组中最大值表示tk.Label(window,text=&apos;分数:&apos;,bg=&apos;gray96&apos;,font=(&apos;微软雅黑&apos;,15)).place(x=10,y=330)tk.Label(window, textvariable=va, bg=&apos;gray96&apos;, font=(&apos;微软雅黑&apos;, 15)).place(x=70, y=330)tk.Button(window, text=&apos;上&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=up_op).place(x=130, y=360)tk.Button(window, text=&apos;下&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=down_op).place(x=130, y=465)tk.Button(window, text=&apos;左&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=left_op).place(x=55, y=410)tk.Button(window, text=&apos;右&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=right_op).place(x=205, y=410)tk.Button(window, text=&apos;重置&apos;, bg=&apos;gray86&apos;, font=(&apos;微软雅黑&apos;, 15), width=4, height=1, command=restart_op).place(x=20,y=510)tk.Button(window, text=&apos;退出&apos;, bg=&apos;gray86&apos;, font=(&apos;微软雅黑&apos;, 15), width=4, height=1, command=exit_op).place(x=245,y=510) 二、功能具体实现 初始化操作：随机在数组中找两个位置，然后各随机分配2或4,2概率为75%，initi之前应该将数组清零。 状态机：初始化后游戏进入game状态，然后游戏可能进入win，gameover这两种状态，还可以人为的重置退出。而在win，gameover状态也可以人为的重置退出。那怎样判断win，gameover呢？当分数值为2048时进入win状态，当数组中非零个数为16且没有两个相同数字相邻时进入gameover状态代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243def is_same_neibor(a): for i in range(4): for j in range(4): if i &lt; 3 and j &lt; 3: if a[i][j] == a[i][j+1] or a[i][j] == a[i+1][j]: return True elif i == 3 and j &lt; 3: if a[i][j] == a[i][j+1]: return True elif j == 3 and i &lt; 3: if a[i][j] == a[i+1][j]: return True return False def judge_state(a): # 判定数组此时状态，max_num记录数组中最大值且为当前分值 count = update(a) max_num=np.max(a) va.set(max_num) if max_num == 2048: round_over=True var1 = tk.messagebox.askyesno(title=&apos;闯关成功！&apos;, message=&apos;你想再来一次吗？&apos;) if var1: for i in range(4): for j in range(4): a[i][j]=0 initi(a) round_over=False update(a) else: window.destroy() if count == 16 and is_same_neibor(a) == False: round_over=True var2 = tk.messagebox.askyesno(title=&apos;闯关失败！&apos;, message=&apos; Game Over!\n你想再试一次吗？&apos;) if var2: for i in range(4): for j in range(4): a[i][j]=0 initi(a) round_over=False update(a) else: window.destroy() 六种运算操作： 向左移动且合并 向右移动且合并 向上移动且合并 向下移动且合并 重置 退出以向左移动且合并为例，向右移动且合并可以根据向左操作模仿操作，向上向下可通过转置和向左来实现1234567891011121314151617 def left_move(a): # 将非零数字左移 k = 0 for i in range(4): if a[i] != 0: a[k] = a[i] k += 1 if k &lt; 4: for j in range(k, 4): a[j] = 0def left_add(a): #将非零相同数字左合并 for i in range(3): if a[i] == a[i + 1]: a[i] = a[i] * 2 if i + 1 &lt; 3: for k in range(i + 1, 3): a[k] = a[k + 1] a[3] = 0 重置和退出： 123456789def restart_op(): for i in range(4): for j in range(4): board[i][j] = 0 initi(board) update(board)def exit_op(): window.destroy() game状态随机数产生和产生时机 123456789101112131415 def compare(a,b): # 数组移动前后比较，若不同则产生随机数，否则不产生 n_equal=False for i in range(4): for j in range(4): if a[i][j]!=b[i][j]: n_equal=True break return n_equaldef produce_rand(a): #在随机为零的位置随机产生一个数 p = random.randint(0, 3) q = random.randint(0, 3) while (board[p][q] != 0): p = random.randint(0, 3) q = random.randint(0, 3) board[p][q] = random.choice([2, 2, 2, 4]) 移动后更新： 12345678910def update(a): #更新，统计数组中非零元素个数且返回，用于后面判断数组状态。并更新颜色 count = 0 for i in range(4): for j in range(4): if a[i][j]: count += 1 num = i * 4 + j c_key = str(a[i][j]) lab[num].config(text=a[i][j], bg=color[c_key]) return count 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229from tkinter import messageboximport tkinter as tkimport numpy as npimport randomdef main(): # 初始化，创造一个窗口，显示title，窗口大小 window=tk.Tk() window.title(&apos;2048&apos;) window.geometry(&apos;330x560&apos;) # 不同的分数不同的颜色 round_over=False color = &#123;&apos;0&apos;: &apos;gray86&apos;, &apos;2&apos;: &apos;green1&apos;, &apos;4&apos;: &apos;cyan&apos;, &apos;8&apos;: &apos;blue1&apos;, &apos;16&apos;: &apos;pink4&apos;, &apos;32&apos;: &apos;yellow1&apos;, &apos;64&apos;: &apos;yellow4&apos;, &apos;128&apos;: &apos;pink&apos;,&apos;256&apos;: &apos;green4&apos;, &apos;512&apos;: &apos;yellow4&apos;, &apos;1024&apos;: &apos;orange4&apos;, &apos;2048&apos;: &apos;red&apos;&#125; # 初始化，随机在数组中找两个位置，然后各随机分配2或4,2概率为75%，initi之前应该将数组清零。 def initi(a): m1 = random.randint(0, 3) #从0到3之间产生一个随机整数（包含端点） n1 = random.randint(0, 3) m2 = random.randint(0, 3) n2 = random.randint(0, 3) while ((m1 == m2) and (n1 == n2)): m2 = random.randint(0, 3) n2 = random.randint(0, 3) a[m1][n1] = random.choice([2, 2, 2, 4]) #从列表中随机选中一个数 a[m2][n2] = random.choice([2, 2, 2, 4]) # 创建原始数组 board = np.zeros((4, 4), dtype=np.int16) initi(board) # 绘制初始的界面 lab = &#123;&#125; Ox, Oy = 10, 10 for i in range(4): for j in range(4): tlx=Ox+j*80 tly=Oy+i*80 num = i * 4 + j key = str(board[i][j]) # height，width值按字符来设置 l = tk.Label(window, text=board[i][j], bg=color[key], font=(&apos;Arial&apos;, 20), height=2, width=4) lab[num] = l l.place(x=tlx,y=tly) # 定义各种操作函数 def left_move(a): # 将非零数字左移 k = 0 for i in range(4): if a[i] != 0: a[k] = a[i] k += 1 if k &lt; 4: for j in range(k, 4): a[j] = 0 def right_move(a): k = 3 for i in range(4): if a[3 - i] != 0: a[k] = a[3 - i] k -= 1 if k &gt; 0: for j in range(0, k + 1): a[j] = 0 def left_add(a): #将非零相同数字左合并 for i in range(3): if a[i] == a[i + 1]: a[i] = a[i] * 2 if i + 1 &lt; 3: for k in range(i + 1, 3): a[k] = a[k + 1] a[3] = 0 def right_add(a): for i in range(3): if a[3 - i] == a[2 - i]: a[3 - i] = a[3 - i] * 2 if 2 - i &gt; 0: for k in range(1, 3 - i): a[3 - i - k] = a[2 - i - k] a[0] = 0 def produce_rand(a): #在随机为零的位置随机产生一个数 p = random.randint(0, 3) q = random.randint(0, 3) while (board[p][q] != 0): p = random.randint(0, 3) q = random.randint(0, 3) board[p][q] = random.choice([2, 2, 2, 4]) def update(a): #更新，统计数组中非零元素个数且返回，用于后面判断数组状态。并更新颜色 count = 0 for i in range(4): for j in range(4): if a[i][j]: count += 1 num = i * 4 + j c_key = str(a[i][j]) lab[num].config(text=a[i][j], bg=color[c_key]) return count def is_same_neibor(a): for i in range(4): for j in range(4): if i &lt; 3 and j &lt; 3: if a[i][j] == a[i][j+1] or a[i][j] == a[i+1][j]: return True elif i == 3 and j &lt; 3: if a[i][j] == a[i][j+1]: return True elif j == 3 and i &lt; 3: if a[i][j] == a[i+1][j]: return True return False def judge_state(a): # 判定数组此时状态，max_num记录数组中最大值且为当前分值 count = update(a) max_num=np.max(a) va.set(max_num) if max_num == 2048: round_over=True var1 = tk.messagebox.askyesno(title=&apos;闯关成功！&apos;, message=&apos;你想再来一次吗？&apos;) if var1: for i in range(4): for j in range(4): a[i][j]=0 initi(a) round_over=False update(a) else: window.destroy() if count == 16 and is_same_neibor(a) == False: round_over=True var2 = tk.messagebox.askyesno(title=&apos;闯关失败！&apos;, message=&apos; Game Over!\n你想再试一次吗？&apos;) if var2: for i in range(4): for j in range(4): a[i][j]=0 initi(a) round_over=False update(a) else: window.destroy() def compare(a,b): n_equal=False for i in range(4): for j in range(4): if a[i][j]!=b[i][j]: n_equal=True break return n_equal # 进行运算操作 def up_op(): ob=board.copy() tb = board.T for i in range(4): left_move(tb[i]) left_add(tb[i]) m = tb.T for i in range(4): for j in range(4): board[i][j] = m[i][j] if compare(ob,board): produce_rand(board) judge_state(board) def down_op(): ob = board.copy() tb = board.T for i in range(4): right_move(tb[i]) right_add(tb[i]) m = tb.T for i in range(4): for j in range(4): board[i][j] = m[i][j] if compare(ob, board): produce_rand(board) judge_state(board) def left_op(): ob = board.copy() for i in range(4): left_move(board[i]) left_add(board[i]) if compare(ob, board): produce_rand(board) judge_state(board) def right_op(): ob = board.copy() for i in range(4): right_move(board[i]) right_add(board[i]) if compare(ob, board): produce_rand(board) judge_state(board) def restart_op(): for i in range(4): for j in range(4): board[i][j] = 0 initi(board) update(board) def exit_op(): window.destroy() # 创建按钮和标签 va=tk.StringVar() va.set(0) tk.Label(window,text=&apos;分数:&apos;,bg=&apos;gray96&apos;,font=(&apos;微软雅黑&apos;,15)).place(x=10,y=330) tk.Label(window, textvariable=va, bg=&apos;gray96&apos;, font=(&apos;微软雅黑&apos;, 15)).place(x=70, y=330) tk.Button(window, text=&apos;上&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=up_op).place(x=130, y=360) tk.Button(window, text=&apos;下&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=down_op).place(x=130, y=465) tk.Button(window, text=&apos;左&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=left_op).place(x=55, y=410) tk.Button(window, text=&apos;右&apos;, bg=&apos;gray80&apos;, font=(&apos;微软雅黑&apos;,15),width=4, height=1, command=right_op).place(x=205, y=410) tk.Button(window, text=&apos;重置&apos;, bg=&apos;gray86&apos;, font=(&apos;微软雅黑&apos;, 15), width=4, height=1, command=restart_op).place(x=20,y=510) tk.Button(window, text=&apos;退出&apos;, bg=&apos;gray86&apos;, font=(&apos;微软雅黑&apos;, 15), width=4, height=1, command=exit_op).place(x=245,y=510) window.mainloop()if __name__==&apos;__main__&apos;: main() 相关链接 http://python.jobbole.com/84971/ https://www.shiyanlou.com/courses/reports/1283118 https://blog.csdn.net/qq_39451109/article/details/78161438 https://blog.csdn.net/yjy_aii/article/details/78071955]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>tkinter</tag>
        <tag>2048</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise_3_飞机大战]]></title>
    <url>%2F2018%2F09%2F26%2F2018%2F2018-09-25-%E7%AC%AC%E4%B8%89%E4%B8%AApython%E9%A1%B9%E7%9B%AE-%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一个小练习，飞机大战，主要有四个类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227import pygamefrom pygame.locals import *import randomimport time&apos;&apos;&apos;说明爆炸效果的原理是:换图片&apos;&apos;&apos;class Hero(object): def __init__(self, screen_temp): self.x = 210 self.y = 590 self.image = pygame.image.load(&quot;./feiji/hero1.png&quot;) self.screen = screen_temp self.bullet_list = []#用来存储子弹对象的引用 &quot;&quot;&quot; #爆炸效果用的如下属性 self.hit = False #表示是否要爆炸 self.bomb_list = [] #用来存储爆炸时需要的 图片 self.__crate_images() #调用这个方法向bomb_list中添加图片 self.image_num = 0#用来记录while True的次数,当次数达到一定值时才显示一张爆炸的图,然后清空,,当这个次数再次达到时,再显示下一个爆炸效果的图片 self.image_index = 0#用来记录当前要显示的爆炸效果的图片的序号 def __crate_images(self): self.bomb_list.append(pygame.image.load(&quot;./feiji/hero_blowup_n1.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/hero_blowup_n2.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/hero_blowup_n3.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/hero_blowup_n4.png&quot;)) &quot;&quot;&quot; def display(self, enemy_temp): &quot;&quot;&quot;显示玩家的飞机&quot;&quot;&quot; #如果被击中,就显示爆炸效果,否则显示普通的飞机效果 &quot;&quot;&quot; if self.hit == True: self.screen.blit(self.bomb_list[self.image_index], (self.x, self.y)) self.image_num+=1 if self.image_num == 7: self.image_num=0 self.image_index+=1 if self.image_index&gt;3: time.sleep(1) exit()#调用exit让游戏退出 #self.image_index = 0 &quot;&quot;&quot; #else: self.screen.blit(self.image,(self.x, self.y)) #不管玩家飞机是否被击中,都要显示发射出去的子弹 for bullet in self.bullet_list: bullet.display() bullet.move(enemy_temp) if bullet.judge():#判断子弹是否越界 self.bullet_list.remove(bullet) def move_left(self): self.x -= 8 def move_right(self): self.x += 8 def fire(self): &quot;&quot;&quot;通过创建一个子弹对象,完成发射子弹&quot;&quot;&quot; print(&quot;-----1----&quot;) bullet = Bullet(self.screen, self.x, self.y)#创建一个子弹对象 self.bullet_list.append(bullet) def bomb(self): self.hit = Trueclass Bullet(object): def __init__(self, screen_temp, x_temp, y_temp): self.x = x_temp+40 self.y = y_temp-20 self.image = pygame.image.load(&quot;./feiji/bullet.png&quot;) self.screen = screen_temp def display(self): self.screen.blit(self.image, (self.x, self.y)) def move(self, enemy_temp): if self.x &gt; enemy_temp.x and self.x &lt; enemy_temp.x + 50 and self.y &lt; 40: enemy_temp.bomb() else: self.y -= 20 def judge(self): if self.y&lt;0: return True else: return Falseclass EnemyPlane(object): def __init__(self, screen_temp): self.x = 0 self.y = 0 self.image = pygame.image.load(&quot;./feiji/enemy0.png&quot;) self.screen = screen_temp self.bullet_list = []#用来存储子弹对象的引用 self.direction = &quot;right&quot;#用来设置这个飞机默认的移动方向 #爆炸效果用的如下属性 self.hit = False #表示是否要爆炸 self.bomb_list = [] #用来存储爆炸时需要的 图片 self.__crate_images() #调用这个方法向bomb_list中添加图片 self.image_num = 0#用来记录while True的次数,当次数达到一定值时才显示一张爆炸的图,然后清空,,当这个次数再次达到时,再显示下一个爆炸效果的图片 self.image_index = 0#用来记录当前要显示的爆炸效果的图片的序号 def __crate_images(self): self.bomb_list.append(pygame.image.load(&quot;./feiji/enemy0_down1.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/enemy0_down2.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/enemy0_down3.png&quot;)) self.bomb_list.append(pygame.image.load(&quot;./feiji/enemy0_down4.png&quot;)) def display(self): &quot;&quot;&quot;显示敌人的飞机&quot;&quot;&quot; if self.hit == True: self.screen.blit(self.bomb_list[self.image_index], (self.x, self.y)) self.image_num+=1 if self.image_num == 7: self.image_num=0 self.image_index+=1 if self.image_index&gt;3: time.sleep(1) exit()#调用exit让游戏退出 #self.image_index = 0 else: self.screen.blit(self.image,(self.x, self.y)) for bullet in self.bullet_list: bullet.display() bullet.move() if bullet.judge():#判断子弹是否越界 self.bullet_list.remove(bullet) def move(self): if self.direction == &quot;right&quot;: self.x+=5 elif self.direction == &quot;left&quot;: self.x-=5 if self.x&gt;480-50: self.direction=&quot;left&quot; elif self.x&lt;0: self.direction=&quot;right&quot; def fire(self): random_num = random.randint(1,100) if random_num == 8 or random_num == 20: self.bullet_list.append(EnemyBullet(self.screen, self.x, self.y)) def bomb(self): self.hit = Trueclass EnemyBullet(object): def __init__(self, screen_temp, x, y): self.x = x+25 self.y = y+40 self.screen = screen_temp self.image = pygame.image.load(&quot;./feiji/bullet1.png&quot;) def display(self): self.screen.blit(self.image, (self.x, self.y)) def move(self): self.y+=5 def judge(self): if self.y&gt;720: return True else: return Falsedef key_control(hero_temp): #获取事件，比如按键等 for event in pygame.event.get(): #判断是否是点击了退出按钮 if event.type == QUIT: print(&quot;exit&quot;) exit() #判断是否是按下了键 elif event.type == KEYDOWN: #检测按键是否是a或者left if event.key == K_a or event.key == K_LEFT: print(&apos;left&apos;) hero_temp.move_left() #检测按键是否是d或者right elif event.key == K_d or event.key == K_RIGHT: print(&apos;right&apos;) hero_temp.move_right() #检测按键是否是空格键 elif event.key == K_SPACE: print(&apos;space&apos;) hero_temp.fire() #elif event.key == K_b: #print(&apos;b&apos;) #hero_temp.bomb()def main(): screen = pygame.display.set_mode((480,720),0,32) background = pygame.image.load(&quot;./feiji/background.png&quot;) #创建玩家飞机 hero = Hero(screen) #创建敌机 enemy = EnemyPlane(screen) while True: screen.blit(background,(0,0)) hero.display(enemy) enemy.display() enemy.move() enemy.fire() pygame.display.update() key_control(hero) time.sleep(0.01)if __name__ == &quot;__main__&quot;: main()]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>pygame</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快排]]></title>
    <url>%2F2018%2F09%2F22%2F2018%2F2018-09-22-%E5%BF%AB%E6%8E%92%2F</url>
    <content type="text"><![CDATA[快排算法： 1、快速排序的基本思想：&emsp;&emsp;快排主要使用分治思想，基于pivot，通过一趟排序将待排序列分割成两部分，左边都不大于pivot，右边都不小于pivot。之后分别对这两部分继续进行排序，以达到整个序列有序的目的。 2、快速排序的三个步骤：(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot） ，这里将第一个元素作为第一个基准。(2)分割操作：以pivot为基准分割该序列为两部分。(3)递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。 3、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;#define n 10//对[left, right]进行划分，使pivot 左边都小于该值，右边都大于该值int Part(int A[], int left, int right)&#123; int pivot = A[left]; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; pivot &lt; A[right]) right--; A[left] = A[right]; while(left &lt; right &amp;&amp; pivot &gt;= A[left]) left++; A[right] = A[left]; &#125; A[left] = pivot; return left;&#125;//利用上面的part函数，且采用递归的方式实现快速排序void Quicksort(int A[], int left, int right)&#123; if(left &lt; right) &#123; int temp = Part(A, left, right); Quicksort(A, left, temp-1); Quicksort(A, temp+1, right); &#125;&#125;//对快排进行测试int main(int argc, char const *argv[])&#123; int array[n]; for (int i = 0; i &lt; n; ++i) cin&gt;&gt;array[i]; Quicksort(array, 0, n-1); cout&lt;&lt;array[0]; for (int i = 0; i &lt; n; ++i) cout&lt;&lt;&quot; &quot;&lt;&lt;array[i]; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>QuickSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise_2_老王开枪]]></title>
    <url>%2F2018%2F09%2F20%2Fpython%E9%A1%B9%E7%9B%AE%2F%E8%80%81%E7%8E%8B%E5%BC%80%E6%9E%AA%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一个小小项目，主要练习类，对象的使用流程。下面是代码来自网上学习视频，作为练习所用:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189class Person(object): &quot;&quot;&quot;人的类&quot;&quot;&quot; def __init__(self, name): super(Person, self).__init__() self.name = name self.gun = None#用来保存枪对象的引用 self.hp = 100 def anzhuang_zidan(self, dan_jia_temp, zi_dan_temp): &quot;&quot;&quot;把子弹装到弹夹中&quot;&quot;&quot; #弹夹.保存子弹(子弹) dan_jia_temp.baocun_zidan(zi_dan_temp) def anzhuang_danjia(self, gun_temp, dan_jia_temp): &quot;&quot;&quot;把弹夹安装到枪中&quot;&quot;&quot; #枪.保存弹夹(弹夹) gun_temp.baocun_danjia(dan_jia_temp) def naqiang(self, gun_temp): &quot;&quot;&quot;拿起一把枪&quot;&quot;&quot; self.gun = gun_temp def __str__(self): if self.gun: return &quot;%s的血量为:%d, 他有枪 %s&quot;%(self.name, self.hp, self.gun) else: if self.hp&gt;0: return &quot;%s的血量为%d, 他没有枪&quot;%(self.name, self.hp) else: return &quot;%s 已挂....&quot;%self.name def kou_ban_ji(self, diren): &quot;&quot;&quot;让枪发射子弹去打敌人&quot;&quot;&quot; #枪.开火(敌人) self.gun.fire(diren) def xiao_xue(self, sha_shang_li): &quot;&quot;&quot;根据杀伤力，掉相应的血量&quot;&quot;&quot; self.hp -= sha_shang_liclass Gun(object): &quot;&quot;&quot;枪类&quot;&quot;&quot; def __init__(self, name): super(Gun, self).__init__() self.name = name#用来记录枪的类型 self.danjia = None#用来记录弹夹对象的引用 def baocun_danjia(self, dan_jia_temp): &quot;&quot;&quot;用一个属性来保存这个弹夹对象的引用&quot;&quot;&quot; self.danjia = dan_jia_temp def __str__(self): if self.danjia: return &quot;枪的信息为:%s, %s&quot;%(self.name, self.danjia) else: return &quot;枪的信息为:%s,这把枪中没有弹夹&quot;%(self.name) def fire(self, diren): &quot;&quot;&quot;枪从弹夹中获取一发子弹，然后让这发子弹去击中敌人&quot;&quot;&quot; #先从弹夹中取子弹 #弹夹.弹出一发子弹() zidan_temp = self.danjia.tanchu_zidan() #让这个子弹去伤害敌人 if zidan_temp: #子弹.打中敌人(敌人) zidan_temp.dazhong(diren) else: print(&quot;弹夹中没有子弹了。。。。&quot;)class Danjia(object): &quot;&quot;&quot;弹夹类&quot;&quot;&quot; def __init__(self, max_num): super(Danjia, self).__init__() self.max_num = max_num#用来记录弹夹的最大容量 self.zidan_list = []#用来记录所有的子弹的引用 def baocun_zidan(self, zi_dan_temp): &quot;&quot;&quot;将这颗子弹保存&quot;&quot;&quot; self.zidan_list.append(zi_dan_temp) def __str__(self): return &quot;弹夹的信息为:%d/%d&quot;%(len(self.zidan_list), self.max_num) def tanchu_zidan(self): &quot;&quot;&quot;弹出最上面的那颗子弹&quot;&quot;&quot; if self.zidan_list: return self.zidan_list.pop() else: return Noneclass Zidan(object): &quot;&quot;&quot;子弹类&quot;&quot;&quot; def __init__(self, sha_shang_li): super(Zidan, self).__init__() self.sha_shang_li = sha_shang_li#这颗子弹的威力 def dazhong(self, diren): &quot;&quot;&quot;让敌人掉血&quot;&quot;&quot; #敌人.掉血(一颗子弹的威力) diren.xiao_xue(self.sha_shang_li)def main(): &quot;&quot;&quot;用来控制整个程序的流程&quot;&quot;&quot; #1. 创建老王对象 laowang = Person(&quot;老王&quot;) #2. 创建一个枪对象 ak47 = Gun(&quot;AK47&quot;) #3. 创建一个弹夹对象 dan_jia = Danjia(20) #4. 创建一些子弹 for i in range(15): zi_dan = Zidan(10) #5. 老王把子弹安装到弹夹中 #老王.安装子弹到弹夹中(弹夹，子弹) laowang.anzhuang_zidan(dan_jia, zi_dan) #6. 老王把弹夹安装到枪中 #老王.安装弹夹到枪中(枪，弹夹) laowang.anzhuang_danjia(ak47, dan_jia) #test:测试弹夹的信息 #print(dan_jia) #test:测试枪的信息 #print(ak47) #7. 老王拿枪 #老王.拿枪(枪) laowang.naqiang(ak47) #test:测试老王对象 print(laowang) #8. 创建一个敌人 gebi_laosong = Person(&quot;隔壁老宋&quot;) print(gebi_laosong) #9. 老王开枪打敌人 #老王.扣扳机(隔壁老宋) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang) laowang.kou_ban_ji(gebi_laosong) print(gebi_laosong) print(laowang)if __name__ == &apos;__main__&apos;: main() 配上下面的图更好理解：]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>类，对象</tag>
        <tag>流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1090 危险品装箱 （25 分）]]></title>
    <url>%2F2018%2F09%2F19%2F2018%2F2018-09-19-1090-%E5%8D%B1%E9%99%A9%E5%93%81%E8%A3%85%E7%AE%B1-%EF%BC%8825-%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1090 危险品装箱 （25 分）集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。 输入格式：输入第一行给出两个正整数：N (≤10$^{4}$) 是成对的不相容物品的对数；M (≤100) 是集装箱货品清单的单数。 随后数据分两大块给出。第一块有 N 行，每行给出一对不相容的物品。第二块有 M 行，每行给出一箱货物的清单，格式如下： K G[1] G[2] … G[K]其中 K (≤1000) 是物品件数，G[i] 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。 输出格式：对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No。 输入样例：123456789106 320001 2000220003 2000420005 2000620003 2000120005 2000420004 200064 00001 20004 00002 200035 98823 20002 20003 20006 100103 12345 67890 23333 输出样例：123NoYesYes 解题思路： map&lt;int, vector &gt; mp字典用来将每个物品与其不相容的物品序列配对 a[10000] = {0}：用来标记物品是否存在 vector g(count): 存放每箱物品清单编号 思路：先配对，然后对每箱物品清单的每个物品判断它的不相容数组中是否有标记，有的话no, 用flag == 1表示。最后为1，即有不相容物品对。若最后还是初始时的0则表示无不相容物品对。12345678910111213141516171819202122232425262728#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main() &#123; int n, m, number1, number2; map&lt;int,vector&lt;int&gt;&gt; mp; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;number1&gt;&gt;number2; mp[number1].push_back(number2); mp[number2].push_back(number1); &#125; while (m--) &#123; int count, flag = 0, a[100000] = &#123;0&#125;; scanf(&quot;%d&quot;, &amp;count); vector&lt;int&gt; g(count); for (int i = 0; i &lt; count; i++) &#123; cin&gt;&gt;g[i]; a[g[i]] = 1; &#125; for (int i = 0; i &lt; g.size(); i++) for (int j = 0; j &lt; mp[g[i]].size(); j++) if (a[mp[g[i]][j]] == 1) flag = 1; printf(&quot;%s\n&quot;,flag ==0 ? &quot;Yes&quot; :&quot;No&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm Practice</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>STL</tag>
        <tag>map</tag>
        <tag>配对问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1089 狼人杀-简单版 （20 分）]]></title>
    <url>%2F2018%2F09%2F19%2F2018%2F2018-09-19-1089-%E7%8B%BC%E4%BA%BA%E6%9D%80-%E7%AE%80%E5%8D%95%E7%89%88-%EF%BC%8820-%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1089 狼人杀-简单版 （20 分）以下文字摘自《灵机一动·好玩的数学》：“狼人杀”游戏分为狼人、好人两大阵营。在一局“狼人杀”游戏中，1 号玩家说：“2 号是狼人”，2 号玩家说：“3 号是好人”，3 号玩家说：“4 号是狼人”，4 号玩家说：“5 号是好人”，5 号玩家说：“4 号是好人”。已知这 5 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。扮演狼人角色的是哪两号玩家？本题是这个问题的升级版：已知 N 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。要求你找出扮演狼人角色的是哪几号玩家？ 输入格式：输入在第一行中给出一个正整数 N（5≤N≤100）。随后 N 行，第 i 行给出第 i 号玩家说的话（1≤i≤N），即一个玩家编号，用正号表示好人，负号表示狼人。 输出格式：如果有解，在一行中按递增顺序输出 2 个狼人的编号，其间以空格分隔，行首尾不得有多余空格。如果解不唯一，则输出最小序列解 —— 即对于两个序列 A=a[1],…,a[M] 和 B=b[1],…,b[M]，若存在 0≤ k&lt; M 使得 a[i]=b[i] （i≤k），且 a[k+1]&lt;b[k+1]，则称序列 A 小于序列 B。若无解则输出 No Solution。输入样例 1：5-2+3-4+5+4输出样例 1：1 4输入样例 2：6+6+3+1-5-2+4输出样例 2（解不唯一）：1 5输入样例 3：5-2-3-4-5-1输出样例 3：No Solution 解题思路： speak[k]数组用来保存k号玩家所说的话 lang_hao[k] 表示k号玩家是狼人还是好人，好人为1，狼人为-1 lie[]存放说谎者的序号 思路：先存speak；然后用两循环令i，j为狼人遍历这n个玩家。当狼人确定后，好人同时确认。接着再用一层循环来判断k号玩家是否说谎，说谎者序号放进lie[]。最后，当lie[]数组大小为2且一个为狼人一个为好人时，输出i，j并结束程序。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; speak(n + 1); for (int i = 1; i &lt;= n; ++i) cin&gt;&gt;speak[i]; for (int i = 1; i &lt;= n; ++i)&#123; for (int j = i + 1; j &lt;= n; ++j) &#123; vector&lt;int&gt; lie, lang_hao(n + 1, 1); lang_hao[i] = lang_hao[j] = -1; for(int k = 1; k&lt;=n; k++)&#123; if(speak[k] * lang_hao[abs(speak[k])] &lt; 0) lie.push_back(k); &#125; if(lie.size() == 2 &amp;&amp; lang_hao[lie[0]] + lang_hao[lie[1]] == 0)&#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j; return 0; &#125; &#125; &#125; cout &lt;&lt; &quot;No Solution&quot;; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm Practice</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>STL</tag>
        <tag>狼人杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1088 三人行 （20 分）]]></title>
    <url>%2F2018%2F09%2F19%2F2018%2F2018-09-19-1088-%E4%B8%89%E4%BA%BA%E8%A1%8C-%EF%BC%8820-%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1088 三人行 （20 分）子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。” 本题给定甲、乙、丙三个人的能力值关系为：甲的能力值确定是 2 位正整数；把甲的能力值的 2 个数字调换位置就是乙的能力值；甲乙两人能力差是丙的能力值的 X 倍；乙的能力值是丙的 Y 倍。请你指出谁比你强应“从之”，谁比你弱应“改之”。输入格式：输入在一行中给出三个数，依次为：M（你自己的能力值）、X 和 Y。三个数字均为不超过 1000 的正整数。 输出格式：在一行中首先输出甲的能力值，随后依次输出甲、乙、丙三人与你的关系：如果其比你强，输出 Cong；平等则输出 Ping；比你弱则输出 Gai。其间以 1 个空格分隔，行首尾不得有多余空格。 注意：如果解不唯一，则以甲的最大解为准进行判断；如果解不存在，则输出 No Solution。 输入样例 1：48 3 7输出样例 1：48 Ping Cong Gai输入样例 2：48 11 6输出样例 2：No Solution 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int i, j; int m, x, y; double a[3] = &#123;0&#125;;//丙可能是小数，所以用double cin&gt;&gt;m&gt;&gt;x&gt;&gt;y; for(i = 99; i &gt;= 10; --i)&#123;//i表示甲，j为乙 j = i%10*10 + i/10; if(j * x == y * abs(j - i))&#123;1089 狼人杀-简单版 （20 分） printf(&quot;%d&quot;,i); a[0] = i; a[1] = j; a[2] = j * 1.0/y; break; &#125; &#125; for(int i = 0; i &lt; 3; i++)&#123; if(a[i] == 0) &#123; printf(&quot;No Solution&quot;); break; &#125; else if(m &gt; a[i]) printf(&quot; Gai&quot;); else if(m == a[i]) printf(&quot; Ping&quot;); else printf(&quot; Cong&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm Practice</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1087 有多少不同的值]]></title>
    <url>%2F2018%2F09%2F19%2F2018%2F2018-09-19-1087-%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[1087 有多少不同的值 （20 分）&emsp;&emsp;当自然数 n 依次取 1、2、3、……、N 时，算式 ⌊n/2⌋+⌊n/3⌋+⌊n/5⌋ 有多少个不同的值？（注：⌊x⌋ 为取整函数，表示不超过 x 的最大自然数，即 x 的整数部分。）输入格式：输入给出一个正整数 N（2 ≤ N ≤ 10$^{4}$)。1088 三人行 （20 分）输出格式：在一行中输出题面中算式取到的不同值的个数。 输入样例：12017 输出样例：11480 有两种解法：第一种：12345678910111213141516171819#include &lt;iostream&gt;using namespace std;const int maxn = 100001;int main() &#123; bool flag[maxn] = &#123;false&#125;;//通过hash表来去重 int n, temp; cin&gt;&gt;n; for (int i = 1; i &lt;= n; i++) &#123; temp = i/2 +i/3 + i/5; flag[temp] = true; &#125; int count = 0; for(int i = 0; i &lt; maxn; i++)&#123; if(flag[i] == true) count++; &#125; cout&lt;&lt;count&lt;&lt;endl; return 0;&#125; 第二种：123456789101112131415#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); set&lt;int&gt; st; //通过集合来去重 for (int i = 1; i &lt;= n; i++) &#123; st.insert(i/2 + i/3 + i/5); &#125; printf(&quot;%d&quot;, st.size()); return 0;&#125; &emsp;&emsp;太简单了没啥好讲的。。。]]></content>
      <categories>
        <category>Algorithm Practice</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1086 就不告诉你 （15 分）]]></title>
    <url>%2F2018%2F09%2F18%2F2018%2F2018-09-18-1086-%E5%B0%B1%E4%B8%8D%E5%91%8A%E8%AF%89%E4%BD%A0-%EF%BC%8815-%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1086 就不告诉你 （15 分）&emsp;&emsp;做作业的时候，邻座的小盆友问你：“五乘以七等于多少？”你应该不失礼貌地围笑着告诉他：“五十三。”本题就要求你，对任何一对给定的正整数，倒着输出它们的乘积。 输入格式：&emsp;&emsp;输入在第一行给出两个不超过 1000 的正整数 A 和 B，其间以空格分隔。 输出格式：&emsp;&emsp;在一行中倒着输出 A 和 B 的乘积。输入样例：15 7 输出样例：153 注意：100的倒序为1。这个很重要，没有得满分的基本都是没注意这点，其他没啥好讲的。 1234567891011121314151617181920#include &lt;cstdio&gt;int main()&#123; int a, b, count = 0, c, ans[10];//基本输入和计算 bool flag = false; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); c = a * b; while(c &gt; 0)&#123;//得到倒序的各元素数组 ans[count++] = c % 10; c /= 10; &#125; for(int i = 0; i &lt; count; i++) &#123;//将前面的0去掉 if(ans[i] != 0) flag = true; if(flag == true) printf(&quot;%d&quot;, ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm Practice</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise_1]]></title>
    <url>%2F2018%2F09%2F16%2Fpython%E9%A1%B9%E7%9B%AE%2Fpython%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[这个系统非常简单，主要目的是练习python的基本操作 下面是主要功能:12345678 名片管理系统 V0.011. 添加一个新名片2. 删除一个名片3. 修改一个名片4. 查询一个名片5. 显示所有名片6. 保存名片7. 退出系统 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127# -*- coding: utf-8 -*-card_infors = []def print_menu(): &quot;&apos;完成打印功能菜单&apos;&quot; print(&quot;=&quot; * 50) print(&quot; 名片管理系统 V0.01&quot;) print(&quot;1. 添加一个新名片&quot;) print(&quot;2. 删除一个名片&quot;) print(&quot;3. 修改一个名片&quot;) print(&quot;4. 查询一个名片&quot;) print(&quot;5. 显示所有名片&quot;) print(&quot;6. 保存名片&quot;) print(&quot;7. 退出系统&quot;) print(&quot;=&quot; * 50)def add_new_card_infor(): &quot;&apos;完成添加一个新名片&apos;&quot; new_name = input(&quot;请输入新的名字:&quot;) new_qq = input(&quot;请输入新的QQ:&quot;) new_weixin = input(&quot;请输入新的微信:&quot;) new_addr = input(&quot;请输入新的住址:&quot;) #定义一个新的字典,用来存储一个新的名片 new_infor = &#123;&#125;5 new_infor[&apos;name&apos;] = new_name new_infor[&apos;qq&apos;] = new_qq new_infor[&apos;weixin&apos;] = new_weixin new_infor[&apos;addr&apos;] = new_addr #将一个字典,添加到列表中 global card_infors card_infors.append(new_infor) #print(card_infors)# for testdef find_card_infor(): &quot;&quot;&quot;用来查询一个名片&quot;&quot;&quot; global card_infors find_name = input(&quot;请输入要查找的姓名:&quot;) find_flag = 0#默认表示没有找到 for temp in card_infors: if find_name == temp[&quot;name&quot;]: print(&quot;%s\t%s\t%s\t%s&quot;%(temp[&apos;name&apos;], temp[&apos;qq&apos;], temp[&apos;weixin&apos;], temp[&apos;addr&apos;])) find_flag=1#表示找到了 break #判断是否找到了 if find_flag == 0: print(&quot;查无此人....&quot;)def show_all_infor(): &quot;&quot;&quot;显示所有的名片信息&quot;&quot;&quot; global card_infors print(&quot;姓名\tQQ\t微信\t住址&quot;) for temp in card_infors: print(&quot;%s\t%s\t%s\t%s&quot;%(temp[&apos;name&apos;], temp[&apos;qq&apos;], temp[&apos;weixin&apos;], temp[&apos;addr&apos;]))def save_2_file(): &quot;&quot;&quot;把已经添加的信息保存到文件中&quot;&quot;&quot; f = open(&quot;backup.data&quot;, &quot;w&quot;) f.write(str(card_infors)) f.close()def load_infor(): global card_infors try: f = open(&quot;backup.data&quot;) card_infors = eval(f.read()) f.close() except Exception: passdef main(): &quot;&quot;&quot;完成对整个程序的控制&quot;&quot;&quot; #恢复(加载)之前的数据到程序中 load_infor()#刚开始启动程序就会加载内容，所以刚开始由于没有back.data文件会报错#但第二次运行时由于前面已经创建了文件不会报错，所以在load_infor()#函数中使用try，Exception #1. 打印功能提示 print_menu() while True: #2. 获取用户的输入 num = int(input(&quot;请输入操作序号:&quot;)) #3. 根据用户的数据执行相应的功能 if num==1: add_new_card_infor() elif num==2: pass elif num==3: pass elif num==4: find_card_infor() elif num==5: show_all_infor() elif num==6: save_2_file() elif num==7: break else: print(&quot;输入有误,请重新输入&quot;) print(&quot;&quot;)if __name__ == &quot;__main__&quot;: //用于测试中，当调用别的模块时，值为别的模块名字符串，调用自己时为&quot;__main__&quot; #调用主函数 main() &emsp;&emsp;该项目是学习过程中，参照学习视频所做的练习题]]></content>
      <categories>
        <category>Python Exercise</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 使用指南一]]></title>
    <url>%2F2018%2F09%2F16%2Fmarkdown%E4%BD%BF%E7%94%A8%2Fmarkdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%E4%B8%80%2F</url>
    <content type="text"><![CDATA[markdown 使用指南一 目录: 基本操作 专用操作 Markdow工具 1. 基本语法： 字体常见设置：下划线，加粗，删除线 字体深度设置：字体，字号，颜色，背景色 分级标题 分割线 链接 引用 列表 Todo列表 行首缩进，换行 特殊字符输入 (1) 字体常见设置：斜体，加粗，删除线&emsp;&emsp; 用一对单星号把要处理的文字包起来就会呈现斜体；用一对双星号把要处理的文字包起来就会呈现加粗；用一对双波浪线把要处理的文字包起来就会呈现斜体。1234*感觉萌萌哒***感觉萌萌哒*****感觉萌萌哒***~~ 感觉萌萌哒~~ 效果如下： 感觉萌萌哒感觉萌萌哒感觉萌萌哒感觉萌萌哒 (2) 字体深度设置：字体，字号，颜色，背景色markdown本身不支持修改字体、字号与颜色等功能，但是使用内嵌HTML的方法来实现。123&lt;font face=&quot;微软雅黑&quot;&gt;感觉萌萌哒&lt;/font&gt;&lt;font color=#0000ff size=5 face=&quot;黑体&quot;&gt;感觉萌萌哒&lt;/font&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=yellow&gt;感觉萌萌哒&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果如下： 感觉萌萌哒 感觉萌萌哒 感觉萌萌哒 注意：Size：字体大小，范围是1到7，浏览器默认值是3。 (3) 分级标题12345使用#来实现分级标题，使用&lt;center&gt;&lt;/center&gt;来居中# 感觉萌萌哒## 感觉萌萌哒### 感觉萌萌哒### &lt;center&gt;感觉萌萌哒&lt;/center&gt; 效果如下： 感觉萌萌哒感觉萌萌哒感觉萌萌哒感觉萌萌哒(4) 分割线三个连续星号(*)、减号(-)、底线(_)来实现123***---___ 效果如下： (5) 链接a. 插入图片12格式：![图片描述](图片本地或互联网url)例如：![女神刘亦菲](http://imgup02.iefans.net/iefans/2018-08/15/10/15343018604507_0.jpg) 效果如下： b. 文字加链接12格式：[文字或(本地图片位置)](url)例如：[女神刘亦菲](http://imgup02.iefans.net/iefans/2018-08/15/10/15343018604507_0.jpg) 效果如下：女神刘亦菲 c. 图片加链接12格式：[![图片描述](图片互联网url或这本地相对链接)](url)例如：[![女神刘亦菲](http://imgup02.iefans.net/iefans/2018-08/15/10/15343018604507_0.jpg)](http://imgup02.iefans.net/iefans/2018-08/15/10/15343018604507_0.jpg) 效果如下： (6) 引用 在正文前使用&gt;符号和空格 123&gt; 感觉萌萌哒&gt;&gt; 感觉萌萌哒&gt;&gt;&gt; 感觉萌萌哒 效果如下： 感觉萌萌哒 感觉萌萌哒 感觉萌萌哒 (7) 列表 列表有两种：无序列表和有序列表 a. 无序列表: 使用 *，+，-，再加上一个空格1234我是无序列表：- 萌萌哒一遍- 萌萌哒二遍- 萌萌哒三遍 我是无序列表： 萌萌哒一遍 萌萌哒二遍 萌萌哒三遍 c. 有序列表：使用数字和一个英文句点，再加上一个空格1234我是有序列表：1. 萌萌大2. 萌萌中3. 萌萌小 效果如下： 我是有序列表： 萌萌大 萌萌中 萌萌小 (8) Todo列表 用- [ ]，- [X]表示事件有没有完成(减号空格左中括号空格右中括号，减号空格左中括号x大写或小写右中括号。都这么直接了，应该不会用错了吧) 如图 今天要做的事： 吃饭 看剧 写代码 上课 (9) 行首缩进，换行直接在 Markdown 里用空格和 Tab 键缩进在渲染后会被忽略掉，需要借助 HTML 转义字符在行首添加空格来实现，&ensp; 代表半角空格，&emsp; 代表全角空格。换行：连续两个以上空格+回车或者举个栗子：1&amp;emsp;&amp;emsp;你爱不爱我，我都是萌萌哒。&lt;br&gt;感觉萌萌哒&lt;br/&gt;萌萌哒 示例效果： &emsp;&emsp;你爱不爱我，我都是萌萌哒。感觉萌萌哒萌萌哒 (10) 特殊字符输入a. 前面加反斜线\ 即可显示符号本身。12345678\\\*\.\_\-\#\&#123;\&#125;\! 效果如下：\*._-#{}!b. 特殊的转义字符12345678910111213141516171819符号 说明 对应编码¶ 段落符号 &amp;para;§ 章节符 &amp;sect;± 加减号 &amp;plusmn;ƒ function &amp;fnof;√ 根号 &amp;radic;∞ 无穷大 &amp;infin;° 度 &amp;deg;≠ 不等号 &amp;ne;≡ 恒等于 &amp;equiv;≤ 小于等于 &amp;le;≥ 大于等于 &amp;ge;♠ 黑桃 &amp;spades;♥ 红桃 &amp;hearts;♣ 梅花 &amp;clubs;♦ 方块 &amp;diams;举个栗子：黑桃&amp;spades;大于红桃&amp;hearts;大于梅花&amp;clubs;方块&amp;diams;不管是人民币&amp;yen;、欧元&amp;euro;、英磅&amp;pound;还是美元 &amp;dollar;，我都喜欢。 效果：黑桃&spades;大于红桃&hearts;大于梅花&clubs;方块&diams;不管是人民币&yen;、欧元&euro;、英磅&pound;还是美元 &dollar;，我都喜欢。本特殊符号来源自该博文 &emsp;&emsp;终于写完了第一个博客，作为一个糙老爷们用了这么多萌萌哒，我先吐会儿。。。。 &emsp;&emsp;等我吐完了再来接着写第二篇哈。。。。 本文参考文章： https://blog.csdn.net/jaywon/article/details/77992082 https://www.jianshu.com/p/c0a2897ad4eb https://blog.csdn.net/u010177286/article/details/50358720]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
</search>
